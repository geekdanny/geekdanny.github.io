<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C标准库 POSIX库 glibc库有什么关系</title>
      <link href="/2022/04/20/5398/"/>
      <url>/2022/04/20/5398/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准函数库（C-standard-library，缩写：libc）"><a href="#C-标准函数库（C-standard-library，缩写：libc）" class="headerlink" title="C 标准函数库（C standard library，缩写：libc）"></a>C 标准函数库（C standard library，缩写：libc）</h2><p>标准函数库通常会随附在编译器上。windows系统和Linux系统下都可以尽情使用。是最基本的C函数库，也叫ANSI C。ANSI C共包括15个头文件。1995年，Normative Addendum 1 （NA1）批准了3个头文件（iso646.h、wchar.h和wctype.h）增加到C标准函数库中。C99标准增加了6个头文件（complex.h、fenv.h、inttypes.h、stdbool.h、stdint.h和tgmath.h）。</p><p>C11标准中又新增了5个头文件（stdalign.h、stdatomic.h、stdnoreturn.h、threads.h和uchar.h）。至此，C标准函数库共有29个头文件。总而言之，几乎在任何平台上的 C 语言 (包括非 UNIX 平台) 都支持此标准。</p><h2 id="ISO-C"><a href="#ISO-C" class="headerlink" title="ISO C"></a>ISO C</h2><p>这个东西其实也是一个标准，保证在各个平台上使用各个编译器对同一份源码能编译出相同的结果。<br>ISO C是从ANSI C继承而来，也可以叫Standard C，其实可以理解为是一样的东西，就是C的标准。<br>但是既然把他归类到POSIX下，那就肯定是跟POSIX有点关系呀~<br>ISO C其实是POSIX的一个子集，除此之外，它还包含各种系统服务接口，如socket等。但是ISO C还是领先于POSIX的，很多C的新标准并没有进入POSIX中，比如线程相关部分。<br>C中还有一个Posix库，他就是基于POSIX标准定义的一套头文件实现的lib库。</p><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>是 Portable Operating System Interface(可移植操作系统接口) 的缩写，X表示UNIX，它是 ISO C 的延伸，明定了一个可移植的操作系统所应具备的种种条件，其范围不只有系统函数库而已。POSIX库 就是C POSIX library。C POSIX library是C语言的POSIX系统下的标准库。包含了一些在C语言标准库之外的函数。为了OS之间的可移植性，POSIX标准规定了一些标准的接口。而这些接口标准的集合就是POSIX库。</p><h2 id="GNU-C库（英语：GNU-C-Library，常简称为glibc）"><a href="#GNU-C库（英语：GNU-C-Library，常简称为glibc）" class="headerlink" title="GNU C库（英语：GNU C Library，常简称为glibc）"></a>GNU C库（英语：GNU C Library，常简称为glibc）</h2><p>是一种按照LGPL许可协议发布的，自由的，公开源代码的函数库。既包含C标准库，也包含POSIX库。glibc是linux下面c标准库的实现，即GNU C Library。glibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准c库，而Linux下原来的标准c库Linux libc逐渐不再被维护。Linux下面的标准c库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6<br>glibc库不但包含标准C库的所有头文件，还包含了所有POSIX库的头文件。</p><p>如果对POSIX不了解建议先了解下POSIX，参见POSIX是什么有什么用。</p><p><img src="https://s2.loli.net/2022/04/21/JVjPkp1tIU8xmZ6.png" alt="JVjPkp1tIU8xmZ6"></p><p>POSIX是标准C库的超集，需要注意的是，它遵从标准C库。如果C和POSIX发生冲突，C获胜。</p><p>套接字、文件描述符、共享内存等都是POSIX的一部分，但在C库中不存在。</p><p><code>pthread.h</code>用于POSIX线程，<code>threads.h</code>是C11的新头，是C库的一部分。也许pthread在将来的某个时候会被弃用，取而代之的是C线程，但是你可能还不能指望C11能得到广泛的部署。因此，如果你想要可移植性，你现在应该更喜欢pthreads。如果可移植性不是一个问题，并且您有C11线程可用，那么您可能应该使用这些线程。</p><h2 id="Linux系统下各个库头文件位置"><a href="#Linux系统下各个库头文件位置" class="headerlink" title="Linux系统下各个库头文件位置"></a>Linux系统下各个库头文件位置</h2><p>以CentOS7为例。通过查看CentOS下标准C库，glibc库，POSIX库头文件的位置，可以对它们的关系有更直接的理解。</p><p>一般linux系统把gcc和glibc都安装到/usr/目录，所以gcc可执行文件在/usr/bin目录下，而glibc的库文件在/usr/lib目录下，glibc的头文件在/usr/include目录下。</p><p>当然上述的关系并不是一定的，在安装gcc和glibc的时候可以手工指定。可以使用命令“gcc -print-search-dirs”来查看gcc库的搜索路径</p><p>详细的可以看这篇文章 Linux头文件和库的搜索路径</p><h2 id="C标准库头文件的位置"><a href="#C标准库头文件的位置" class="headerlink" title="C标准库头文件的位置"></a>C标准库头文件的位置</h2><p>连接：<a href="https://zh.cppreference.com/w/c/header">C 标准库头文件</a></p><p><img src="https://s2.loli.net/2022/04/21/Vm9R8kwcafqDQTt.png" alt="Vm9R8kwcafqDQTt"></p><p>这些头文件放在哪些目录下取决于不同的编译器，在我的系统上(CentOS7)，stdio.h、stdlib.h、time.h、math.h、assert.h等位于/usr/include目录下，stdarg.h和stddef.h等位于/usr/lib/gcc/x86_64-redhat-linux/4.8.2/include目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/include</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.8.2/include</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/21/BAZ9y48Nso5kUXL.png" alt="BAZ9y48Nso5kUXL"></p><h2 id="POSIX库头文件的位置"><a href="#POSIX库头文件的位置" class="headerlink" title="POSIX库头文件的位置"></a>POSIX库头文件的位置</h2><p>链接：<a href="https://pubs.opengroup.org/onlinepubs/9699919799/">POSIX.1 and ISO C标准头文件</a></p><p><strong>ISO C标准定义的头文件(24项)</strong></p><p>&lt;assert.h&gt;    ———————-  验证程序断言</p><p>&lt;complex.h&gt;  ———————-  支持复数算术运算</p><p>&lt;ctype.h&gt;    ———————-  字符类型</p><p>&lt;errno.h&gt;    ———————-  出错码</p><p>&lt;fenv.h&gt;     ———————-  浮点环境</p><p>&lt;float.h&gt;     ———————-  浮点常量</p><p>&lt;inttypes.h&gt;  ———————-  整型格式转换</p><p>&lt;iso646.h&gt;   ———————-  替代关系操作符宏</p><p>&lt;limits.h&gt;     ———————-  实现常量</p><p>&lt;locale.h&gt;    ———————-  局部类别</p><p>&lt;math.h&gt;     ———————-  数学常量</p><p>&lt;setjmp.h&gt;   ———————-  非局部goto</p><p>&lt;signal.h&gt;    ———————-  信号</p><p>&lt;stdarg.h&gt;   ———————-  可变参数表</p><p>&lt;stdbool.h&gt;   ———————-  布尔类型和值</p><p>&lt;stddef.h&gt;    ———————-  标准定义</p><p>&lt;stdint.h&gt;    ———————-  整型</p><p>&lt;stdio.h&gt;     ———————-  标准I/O库</p><p>&lt;stdlib.h&gt;    ———————-  实用程序库函数</p><p>&lt;string.h&gt;    ———————-  字符串操作</p><p>&lt;tgmath.h&gt;   ———————-  通用类型数学宏</p><p>&lt;time.h&gt;     ———————-  时间和日期</p><p>&lt;wchar.h&gt;   ———————-  扩展的多字节和宽字符支持</p><p>&lt;wctype.h&gt;   ———————-  宽字符分类和映射支持</p><p>sys开头的是Linux系统自己的头文件，sys文件夹在Ubuntu 18.04中的路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/i</span>nclude<span class="regexp">/x86_64-linux-gnu/</span>sys</span><br></pre></td></tr></table></figure><p><strong>POSIX标准定义的必须的头文件(26项)</strong></p><p>&lt;dirent.h&gt;   ———————-  目录项</p><p>&lt;fcntl.h&gt;     ———————-  文件控制</p><p>&lt;fnmatch.h&gt;  ———————-  文件名匹配类型</p><p>&lt;glob.h&gt;     ———————-  路径名模式匹配类型</p><p>&lt;grp.h&gt;     ———————-  组文件</p><p>&lt;netdb.h&gt;   ———————-  网络数据库操作</p><p>&lt;pwd.h&gt;     ———————-  口令文件</p><p>&lt;regex.h&gt;   ———————-  正则表达式</p><p>&lt;tar.h&gt;      ———————-  tar归档值</p><p>&lt;termios.h&gt;   ———————-  终端I/O</p><p>&lt;unistd.h&gt;   ———————-  符号常量</p><p>&lt;utime.h&gt;    ———————-  文件时间</p><p>&lt;wordexp.h&gt;  ———————-  字扩展类型</p><p>&lt;arpa/inet.h&gt; ———————-  Internet定义</p><p>&lt;net/if..h&gt;    ———————-  套接字本地接口</p><p>&lt;netinet/in.h&gt; ———————-  Internet地址族</p><p>&lt;netinet/tcp.h&gt;———————-  传输控制协议定义</p><p>&lt;sys/mman.h&gt;———————-  内存管理声明</p><p>&lt;sys/select.h&gt;———————-  select函数</p><p>&lt;sys/socket.h&gt;———————-  套接字接口</p><p>&lt;sys/stat.h&gt;  ———————-  文件状态</p><p>&lt;sys/times.h&gt; ———————-  进程时间</p><p>&lt;sys/types.h&gt; ———————-  基本系统数据类型</p><p>&lt;sys/un.h&gt;   ———————-  UNIX域套接字定义</p><p>&lt;sys/utsname.h&gt;———————-系统名</p><p>&lt;sys/wait.h&gt;  ———————-  进程控制</p><p><strong>POSIX标准定义的XSI扩展头文件(26项)</strong></p><p>&lt;cpio.h&gt;     ———————-  cpio归档值</p><p>&lt;dlfcn.h&gt;     ———————-  动态链接</p><p>&lt;fmtmsg.h&gt;   ———————-  消息显示结构</p><p>&lt;ftw.h&gt;      ———————-  文件树漫游</p><p>&lt;iconv.h&gt;    ———————-  代码集转换实用程序</p><p>&lt;langinfo.h&gt;  ———————-  语言信息常量</p><p>&lt;libgen.h&gt;    ———————-  模式匹配函数定义</p><p>&lt;monetary.h&gt; ———————-  货币类型</p><p>&lt;ndbm.h&gt;    ———————-  数据库操作</p><p>&lt;nl_types.h&gt;  ———————-  消息类别</p><p>&lt;poll.h&gt;      ———————-  轮询函数</p><p>&lt;search.h&gt;   ———————-  搜索表</p><p>&lt;strings.h&gt;   ———————-  字符串操作</p><p>&lt;syslog.h&gt;   ———————-  系统出错日志记录</p><p>&lt;ucontext.h&gt;  ———————-  用户上下文</p><p>&lt;ulimit.h&gt;    ———————-  用户限制</p><p>&lt;utmpx.h&gt;    ———————-  用户帐户数据库</p><p>&lt;sys/ipc.h&gt;   ———————-  IPC</p><p>&lt;sys/msg.h&gt;  ———————-  消息队列</p><p>&lt;sys/resource.h&gt;——————-  资源操作</p><p>&lt;sys/sem.h&gt;  ———————-  信号量</p><p>&lt;sys/shm.h&gt;  ———————-  共享存储</p><p>&lt;sys/statvfs.h&gt;———————-  文件系统信息</p><p>&lt;sys/time.h&gt;   ———————-  时间类型</p><p>&lt;sys/timeb.h&gt; ———————-  附加的日期和时间定义</p><p>&lt;sys/uio.h&gt;   ———————-  矢量I/O操作</p><p><strong>POSIX标准定义的可选头文件(8项)</strong></p><p>&lt;aio.h&gt;      ———————-  异步I/O</p><p>&lt;mqueue.h&gt;  ———————-  消息队列</p><p>&lt;pthread.h&gt;  ———————-  线程</p><p>&lt;sched.h&gt;    ———————-  执行调度</p><p>&lt;semaphore.h&gt;———————  信号量</p><p>&lt;spawn.h&gt;    ———————-  实时spawn接口</p><p>&lt;stropts.h&gt;   ———————-  XSI STREAMS接口</p><p>&lt;trace.h&gt;     ———————-  时间跟踪</p><p><img src="https://s2.loli.net/2022/04/21/Pqsric4VLGhE7Rn.png" alt="bjrqgJA2iBhLVvP"></p><h2 id="glibc库头文件的存放位置"><a href="#glibc库头文件的存放位置" class="headerlink" title="glibc库头文件的存放位置"></a>glibc库头文件的存放位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/include</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）</li><li>POSIX标准意在期望获得源代码级别的软件可移植性。</li></ol><p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</p><p>在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE的一组标准组成，其目标是提供一套大体上基于Unix的可移植操作系统标准。Linux是与POSIX兼容的。</p><p> POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关系。实际上，POSIX标准就是仿照早期Unix系统的界面建立的。另一方面，许多操作系统，像Windows NT，尽管和Unix没有什么关系，也提供了与POSIX兼容的库。</p><p> Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如图5-1所示。如图5-1所示C库实现了Unix系统的主要API，包括标 准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C库提供了POSIX的 绝大部分API。</p><p> 从程序员的角度看，系统调用无关紧要；他们只需要跟API打交道就可以了。</p><p> 相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</p><p>完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，</p><p>例如创建进程：</p><ul><li>linux下是fork函数</li><li>windows下是creatprocess函数。</li></ul><p>好，我现在在linux下写一个程序，用到fork函数，那么这个程序该怎么往windows上移植？我需要把源代码里的fork通通改成creatprocess，然后重新编译…</p><p>posix标准的出现就是为了解决这个问题。linux和windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess函数也封装成posix_fork，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了</p><h2 id="官方回答："><a href="#官方回答：" class="headerlink" title="官方回答："></a>官方回答：</h2><p>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。</p><p>POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统（即使是来自另一个厂商）上编译执行。</p><p>POSIX 并不局限于 UNIX。许多其它的操作系统，例如 DEC OpenVMS 支持 POSIX 标准，尤其是 IEEE Std. 1003.1-1990（1995 年修订）或 POSIX.1，POSIX.1 提供了源代码级别的 C 语言应用编程接口（API）给操作系统的服务程序，例如读写文件。POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些常见的国际标准化组织</title>
      <link href="/2022/04/20/49da/"/>
      <url>/2022/04/20/49da/</url>
      
        <content type="html"><![CDATA[<h2 id="ITU-International-Telecommunication-Union"><a href="#ITU-International-Telecommunication-Union" class="headerlink" title="ITU (International Telecommunication Union)"></a>ITU (International Telecommunication Union)</h2><p><a href="http://baike.baidu.com/view/26606.htm">国际电信联盟</a>， 成立于1865年，主要定义电信标准<br>网址： <a href="http://ietf.org/">http://itu.int/ITU-T</a><br>文档下载： <a href="http://www.itu.int/rec/T-REC/en">http://www.itu.int/rec/T-REC/en</a><br>例子： 如视频编码H.264, 音频编码G.731等，我查找的视频和网络会议相关的H.323和T.120协议都可以在这里找到</p><h2 id="IETF-Internet-Engineering-Task-Force"><a href="#IETF-Internet-Engineering-Task-Force" class="headerlink" title="IETF (Internet Engineering Task Force)"></a>IETF (Internet Engineering Task Force)</h2><p><a href="http://baike.baidu.com/view/1451264.htm">互联网工程任务组</a>， 成立于1985年，主要定义互联网标准<br>网址： <a href="http://ietf.org/">http://ietf.org</a><br>文档下载： <a href="http://www.ietf.org/rfc.html">http://www.ietf.org/rfc.html</a><br>例子： 我们平时提到的RFC文档都是他们的产物，例如常见的网络协议:<br>IP：791     TCP：793      UDP：768       FTP：959        HTTP1.1：2616</p><h2 id="IEEE-Institute-of-Electrical-and-Electronics-Engineers"><a href="#IEEE-Institute-of-Electrical-and-Electronics-Engineers" class="headerlink" title="IEEE (Institute of Electrical and Electronics Engineers)"></a>IEEE (Institute of Electrical and Electronics Engineers)</h2><p><a href="http://baike.baidu.com/view/1164737.htm?from_id=150905&type=syn&fromtitle=IEEE&fr=aladdin">电气和电子工程师协会</a>, 成立于1961年, 主要致力于电气、电子、计算机工程和与科学有关的领域的开发和研究<br>网址: <a href="http://www.ieee.org/">http://www.ieee.org/</a><br>例子： IEEE 754 浮点 算法规范      IEEE 802 局域网标准</p><h2 id="ANSI-AMERICAN-NATIONAL-STANDARDS-INSTITUTE"><a href="#ANSI-AMERICAN-NATIONAL-STANDARDS-INSTITUTE" class="headerlink" title="ANSI (AMERICAN NATIONAL STANDARDS INSTITUTE)"></a>ANSI (AMERICAN NATIONAL STANDARDS INSTITUTE)</h2><p><a href="http://baike.baidu.com/view/1501471.htm">美国国家标准学会</a>, 成立于1918年， 实际上成了国家标准化中心<br>网址: <a href="http://www.ansi.org/">http://www.ansi.org/</a><br>例子： ASCII编码， ANSI C</p><h2 id="EC-International-Electro-technical-Commission"><a href="#EC-International-Electro-technical-Commission" class="headerlink" title="EC (International Electro technical Commission)"></a>EC (International Electro technical Commission)</h2><p><a href="http://baike.baidu.com/view/159311.htm">国际电工委员会</a>, 成立于1906年， 是世界上成立最早的非政府性国际电工标准化机构<br>网址： <a href="http://www.iec.ch/">http://www.iec.ch/</a><br>例子： 静电标准IEC61340</p><h2 id="ISO-International-Organiza-tion-for-Standardization"><a href="#ISO-International-Organiza-tion-for-Standardization" class="headerlink" title="ISO (International Organiza,tion for Standardization)"></a>ISO (International Organiza,tion for Standardization)</h2><p><a href="http://baike.baidu.com/view/1304148.htm?fr=aladdin">国际标准化组织</a>， 成立于1926年，主要制订国际标准<br>网址： <a href="http://www.iso.org/">http://www.iso.org/</a><br>例子： ISO9001、ISO libC</p><p>ITU最老，IETF最新，这方面也体现电信向互联网的转变， 同时感慨大部分技术标准基本都是美国那边制订。</p><p>原文引用：<a href="https://www.cnblogs.com/wfwenchao/p/5209100.html">https://www.cnblogs.com/wfwenchao/p/5209100.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组织和协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骁龙8Gen1 SoC 在ARMv9上的落地表现</title>
      <link href="/2021/12/12/dd3a/"/>
      <url>/2021/12/12/dd3a/</url>
      
        <content type="html"><![CDATA[<p>前不久，高通发布了骁龙8Gen1 SoC。也是骁龙第一款采用ARMv9架构的芯片。虽然ARM官方声称ARMv9的新架构带来了性能收益，但是，一个采用了ARM 架构的SoC具体的性能提升还牵扯到很多其他因素，例如制程工艺，软硬协同，Cache大小等。作为高通第一款采用ARMv9新架构的芯片，具体变现如何呢？我们来看一下。</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>高通新的SoC采用ARM的<strong>1+3+4 CPU Core</strong>的组合结构。超大核升级到了X2，中核用了A710，小核则去掉了垃圾的A55，采用了A510。</p><p><img src="https://s2.loli.net/2021/12/13/f93YwJV1RTSMNbx.png" alt="PLUR8BTzrNAHE7Q"></p><p><strong>X2核</strong>的升级本次并不是很大，<strong>它把流水线从11缩到了10，乱序执行窗口稍微增大了一点，改进了分支预测，并完全<em>剔除</em>了对32微程序的支持</strong>。</p><p><img src="https://s2.loli.net/2021/12/13/kUB47bfOexJRKu5.png" alt="image-20211212101007636"></p><p>但是X2总体来讲本质跟之前几代产品相比在设计上是没有巨大的变化的，它依然是美国奥斯汀团队在A76基础上的升级。真正的全新升级，我们可能要等到2022年法国的索菲亚团队的全新设计。</p><p><img src="https://s2.loli.net/2021/12/13/lE4y7Pz1mvonKsc.png" alt="gwOGeZrk3MnqPlp"></p><p><strong>A710核</strong>本质上也是没有本质上的架构变化。也只是在A78上做了改进。</p><p><img src="https://s2.loli.net/2021/12/13/YksAnQOaRmy4SLx.png" alt="H3mXcOvaMCEzrsZ"></p><p>但是从ARM的PPT可以看出来它的<strong>功耗</strong>还是有所期待。</p><p><img src="https://s2.loli.net/2021/12/13/mep5jx9urFHAIob.png" alt="gY57zCxW69UciAM"></p><p>A710有一个特点就是为了满足中国市场的需求，保留对32位的App的支持。</p><p><img src="https://s2.loli.net/2021/12/13/KEVcLogWB7b4XFI.png" alt="9qdA8zCRxNGp2TY"></p><p>A510这次是最亮眼，终于淘汰了5年不变的A55。这次A510的性能比A55提升了<strong>35%~50%</strong>的IPC。</p><p><img src="https://s2.loli.net/2021/12/13/FYsKDAUHN6Cn4cB.png" alt="FYsKDAUHN6Cn4cB"></p><p><img src="https://s2.loli.net/2021/12/13/8wLrBV9cJO6ZUYf.png" alt="8wLrBV9cJO6ZUYf"></p><p><img src="https://s2.loli.net/2021/12/13/JpfNZyjVHxcd9lL.png" alt="JpfNZyjVHxcd9lL"></p><p>虽然A510的进步很明显，但是更多是通过<strong>加宽解码</strong>和<strong>加大ALU</strong>来实现的。例如，升级到<strong>3解码3发射</strong>，<strong>后端3组ALU</strong>。所以，虽然性能提高了，但是他的<strong>能耗比</strong>没有多大的提升。虽然性能强了不少，但是并没有更节能。最关键的是它依然是个顺序执行的处理器，做得再大依然是个小核。</p><p><img src="https://s2.loli.net/2021/12/13/GHPmfi8eaCb653x.png" alt="image-20211212101843644"></p><p>不过A510有个特别的设计，他的每个核心是不完整的。而是需要<strong>两个核心组成一个簇</strong>，共享L2缓存和浮点部分。这个很有点像当年AMD的推土机的二并一的设计，当年AMD的这个设计把AMD坑惨了，但是，放在ARM的CPU的小核设计就显得更加合理：因为这些小核，本来就是为了用来处理后台工作的。它的整数调用确实更多；反而，浮点确实用的不多。理论上是因地制宜地节省功耗，可以提高效率。</p><p><img src="https://s2.loli.net/2021/12/13/pOEMQxifh6WXnaJ.png" alt="image-20211212101912174"></p><p>不仅大中小三个核都换了新架构，8 Gen1 还把L3 Cache 从4MB提升到了6MB。但是，这个估计是为了降低成本，要知道ARM的公版可是8MB。</p><p><img src="https://s2.loli.net/2021/12/13/KkvFhGs4XJDOetL.png" alt="bFmHxTyaBPD5JYA"></p><p><img src="https://s2.loli.net/2021/12/13/eWK3b2LRDEl8I7h.png" alt="image-20211212102204426"></p><p>相比之下，联发科的天玑9000的8MB L3 Cache就显得更加有诚意了。缓存的大小对游戏的影响很大，这个在之后章节，游戏的表现部分会具体讲到。</p><p><img src="https://s2.loli.net/2021/12/13/EoB6b9g8UJhAqmO.png" alt="EoB6b9g8UJhAqmO"></p><p>制造工艺上高通也同样采用了三星的工艺，只是从5nm变成了4nm。</p><p><img src="https://s2.loli.net/2021/12/13/4lW7pLq1Zb9FaTx.png" alt="image-20211212102311348"></p><h1 id="CPU-能效评测"><a href="#CPU-能效评测" class="headerlink" title="CPU 能效评测"></a>CPU 能效评测</h1><p>多核心跑分只比上一代提升了1.5%，如下图：</p><p><img src="https://s2.loli.net/2021/12/13/pw4VHqMFSrhsG5c.png" alt="image-20211212102541221"></p><p>单核心跑分也只比上一代提升了5.7%，如下图：</p><p><img src="https://s2.loli.net/2021/12/13/Qh1Mc3JGDgn6W2t.png" alt="Qh1Mc3JGDgn6W2t"></p><p>可以看出高通的CPU还是在挤牙膏，真没想到CPU的功耗也拉胯了。CPU功耗单核4.2w，多核11.1w，<strong>这个可以赶上笔记本的功耗了</strong>。<strong>这就是说在多核心原地基本踏步的情况下，功耗还提升了2.2w。</strong>这是不是在没有华为的SoC的竞争下，高通突然安逸现状了？</p><p><img src="https://s2.loli.net/2021/12/13/gslywcGzLHaq61N.png" alt="t68XyAdURhbkWxJ"></p><p>从上图，可以看出多核的能耗比表现非常让人失望。也可以看出<strong>A510的功耗更高，性能又发挥不出来</strong>。另一方面也可能说明<strong>三星的4nm工艺能效比依然不乐观</strong>。下图为两代芯片的能耗比跑分:</p><p><img src="https://s2.loli.net/2021/12/13/k7CtrihsDvmbW3p.png" alt="k7CtrihsDvmbW3p"></p><h1 id="GPU能效评测"><a href="#GPU能效评测" class="headerlink" title="GPU能效评测"></a>GPU能效评测</h1><p>今年的8 Gen1 上的GPU，发布了四款。其中高端型号为730.</p><p><img src="https://s2.loli.net/2021/12/13/ot9rXbpxzOURCKu.png" alt="ot9rXbpxzOURCKu"></p><h2 id="性能跑分"><a href="#性能跑分" class="headerlink" title="性能跑分"></a>性能跑分</h2><p>在GFXBench的Aztec 跑分中，OpenGL跑分已经接近了剪裁版A15的GPU。的确让人意外。比上一代888的GPU跑分提高了49%。比麒麟9000提高了21%。</p><p><img src="https://s2.loli.net/2021/12/13/furS3b8odIkXQRy.png" alt="furS3b8odIkXQRy"></p><p>Vulkan跑分就更夸张，已经超过了残血的A15的126分。</p><p><img src="https://s2.loli.net/2021/12/13/Lzhv4W7DygVRGfU.png" alt="image-20211212103356115"></p><p>比起上一代的888上的GPU，Vulkan超出了<strong>57%</strong>的性能。<img src="https://s2.loli.net/2021/12/13/hc8AIBguZ9GmVlb.png" alt="hc8AIBguZ9GmVlb"></p><h2 id="功耗跑分"><a href="#功耗跑分" class="headerlink" title="功耗跑分"></a>功耗跑分</h2><p>这么牛的性能，那事实真的是这样的吗？光看性能，不看功耗那是耍流氓，8Gen1的GPU的功耗在峰值时候比它的CPU的<em>11.1</em>w还要高，居然达到了<em>11.2</em>w。相比苹果残血版的A15 的6.5w简直是惨不忍睹。骁龙8 Gen1的这个GPU功耗甚至已经接近M1了。</p><p><img src="https://s2.loli.net/2021/12/13/VM1zyakeiCJwsdH.png" alt="image-20211212103533979"></p><p><img src="https://s2.loli.net/2021/12/13/Iyfl4ugsxUYzWBr.png" alt="image-20211212103720409"></p><h2 id="峰值表现和稳定性"><a href="#峰值表现和稳定性" class="headerlink" title="峰值表现和稳定性"></a>峰值表现和稳定性</h2><p>高通的整体感觉是用<strong>功耗在换性能</strong>，那么，功耗这么高，性能这么强的GPU在耐久测试上的表现如何呢？我们来看一下《光明山脉》游戏的<strong>耐久测试</strong>。从游戏帧率可以看到，在峰值频率时，这一代高通的GPU表现超过了A15，其降频曲线看起来也比A15平滑一些。不过，这种GPU功耗，想长时间跑《光明山脉》这个游戏而不降频是不可能的。在整个十分钟跑下来，大概会降到888的峰值时的性能，略微好过A15。</p><p><img src="https://s2.loli.net/2021/12/13/OTyUvJZnwKxWjAS.png" alt="OTyUvJZnwKxWjAS"></p><p>如果我们给这个GPU施加更大的压力，跑3D Mark Wild Life Extreme 的压力测试，最终我们会得到<em>66.8%</em>的稳定度。降频还是比较严重的。所以，手机厂商想压压住8Gen 1的GPU，还需要在散热上花很多心思。</p><p><img src="https://s2.loli.net/2021/12/13/g6h4p3NZoEwV715.png" alt="g6h4p3NZoEwV715"></p><h2 id="SoC新架构层面带来的能耗比"><a href="#SoC新架构层面带来的能耗比" class="headerlink" title="SoC新架构层面带来的能耗比"></a>SoC新架构层面带来的能耗比</h2><p>虽然说这款GPU的峰值功耗爆表，但是手机一般也不只是看峰值功耗。既然换了新的CPU和GPU架构，那么架构层面带来的能耗比如何呢？这里需要具体看一下<strong>在稍低一些的图形负载情况</strong>下，能耗比的情况。</p><p>这里做一个新的测试场景：《光明山脉》的固定负载测试。分辨率降为1080P，然后锁定住30帧来运行。这里模拟了一个<em>稍低一些且统一频率</em>的GPU负载。我们来看看在<strong>同负载</strong>下的功耗表现：</p><p><img src="https://s2.loli.net/2021/12/13/kX4HmOLsqVI6KQo.png" alt="image-20211212104103464"></p><p>结果，8Gen1 的GPU在<strong>中负载</strong>的情况下，功耗一样不低。只比上一代的888改善了一点，<strong>依然无法超越Kirin9000</strong>。峰值负载测试时候如果功耗很差还可以接受，但是要知道，<strong>中负载是大部分的游戏场景，在这种中负载的情况下，功耗还是这么高，就太让人失望了。</strong></p><h2 id="实际游戏中的能耗比测试"><a href="#实际游戏中的能耗比测试" class="headerlink" title="实际游戏中的能耗比测试"></a>实际游戏中的能耗比测试</h2><p>这里我们采用常用的测试游戏：《元神》。测试的场景依然是传统的“璃月港”夜间跑图。如果论CPU压力，“璃月港”甚至比“大深渊”更高。主要是因为这里频繁的加载会对I/O提出更高的要求。稍微差一点的SoC就会出现卡顿的现象。</p><p><img src="https://s2.loli.net/2021/12/18/hbM6CLfIJG2uXsc.png" alt="image-20211217103624861"></p><p>可能是因为8 Gen1 刚出，目前元神在这一代平台上只能支持640P的最高渲染分辨率。并不是标准的720P。</p><p><img src="https://s2.loli.net/2021/12/13/A7SwEptkxLcDBon.png" alt="image-20211212104236039"></p><p>《元神》上的测试我们会分成三种：<strong>中负载，高负载，和魔鬼负载</strong>。如下图。</p><p><img src="https://s2.loli.net/2021/12/13/nC58aAp6TMEjFtW.png" alt="vrmK7hzcSwJj1Hk"></p><h3 id="高负载测试"><a href="#高负载测试" class="headerlink" title="高负载测试"></a>高负载测试</h3><p><img src="https://s2.loli.net/2021/12/13/MwgHOKuECpcSIGk.png" alt="MwgHOKuECpcSIGk"></p><p>如果只看前3分钟，可以一根线贴着60帧跑，这个在以往的高通的芯片中是从来没有实现过的，所以整体性能表现还是不错的。如果我们对比下图的CPU频率，会看到CPU调度也比较激进，所以功耗也会比较高。<img src="https://s2.loli.net/2021/12/13/QXMlBILKZWskdp3.png" alt="QXMlBILKZWskdp3"></p><p>所以前3分钟功耗比较高，如下图，会达到整机7.6w。略好于麒麟9000芯片。</p><p><img src="https://s2.loli.net/2021/12/13/PUdoh8g5pTr2ZMu.png" alt="PUdoh8g5pTr2ZMu"></p><p>很显然，这种功耗所带来的发热是撑不了太久的，3分钟之后，CPU就会陆续开始降频。实际跑下来30分钟的《元神》测试，最后的平均帧率会落在55帧左右。整机功耗会控制在6.3W左右，平均每帧消耗0.114W。 相比麒麟9000是44帧，功耗控制在5.0W， 平均每帧消耗0.114W。两个竞品每帧功耗基本一样。但是不得不说，8 Gen1在实测《元神》游戏场景中的性能表现比麒麟9000强了25%，帧数提高了不少，游戏运行起来更流畅了。但是能效比基本还是跟麒麟9000打了个平手。<img src="https://s2.loli.net/2021/12/13/VzU6oEXtwc93fFu.png" alt="image-20211212104655724"></p><p>那这个性能表现的提高是不是GPU的功劳呢？笔者认为并不是。如下图，GPU的占用率平均只有56%，它的负载非常低。这个《元神》的性能提升很有可能还是L3缓存的功劳。6M的L3 缓存，极大的缓解了CPU的瓶颈，和提高了配置GPU Job的速度。所以，虽然从数据上来看8Gen1 的跑分看起来跟麒麟9000拉不开差距，但是实际游戏中8Gen1 的表现还算不错，但是和苹果还是差了至少一代的水准。</p><p><img src="https://s2.loli.net/2021/12/13/ZMIKzxYT9shvAuX.png" alt="ZMIKzxYT9shvAuX"></p><p>但是，如果8 Gen1机身确实可以长时间的压制到7.6W的整机功耗，那么《元神》 确实可以维持满帧运行的。这一点是麒麟9000和888平台在开低分辨的时候都无法做到的。值得提醒的是，以上测试只是在640P下进行的，在720P下，负载会更高，所以整机个功耗也会更高。</p><p><img src="https://s2.loli.net/2021/12/18/7sud68XkUg54jVW.png" alt="image-20211217112550549"></p><h4 id="机身温度"><a href="#机身温度" class="headerlink" title="机身温度"></a>机身温度</h4><p>另外一个关注点就是跑《元神》30分钟后的机身温度。当然机身的温度也要取决于测试时用的具体的哪款手机。这里因为8 Gen1还没有具体的上市手机，这里暂时就不多说了。</p><p><img src="https://s2.loli.net/2021/12/13/aB9CFSIUgboj3qP.png" alt="image-20211212105115762"></p><h3 id="中负载测试"><a href="#中负载测试" class="headerlink" title="中负载测试"></a>中负载测试</h3><p>在中负载测试中，用568P的分辨率，跑《元神》30分钟，《元神》确实可以坚持在6分钟左右的时间保持60fps满帧，再之后，依然是出现慢慢降频的情况，整体来看30分钟，依然可以维持在平均57fps的水平。整体流畅度还是要优于888机型和麒麟9000的机型。可惜的是功耗依然是和888差不多。</p><p><img src="https://s2.loli.net/2021/12/13/mYj9ZQ461nwMVzy.png" alt="mYj9ZQ461nwMVzy"></p><h3 id="魔鬼负载测试"><a href="#魔鬼负载测试" class="headerlink" title="魔鬼负载测试"></a>魔鬼负载测试</h3><p>魔鬼测试会彻底压榨一下这款芯片。令人意外的是，在这种魔鬼负载的情况下，8Gen1的确跑出了所有机型里的最高水平。30分钟的平均帧率在48fps。只是在这种情况下，手机的表面温度已经超过了53度了，会很烫手，但是至少没有闪退，游戏的帧数也比较稳定。</p><p><img src="https://s2.loli.net/2021/12/13/OWQMhEFHNRusqZ7.png" alt="image-20211212105333671"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>8Gen1 的CPU 表现差强人意，GPU表现还是比较亮眼。让我们看到Android上的GPU终于赶上了Apple步伐。L3的增加提高了整个CPU的调度效率，提升了游戏体验。</p><p><img src="https://s2.loli.net/2021/12/13/SQwj1yvcKBCtdZr.png" alt="SQwj1yvcKBCtdZr"></p><p>但是能耗比依然提升不大。</p><p><img src="https://s2.loli.net/2021/12/13/2uQL3mbolUMyvPG.png" alt="2uQL3mbolUMyvPG"></p><p>最后就是基于ARMv9的CPU架构在<strong>三星4nm工艺下所带来的性能提升微乎其微</strong>。</p><p><img src="https://s2.loli.net/2021/12/13/UTqhHLykei3N6KE.png" alt="UTqhHLykei3N6KE"></p><p>只能说，8Gen1比888好太多了，但是依然是个差强人意的产品。CPU的提升一般，GPU的性能提升<strong>爆炸亮眼</strong>，但是整体功耗依然使得采用这款芯片的手机像个冬天的<strong>暖手宝</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
            <tag> 高通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARMv9以及公版CPU有什么重大改进</title>
      <link href="/2021/12/12/c8bf/"/>
      <url>/2021/12/12/c8bf/</url>
      
        <content type="html"><![CDATA[<p>ARM v9 是继v8发布后十年来的一次重要的指令集的升级，我之前写过一篇<a href="https://broadgeek.com/2021/11/21/d179/">《ARM 架构家族史》</a>，ARM 从v7架构以后，将CPU分成了三类。如下图：A系列，R系列和M系列，各自针对不同的的领域。</p><p><img src="https://s2.loli.net/2021/12/13/VEnp9yQq4BoxH6M.png" alt="VEnp9yQq4BoxH6M"></p><p><img src="https://s2.loli.net/2021/12/13/whlIP16D8dkEmpb.png" alt="whlIP16D8dkEmpb"></p><p>ARM在发布v9架构后，又发布了三款公版 CPU IP 和四款GPU IP。</p><p><img src="https://s2.loli.net/2021/12/13/ew5lOSUv6LWHtGr.jpg" alt="img"></p><p><img src="https://s2.loli.net/2021/12/13/k9q8iRuZzgpeaNT.jpg" alt="VideoCardz: &quot;ARM announces Mali-G710, G610, G510 and G310 graphics  processing units&quot; : r/hardware"></p><p>关于新的GPU IP我会单独写一篇文章来分析。今天我们重点来看一下2021年发布的<strong>v9指令集</strong>和<strong>公版CPU IP</strong>。</p><h1 id="ARMv9架构"><a href="#ARMv9架构" class="headerlink" title="ARMv9架构"></a>ARMv9架构</h1><p><img src="https://s2.loli.net/2021/12/13/SebUziEq54RnuO6.png" alt="image-20211212100508221"></p><p>如上图，ARM在v9的主要变化是2个增强，2个添加和1个兼容。</p><p>增强了：<strong>安全性</strong>和<strong>矢量处理</strong></p><p>添加了：<strong>机器学习</strong>和<strong>数字信号处理</strong></p><p>兼容了：ARMv8</p><h2 id="安全性的增强"><a href="#安全性的增强" class="headerlink" title="安全性的增强"></a>安全性的增强</h2><p>Armv9把安全性放在了<strong>第一位</strong>，在整个安全架构里有：MTE、CCA、REALMS。</p><p><img src="https://s2.loli.net/2021/12/13/cIr8QOMl2ynq6fL.png" alt="cIr8QOMl2ynq6fL"></p><h3 id="MTE"><a href="#MTE" class="headerlink" title="MTE"></a><strong>MTE</strong></h3><p>Arm MTE（内存标记）并不是v9的新功能，而是随v8.5一起引入的，MTE或内存标记扩展旨在帮助解决世界软件中两个最持久的安全问题。缓冲区溢出（Buffers overflows）和无用后使用（use-after-free）是持续的软件设计问题，在过去的50年中，这些问题一直是软件设计的一部分，并且可能需要花费数年的时间才能对其进行识别或解决。MTE旨在通过在分配时标记指针并在使用时进行检查来帮助识别此类问题。作为Armv8.5指令集的一部分引入。MTE现在内置于Arm 最近宣布的符合Armv9 的 CPU 中，例如 Cortex-X2、Cortex-A710 和Cortex-A510。基于Armv9 的 CPU 也将集成 MTE。还增加了一个Arm<strong>内存标签扩展</strong>（MTE），开发人员可以用“标签”锁定数据串，只有使用正确的密钥才能访问，该密钥由负责从内存中调用数据的代码“指针”持有，从而确保和保障数据的安全。</p><p>内存标记背后的想法非常简单：将一些位（4bit）添加到内存块中，以标识应用程序对内存的使用是安全的。Arm将内存标记实现为两阶段系统，也称为锁和钥匙： </p><ul><li>地址标记。在进程中的每个指针的顶部添加四bit校验位（59-56）。地址标记仅适用于 64 位应用程序，因为它使用ARM64 feature TBI （top-byte-ignore）。地址标签充当虚拟“key”。</li><li>内存标记。内存标签也由四位组成，在应用程序使用的物理内存中16字节对齐。这四bit不用于应用程序数据，而是单独存储。内存标签是“lock”。</li></ul><p>虚拟地址标签（key）必须与内存标签（lock）匹配。否则，会发生错误。</p><p><img src="https://s2.loli.net/2021/12/13/T6nubcPMNoVUAQR.png" alt="image-20211212144214769"></p><h3 id="CCA"><a href="#CCA" class="headerlink" title="CCA"></a>CCA</h3><p>机密计算可以打造基于硬件的安全运行环境来执行计算，保护部分敏感数据和代码，甚至不受特权软件的影响。也就是说，即使是具有最高权限的设备操作系统也无法影响。虽然操作系统可以决定何时运行，但应用程序位于独立的硬件保护内存区域，和系统中的一切是隔离的。这意味着就算社交媒体应用真的感染了恶意软件，也不会传播给设备里的其他部分。CCA的目标是从当前的软件堆栈情况中获得更大的收益，在当前的软件堆栈情况下，在设备上运行的应用程序必须固有地信任它们所运行的操作系统和虚拟机管理程序。传统的安全模型是基于以下事实建立的：更高特权的软件层被允许查看较低层的执行，然而当操作系统或系统管理程序被以任何方式损害时，这就可能成为了一个问题。</p><p><img src="https://s2.loli.net/2021/12/13/E6Ptlv3whUGnzoS.png" alt="E6Ptlv3whUGnzoS"></p><p>CCA引入了动态创建““realms”的新概念，可以将其视为对OS或虚拟机管理程序完全不透明的安全容器化执行环境。系统管理程序将仍然存在，但仅负责调度和资源分配。而“realm”将由称为“ealm manager”的新实体管理，其被认为是一段新的代码，大致大小约为hypervisor的1/10。</p><p>realm内的应用程序将能够“证明”领域管理器以确定其是否可信任，这对于传统的虚拟机管理程序而言是不可能的。</p><h3 id="REALMS"><a href="#REALMS" class="headerlink" title="REALMS"></a>REALMS</h3><p>机密领域（Realms）则是面向所有应用，运行在独立于安全或非安全环境之外的环境中，实现保护数据安全的目的，在传输中和休息时保持数据加密，并在使用时被硬件隔离，在云环境中，也意味着保护物理CPU以及运行在第三方代码旁的虚拟化处理器。</p><p><img src="https://s2.loli.net/2021/12/13/jEJXIzQPoy1SCrp.png" alt="jEJXIzQPoy1SCrp"></p><p>使用realms的优势在于，它极大地减少了设备上运行的给定应用程序的信任链，并且OS对安全性问题变得越来越透明。与当今需要企业或企业使用带有授权软件堆栈的专用设备的情况相反，需要监督控制的关键任务应用程序将能够在任何设备上运行。</p><h2 id="矢量的增强"><a href="#矢量的增强" class="headerlink" title="矢量的增强"></a>矢量的增强</h2><p><img src="https://s2.loli.net/2021/12/13/2K7ZMBiqh6suWkF.png" alt="image-20211212100557661"></p><p>ARMv9的另外一个重要的特性就是SEV2指令集的加入。SVE2是作为NEON的后继产品，我会单独写一篇文章来讲解。本篇主要介绍SVE2的增强功能。</p><p>可伸缩矢量扩展（SVE）的于2016年首次亮相，并首次在富士通的A64FX CPU内核中实现，该芯片已为日本排名第一的超级计算机Fukagu提供支持。SVE的问题在于，新的可变矢量长度SIMD指令集的第一次迭代的范围相当有限，并且更多地针对HPC工作负载，缺少了许多仍由NEON涵盖的更通用的指令。</p><p>SVE2于2019年4月发布，旨在通过用所需指令补充新的可扩展SIMD指令集来解决此问题，以服务于类似DSP等目前仍在使用NEON的工作负载。</p><p>除了增加的各种现代SIMD功能外，SVE和SVE2的优势还在于其可变的向量大小，范围覆盖了128bits到2048bits，让其无论在什么硬件运行，都允许向量的可变粒度为128b。如果纯粹从向量处理和编程的角度来看，这意味着软件开发人员将只需要编译一次其代码，并且如果将来某个CPU带有本地的512b SIMD execution pipelines，该代码将能够充分利用单元的整个宽度。同样，相同的代码将能够在具有较低硬件执行宽度能力的保守设计上运行，这对于Arm设计从物联网、移动到数据中心的CPU而言至关重要。在保留Arm体系结构的32bits编码空间的同时，它还可以完成所有这些工作。然而类似X86这样的架构则需要根据矢量尺寸增加新的指令和扩展。</p><p><img src="https://s2.loli.net/2021/12/13/B9rvjZ2JETdli74.png" alt="B9rvjZ2JETdli74"></p><p>如上图，以往我们<strong>手机</strong>上的，<strong>桌面端</strong>的，还有<strong>超算伺服器</strong>上的ARM处理器虽然都是ARM处理器，但是它们的<em>矢量寄存器<em>的宽度是完全不一样的。例如，手机芯片支持*</em>128位<strong>矢量长度，桌面端可能有</strong>256位<strong>，而超算服务器上面能达到</strong>512位<strong>甚至</strong>1024<strong>位。这就意味着，给超算设计的程序是无法轻易的在手机上运行的。有了SVE2后，情况就不同了，它打破了矢量长度的限制，开发者只要编译一次，app就可以</strong>同时在手机芯片，桌面芯片和服务器芯片上运行*<em>。所以，以后一些给超算设计的算法，在手机上也可以更容易的跑起来。这个对ARM生态的构建非常有利，它拉通了不同平台的差异性，</em>也能看出ARM想要不断你的占领PC和超算服务器市场。</em></p><p><img src="https://s2.loli.net/2021/12/13/yWX2rghiufHVzOc.png" alt="yWX2rghiufHVzOc"></p><h1 id="三款公版处理器"><a href="#三款公版处理器" class="headerlink" title="三款公版处理器"></a>三款公版处理器</h1><p>在ARMv9公布两个月后，ARM又公布三款公版CPU。</p><ol><li>一个X2: 超级性能核，X1的下一代。由美国奥斯汀团队设计。</li><li>3个A710: 注重能耗比的大核，A78的下一代。由美国奥斯汀团队设计。</li><li>4个A510：能耗小核，继A55<strong>四年后</strong>的第一次重大改进，由英国剑桥团队设计。</li></ol><p>L3 Cache 也从v8 的CPU的<strong>4MB</strong>升级到了<strong>8MB</strong>。</p><p><img src="https://s2.loli.net/2021/12/13/zhbgMyQS4Ecd5Um.jpg" alt="img"></p><p>ARM声称：使用了1个X2和3个A710和4个A510设计的SoC，相当于2020年的旗舰芯片骁龙888，Exynos2100的30%的峰值性能提升，或者同样性能下的30%的能耗降低。那么它是怎么做到的呢？我们来看一下ARM公布的PPT。</p><h3 id="超级性能核X2"><a href="#超级性能核X2" class="headerlink" title="超级性能核X2"></a>超级性能核X2</h3><p>在相同的制程下，X2可以得到<strong>16%的IPC提升</strong>，但是值得留意的是相比X1 的 4MB的L3 Cache， X2的L3 Cache变成了8MB Cache。</p><p><img src="https://s2.loli.net/2021/12/14/qOZ8lGCtmJFUQzb.png" alt="qOZ8lGCtmJFUQzb"></p><p>同时X2的前端提高了<strong>分支预测的精度</strong>，<strong>重排序缓冲区由X1的224增加到了288</strong>，流<strong>水线长度从11个指令周期缩减到了10个</strong>。</p><p><img src="https://s2.loli.net/2021/12/14/BqGJpkUCinE6DtQ.png" alt="image-20211213085810643"></p><p>并且还将<strong>二级缓存的转译后备缓冲器加大，数据预读取功能增强</strong>。所以，不难发现，X2的性能提升主要靠的是：</p><ol><li>提高缓存大小</li><li>加强访存性能</li><li>优化进程间通信延迟来实现的</li></ol><p><img src="https://s2.loli.net/2021/12/14/6rJxOXTgRNAC2M5.png" alt="image-20211213090349623"></p><h3 id="注重能耗比的大核A710"><a href="#注重能耗比的大核A710" class="headerlink" title="注重能耗比的大核A710"></a>注重能耗比的大核A710</h3><p>ARM推出注重性能X系列大核后，传统的注重性能的7系列的大核就逐渐变成了注重<strong>能耗比的中核</strong>。A710相比上一代的A78只有<strong>10%</strong>的IPC提升，这还是在三级缓存翻倍的情况下实现的。<img src="https://s2.loli.net/2021/12/14/MNmvTJiezdESWDn.png" alt="image-20211213091639237"></p><p><img src="https://s2.loli.net/2021/12/14/e87NfZ9GSnEOBHq.png" alt="image-20211213091554837"></p><p>不过在功耗控制方面，A710要远远优于上一代的A78。在同样的性能下，A710相比A78还能<strong>再降低最多30%</strong>。<img src="https://s2.loli.net/2021/12/14/rbRpXPFUMKjylWd.png" alt="image-20211213091837000"></p><p>因为A710跟X2同为美国的奥斯汀团队设计，其设计理念基本相似：改进了分支预测并且加大了Buffer，优化了延迟，流水线的长度同样降至了<strong>10</strong>个周期。</p><p><img src="https://s2.loli.net/2021/12/14/HD8gFw4cxQpJOAk.png" alt="image-20211213092130140"></p><p>同时为了进一步的降低能耗，A710的分发吞吐量从A78的<strong>6发射降到了5发射</strong>。A710的<strong>IPC性能提升不明显，只有10%的提高</strong>，很有可能就是<strong>因为发射数降低导致的。</strong>可以猜想，奥斯汀团队或许认为：<em>更佳的能耗比才是A710的定位吧</em>。所以，7系列的中核更可以被认为是<strong>更关注能效的中核了</strong>。</p><p><img src="https://s2.loli.net/2021/12/14/zUmLakJ6wOHgZov.png" alt="zUmLakJ6wOHgZov"></p><h3 id="能耗小核A510"><a href="#能耗小核A510" class="headerlink" title="能耗小核A510"></a>能耗小核A510</h3><p>对比X2，A710，本次最抢眼的设计还属由剑桥团队设计的全新小核A510。A510在结构上做了重新的设计。由<strong>两个A510</strong>组成一个<strong>核心对</strong>，共享L2 Cache和浮点运算单元。这种设计可以理解为<em>硬件超线程</em>。</p><p><img src="https://s2.loli.net/2021/12/14/VgcqZtKOMkw3aDy.png" alt="image-20211213093103127"></p><p>重点是，作为小核的A510的前端指令解码宽度，由<strong>双解码</strong>增加到<strong>3解码</strong>。</p><p><img src="https://s2.loli.net/2021/12/14/dgQqx6anB9rzesh.png" alt="image-20211213093447303"></p><p>同时，A510的缓存带宽也提升了不少。L1 Cache带宽达到了A55的<strong>四倍</strong>；L2和L3 Cache的带宽达到了A55的<strong>两倍</strong>。</p><p><img src="https://s2.loli.net/2021/12/14/K42owvJQ5qbODnh.png" alt="image-20211213093658348"></p><p>从ARM的PPT可以看出，A510相比A55有<strong>50%的浮点性能运算提升</strong>，和<strong>35%整数运算性能提升</strong>。<img src="https://s2.loli.net/2021/12/14/uOh5IzMLT6HJbAP.png" alt="uOh5IzMLT6HJbAP">不过，A510相比A55的L2和L3的缓存尺寸也同样增加了一倍，所以，运算性能的提升也极有可能<strong>得力于缓存大小的增加</strong>。</p><p><img src="https://s2.loli.net/2021/12/14/ifzgM5hEmFBaukD.png" alt="image-20211213093837364"></p><p>但是，从ARM的PPT看，有意思的是：<strong>A510只有在高频高能耗的情况下，才能跟A55拉开差距。</strong>对于一款主打能耗比的小核来说，多少这样的场景具体才能体现出能效收益还值得验证。</p><p><img src="https://s2.loli.net/2021/12/14/fUeOWsIdctN35Br.png" alt="fUeOWsIdctN35Br"></p><p>同时ARM宣称，A510可以<strong>以A73的65%的能耗达到90%的性能</strong>。剑桥团队或许是想通过提高小核A510的峰值性能，来承担更多的日常运算；同时保证在低负载下的功耗能维持在A55的水平，分担一部分A710和X2的运算压力，变相降低SoC的整体功耗，从而增加手机续航能力。</p><p><img src="https://s2.loli.net/2021/12/14/WkOIXmYU5Scqvy4.png" alt="WkOIXmYU5Scqvy4"></p><h2 id="32位和64位的支持"><a href="#32位和64位的支持" class="headerlink" title="32位和64位的支持"></a>32位和64位的支持</h2><p>本次发布的X2和X510完全放弃了对32位的支持，<strong>而中核A710仍旧兼容32位</strong>。ARM声称这是为了照顾中国大陆的安卓软件环境，现在市面上还有很大一部分软件包括：QQ、百度网盘、支付宝、网易云等仍旧是32位。</p><p>我们知道ARMv8是第一个支持64位指令集的架构，但是ARMv8同样也兼容32 bits App。这种兼容32位指令集的设计好不好呢？好的就是做到了向前兼容，不好的就是“任何32位程序运行时，大核心都将保持运行”。系统会有个调度器，当运行32位程序的时候，会自动分配大核给运行。所以本来是需要跑在小核的32位程序，现在都需要跑在A710的大核上了，这样就会造成额外的电力损耗。</p><p><img src="https://s2.loli.net/2021/12/13/8VTcLu3IBjJlnH9.png" alt="8VTcLu3IBjJlnH9"></p><p>所以为了解决这个问题，ARM公司的白皮书里宣布：“<em>2019年8月1日起，所有的Google应用商店的新程序必须支持64位架构，2022年起所有的ARMv9架构的大核心只支持64位指令集。</em>”</p><p><img src="https://s2.loli.net/2021/12/13/8kSuwDtcRlGbNqy.png" alt="8kSuwDtcRlGbNqy"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来看，2021年发布的三款公版CPU core，性能提升十分有限，X2和A710都没有对核心结构进行大刀阔斧的改动，而是通过增加Cache提升计算性能和一系列的优化来进一步降低功耗，本质上还是对之前A76的深度优化。虽然A510核采用了全新的设计，但是在低负载下功耗甚至高出A55。估计要想看到X和A7xx核的结构性的设计更新，还要看2022年法国的索菲亚团队是不是能推陈出新了！</p><p><img src="https://s2.loli.net/2021/12/14/PmIOTz7uHSYvbsZ.png" alt="image-20211213095914906"></p><p>2021年底联发科的天玑9000和高通的Snapdragon 8 Gen1 都采用了ARMv9指令架构的X2+A710+A510的CPU设计。 我会再专门开一篇专题，在分析高通Snapdragon 8 Gen1 最新的SoC的时候，来看看ARM的公版CPU在具体芯片公司SoC中的落地情况。</p>]]></content>
      
      
      <categories>
          
          <category> 芯片知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动GPU测试那些事</title>
      <link href="/2021/12/11/17d7/"/>
      <url>/2021/12/11/17d7/</url>
      
        <content type="html"><![CDATA[<p>本文主要内容转自知乎<a href="https://zhuanlan.zhihu.com/p/343565856">《手机标准化评测方法的梳理和解读V2.0》</a>。主要摘选了原文关于GPU性能评测的章节，并在原文基础上对于部分内容作了注解。如有版权不恰当引用，请及时联系我。</p><p>在阅读本文前，我先对业内有名的工具做一些介绍。</p><h1 id="GFXBench"><a href="#GFXBench" class="headerlink" title="GFXBench"></a>GFXBench</h1><p><strong>GFXBench</strong>是移动平台最常见也是最权威的GPU测试软件之一了，很多人都知道它的曼哈顿、霸王龙测试，其在移动GPU基准测试上的地位跟PC界的3DMark差不多，反而是3DMark自己在移动平台没那么受欢迎。随着移动GPU的性能不断提升，GFXBench的测试场景也在不断升级，最新的GFXBench 5.0增加了Aztec Ruins（阿兹特克废墟）测试场景，分辨率可达2K级别，并支持DX12、Vulkan等API，其要求之强悍，足以把当前手机/平板的苹果A11、骁龙845、麒麟970榨干。</p><p><img src="https://s2.loli.net/2021/12/12/GzR1YAfH7aJkPgQ.jpg" alt="img"></p><h1 id="Aztec-Ruins"><a href="#Aztec-Ruins" class="headerlink" title="Aztec Ruins"></a>Aztec Ruins</h1><p>GFXBench 5.0的Aztec Ruins（阿兹特克废墟）开发了三年多了，早在2015年官方就宣布过开发5.0测试了，2016年还在GDC大会上演示过，直到现在才正式发布。至此GFXBench的高级测试中已经有四个主要的测试场景了——曼哈顿、曼哈顿3.1、Car Chase及Aztec Ruins，技术越来越先进，要求也越来越高。</p><p><img src="https://s2.loli.net/2021/12/12/lqofHa2SciEDGVC.jpg" alt="img"></p><p>说到Aztec Ruins的具体要求，首先它支持的API更加先进，除了移动平台的Metal及OpenGL ES 3.2之外，还有桌面级的DX12、DX11及OpenGL，最重要的则是跨平台的Vulkan，官方介绍中提到Aztec Ruins的引擎支持多线程、后期特效预录制命令缓冲区、延迟渲染等技术。</p><p>Aztec Ruins有High及Normal两个级别，前者是2560x1440分辨率的，后者是1920x1080分辨率的，同时每个级别还有offscreen及onscreen之分。</p><p><img src="https://s2.loli.net/2021/12/12/Ld4xSUkZ7XwQA2C.jpg" alt="img"></p><p>虽然现在的测试样本还比较少，不过新的Aztec Ruins场景绝对可以说说移动GPU杀手，High级别offscreen测试中除了iPhone X、iPad Pro能维持10fps以上的帧数，骁龙835及以下处理器帧数都跌破个位数。</p><p><img src="https://s2.loli.net/2021/12/12/XxqhgfRbpPs8F6l.jpg" alt="img"></p><p>Normal级别的测试倒是好多了，不过30fps以上的主要还是苹果iPhone X及iPad Pro。</p><p>性能测评其实是手机测评里最好测试，数据最好量化的一个部分。因为测试性能你只需要手机本身和一台PC而已，可以说是基本没有门槛的一个项目了。手机的性能测试分为两个部分，分别为基准性能测试（跑分）和游戏帧率测试。</p><h1 id="基准性能测试"><a href="#基准性能测试" class="headerlink" title="基准性能测试"></a>基准性能测试</h1><p>首先是基准性能测试，许多人现在可能在测评中不太看重跑分了，觉得跑分不太能体现手机的真实性能表现，但是跑分依然是一台手机极限性能的标准测试方式，我们也可以通过一些特殊的方法让基准性能测试展现手机性能的性能释放，散热和降频情况。</p><p>工具上我推荐CPU项目的GeekBench5（需要Google Play），GPU项目的3D Mark，GFXBench5.0（需要Google Play）和闪存项目的Androbench5.0。不推荐大家使用安兔兔和鲁大师作为跑分工具，这两个跑分工具在过去都存在过不同程度的争议问题，其中鲁大师还出现过“660跑分比835还高”的闹剧，可信度较低。</p><p>关于这几个项目，我具体说一下GFXBench的测试，GFXBench的测试项目在这几个测试工具是最多的，分为高水平测试，低水平测试和其他项目，而高水平测试中又分为新项目（阿兹特科）和老项目（Car Chase，曼哈顿，<a href="https://www.zhihu.com/search?q=霸王龙&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A343565856}">霸王龙</a>），目前来说，我推荐大家使用高水平测试进行测试，低水平测试对于目前的手机性能来说已经非常小儿科了。</p><p>通常来说，如果你想测试一款手机的极限性能，单独测试神庙的几项就可以得到成绩了。但如果你想得到手机在高发热情况的性能释放和散热情况话，把整个高水平测试项目跑完是一种很好的测试方式，在跑完神庙测试后，手机的发热已经达到一个很可观的程度，这个时候的性能释放水平就很有参考性了，散热不好或者调度机制保守的手机这时候就会出现降频的情况。</p><p>使用软件测试完数据后，尽量不要使用截图的形式展示成绩，目前大家基本上都是使用手机看文章的，使用竖屏截图对于读者的体验非常差，使用Excel整理数据并制出表格是更好的一种方式，在对比测评中，这样也能更好的展示不同产品数据的差异。</p><p><img src="https://s2.loli.net/2021/12/12/1Fs39ZOBghbH7YS.jpg" alt="img"></p><h1 id="游戏帧率测试"><a href="#游戏帧率测试" class="headerlink" title="游戏帧率测试"></a>游戏帧率测试</h1><p>然后便是游戏帧率测试了，测试工具首推腾讯的Perfdog，快否由于长期无更新，目前绝大部分手机都不再适配了，而GameBench需要付费使用。</p><p>目前来说，腾讯这个既好用，又不需要付费。而且腾讯这个软件支持WiFi传输帧率数据到电脑上，所有的数据都会云备份到电脑端，注意在测试的时候要打开所有的数据采集。</p><p><a href="https://link.zhihu.com/?target=https%3A//perfdog.qq.com/">PerfDog | 移动全平台性能测试分析专家perfdog.qq.com/<img src="https://s2.loli.net/2021/12/12/wenmhUz3xrKp2Jk.jpg" alt="img"></a></p><p>Prefdog有许多项数据，这些数据将有助于你对手机的性能释放情况和性能策略进行分析，让你知道为何这台手机在游戏里的帧率很高/很低。</p><p>CPU Clock可以查看八颗CPU核心在游戏过程中的频率，你也可以单独选择查看一下，下图展示的就是小米11超大核在原神游戏中的运行情况。</p><h1 id="CPU温度"><a href="#CPU温度" class="headerlink" title="CPU温度"></a>CPU温度</h1><p>而CPU温度则有助于帮你了解一台手机的温度墙，温度墙，顾名思义就是手机预设的Soc温度的临界值，当传感器采集的温度数据达到这一数值时，Soc将会降低性能，将温度降低至一定程度后再恢复满血输出，如果温度墙设定的过低或者手机的性能释放策略不合理，手机在游戏过程中将会出现较为明显的掉帧，在掉帧的同时关注手机的CPU频率和GPU频率，可以有助于帮助你找到原因。</p><p><img src="https://s2.loli.net/2021/12/12/YUXLSI2Ba36GFJA.jpg" alt="img"></p><p>Battery，就是手机在游戏时的功率和消耗的电量，功率上双电芯的手机采集的值通常是手机功率的1/2（当然也有不是的），如果Prefdog采集的功率数过低，而你手上的手机又恰好是双电芯快充的，把数值乘以2就对了。</p><p><img src="https://s2.loli.net/2021/12/12/kEfBz3gDw98dqLG.jpg" alt="img"></p><h1 id="GPU功耗"><a href="#GPU功耗" class="headerlink" title="GPU功耗"></a>GPU功耗</h1><p>另外，你也可以使用PrefDog和GFXBench5.0采集手机的GPU功耗数据并计算GPU能耗比。目前绝大多数媒体和发烧友都以GFXBench 5.0为测试GPU的方式，具体方法如下：</p><p>GFXBench 5.0需要联网挂载工具运行，因此我们将所有手机的设置统一为“最低亮度”，“开启飞行模式并打开WiFi，连接同一网络”，“后台挂载工具，使用相同节点”，“使用同一版本的GFXBench5”。</p><p>使用Prefdog测试功耗，先将手机所有后台和功能关闭，亮度最低，仅开启WiFi，测试手机在此时的空载功耗，具体方法为选择手机桌面为测试软件，将手机静置不做任何操作，关闭动态壁纸和所有的动画，测量1秒后，注意在连接WiFi时部分手机在静置后会开启自动云备份或者APP更新，如果测试出的功耗过高或者测试时出现CPU占用率过高的情况，你可以先将这些功能关闭后再重新测试，如果不是这些情况就需要你自己一个一个排除了。最终我们得到了这样一段<a href="https://www.zhihu.com/search?q=功耗曲线&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A343565856}">功耗曲线</a>和平均功耗值，对数值进行记录。</p><p><img src="https://s2.loli.net/2021/12/12/jYSR6dLInBeoHDx.jpg" alt="img"></p><p>再挂载工具使用GFXBench 5.0进行单项离屏跑分，跑分时采集平均功耗数据并减去空载数据，得到手机处理器的功耗，我们推荐的单项测试项目为1080P曼哈顿3.1离屏，1440P阿兹特克离屏（OpenGL/Vulkan ）。</p><p>注意，Prefdog可以选定有效数据再导出，为了排除干扰，选择没有网络运行的数据导出并计算平均功耗</p><p><img src="https://s2.loli.net/2021/12/12/k8VnloaBIEi4HQS.jpg" alt="img"></p><p>导出的数据是一个Excel形式的表格，最底下记录了各项数值，你也可以单独使用数据制作折线表。</p><p><img src="https://s2.loli.net/2021/12/12/jC6ZJKGolgswvhP.jpg" alt="img"></p><h1 id="帧率，功耗，和能耗比"><a href="#帧率，功耗，和能耗比" class="headerlink" title="帧率，功耗，和能耗比"></a>帧率，功耗，和能耗比</h1><p>最终得到了帧率，功耗，和能耗比。</p><p><img src="https://s2.loli.net/2021/12/12/Y39TCajLgFqSQd2.jpg" alt="img"></p><p>具体的测试游戏方面，其实各位可测的选项有很多，但是要注意的是，<strong>市面上绝大部分游戏使用骁龙710这个级别的处理器即可满帧</strong>，例如王者荣耀，对于百元机以外的产品完全没有测试的必要，既然要测试，那就测试性能需求高的游戏。</p><p>目前市面上比较主流，对性能需求较高的游戏有 三款，分别是和平精英，狂野飙车9和原神。开启全高画质，和平精英满帧至少需要骁龙765G/麒麟810级别的处理器，而崩坏3安卓端和原神至今没有能够满帧运行的处理器。</p><p>在测试和平精英的时候，你可能会遇到和平精英没有适配测试机型的情况，例如我前一段测试的Mate 40 Pro，其支持的画质仅仅有HDR高清+40帧，这个时候，你就需要PUBG Tool来破解HDR高清+60帧的画质选项了，正版在酷安可下载，但是不推荐购买付费版，因为你就算买了付费版许多机型依然不能破解90帧的画质选项。</p><p><img src="https://pic1.zhimg.com/80/v2-6eec8eecb02624fef0cad6e27d8e3d50_1440w.jpg" alt="img"></p><p>还有，许多做手机测评的朋友由于没玩过崩坏3，在崩坏3的测试中会存在一些误区。例如在测试关卡和角色的选择上，崩坏3每个角色都有着不同的粒子效果，有的简单，有的就很丰富，关卡也是差不多的情况，难度高的关卡需要渲染更多的怪物，这对手机性能的需求同样是一种挑战。因此来说，我推荐各位使用活动中的角色试玩关卡进行测试，首先，角色试玩关卡不需要你买新角色，不需要打通多少关卡，门槛非常低，而且角色试玩关卡的内容基本上都是崩坏3新版本的内容，崩坏3每个版本更新都会提升对手机性能的需求，相对来说也有一些前瞻性。</p><p><img src="https://s2.loli.net/2021/12/12/Srte4kOBgjXNyTY.jpg" alt="img"></p><p>原神这个游戏也和崩坏3比较类似，具体的测试场景我推荐在蒙德城和璃月港跑图，以及在庆云顶飞行，这几个场景大多需要渲染更多的内容，而粒子效果较多的场景，我个人更加推荐打无相之雷，操作最简单，例子效果也比较多。</p><p><img src="https://s2.loli.net/2021/12/14/XbIApCo6SPFaNZq.jpg" alt="img"></p><p>最后说一下机身温度测试。目前消费电子产品评测使用的温度测试设备为红外热成像仪，便宜的价格通常在一千到两千元不等，贵的就没数了，一般测温使用的测温枪是不适合测量手机温度的，不少媒体用的是Filr的手机热成像，直接插在手机上就可以用了。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU 计算的发展历程</title>
      <link href="/2021/12/09/a42f/"/>
      <url>/2021/12/09/a42f/</url>
      
        <content type="html"><![CDATA[<p>人类似乎对计算有着天然的追求，几乎所有的自然语言 都至少有“1”和“2”的数字概念。文明史其实也是一部计算的历史，人类总是在追求更强的计算能力。公元前 3000 年古巴比伦就发明了算盘，1822 年查尔斯·巴贝奇设计出第一台机械计算机。1936 年图灵提出了通用计算机模型，1943 ～ 1945 年第一台电子计算机在宾夕法尼亚大学诞生，标志着计算机时代的来临。20 世纪 60 年代集成电路技术的发展为计算硬件注入了空前的活力。1971 年第一款通用微处理器芯片 4004 的出现标志着人类进入个人计算机时代。20 世纪八九十年代是计算机体系结构的黄金时期，随着流水线和超标量等指令间技术的不断深入，CPU 性能不断提升，而编程模型不需要任何改变就可以获得更高性能。2000 年以后，一方面指令间并行技术发展逐渐遭遇瓶颈，单核 CPU 的性能趋于饱和。另一方面，半导体工业仍然能够提供更高的集成度。针对这种形式，直观的解决方法是在单个集成电路上部署多个处理器，所以多核（几个到几十个内核）处理器甚至众核（几百个到上千个内核）处理器应运而生。与单核处理器主要利用指令间并行性不同，多核和众核处理器依赖线程级与数据级并行性来提高处理能力，换言之，需要程序员设计并行算法并且在代码中指定并行的方式。主流计算工具开始实现全面并行化，这是人类计算史上的第一次，因此具有深远的意义。</p><p> 在过去短短几年中，并行处理器无处不在，即使是手机的应用处理器，也会装备多个内核。然而，并行算法设计、程序开发和编译技术的发展却滞后很多。这一方面是由于人类思维方式组织在顺序模型中（虽然执行基础是高度并行的），直接进行并行思维非常困难；另一方面是由于现有技术储备不足，虽然并行计算已经过多年发展，但主要用在高性能计算领域，其问题、方法甚至程序员群体都与当前有着巨大的区别。正如《量化计算机体系结构》的两位作者——计算机体系结构大师和诺依曼奖获得者 John L. Hennessy 和 David Patterson 指出的那样，正如 50 年前的编程危机，易于编程的高性能并行处理器体系结构和并行编程模型是计算机科学与技术史上面临的最大挑战之一［1］。</p><p>严峻的挑战也会带来崭新的机会。50 年前的编程危机催生出高级编程语言，而现在也能看到大量新型计算机体系结构和编程模型在不断涌现。在这本书里，我们关注图形处理器</p><p>（GPU）。当前的 GPU 一般以单片集成电路的形式出现，同时也是单片处理能力最高的处理器。顾名思义，图形处理器是为图形应用这一类特殊计算而生的，那么，GPU 是怎样成为通用计算处理器的呢？本章首先扼要回顾计算机图形学的发展，从中整理出 GPU 的概念；接下来整理 GPU 的发展脉络；最后介绍 GPU 通用计算的发展历程。</p><h1 id="计算机图形学的发展"><a href="#计算机图形学的发展" class="headerlink" title="计算机图形学的发展"></a>计算机图形学的发展</h1><p>图形处理器是计算机图形学（Computer Graphics，CG）高度发展的结果。计算机图形学研究用计算机生成适合人眼观看的二维或三维图像表征。由于通过眼睛采集图像是人类感知信息最重要的方式，所以图形显示是计算机信息处理过程中人机交互的核心手段。自 1960</p><p>年“计算机图形学”术语的出现，该学科已经历经 50 年的发展。以计算机游戏和电影制作为代表的娱乐业应用、以工程 CAD 为代表的可视化应用，以及各类图形界面应用取得了长足进步，已经并且继续深刻地改变着人类生活、工作和娱乐的方式。由于人眼对图形细节有着极高的分辨能力，随着计算机技术的高速发展和人类对用户体验的不断追求，计算机图形学至今仍然是计算机科学研究的热点。</p><p>表 1-1 列出了计算机图形学发展历程中的主要里程碑。令人惊奇的是，早在 1944 年， MIT 开展的“ Whirlwind”计算机项目中就已经出现了现代计算机图形学的关键概念。该计算机用于冷战时期的防空作战指挥，对快速、有效的图形交互具有强大需求，开始使用阴极射线显示器、光笔等现代图形交互手段。在此基础上，MIT 又设计了 TX-0 和 TX-2 计算机， 当时还是博士研究生的计算机图形学大师 Ivan Sutherland 为 TX-2 设计了 Sketchpad 图形交互工具。如图 1-1 所示，Sketchpad 允许使用光笔在显示器上绘制和操作图形。Sketchpad 包含现代计算机图形学的几乎所有核心概念。因此，Ivan Sutherland 被认为是计算机图形学的祖父级人物。</p><center>表 1-1 计算机图形学发展史的重要里程碑［2］</center><table><thead><tr><th align="center">时间</th><th align="left">计算机图形学发展的重要成就</th></tr></thead><tbody><tr><td align="center">1944 年</td><td align="left">MIT 开展的“Whirlwind”项目首次系统化研究实时计算机图形显示</td></tr><tr><td align="center">1960 年</td><td align="left">“计算机图形学”术语出现</td></tr><tr><td align="center">1962 年</td><td align="left">第一个多玩家计算机游戏 Spacewar</td></tr><tr><td align="center">1963 年</td><td align="left">Ivan Sutherland 发明 Sketchpad</td></tr><tr><td align="center">1965 年</td><td align="left">首次计算机艺术展在斯图加特和纽约举办</td></tr><tr><td align="center">1967 年</td><td align="left">● Coons Patch 复杂曲面建模算法提出<br>● NASA 设计了第一个全彩色实时飞行模拟器</td></tr><tr><td align="center">1968 年</td><td align="left">第一家计算机图形技术公司 Evans &amp; Sutherland 成立</td></tr><tr><td align="center">1968 年</td><td align="left">首届计算机图形学会议（SIGGRAPH）召开</td></tr><tr><td align="center">1970 年</td><td align="left">随机访问存储器和光栅化显示器诞生</td></tr><tr><td align="center">1973 年</td><td align="left">多维可视化，Phong 渲染算法提出</td></tr><tr><td align="center">1974 年</td><td align="left">Z-Buffer 算法，纹理映射算法提出</td></tr><tr><td align="center">1980 年</td><td align="left">● 首届欧洲图形学（Eurographics）会议召开 <br>● 光线追踪算法提出<br>● 迪斯尼制作第一部大量使用计算机合成图像（超过 20 分钟）的电影《TRON 》</td></tr><tr><td align="center">1982 年</td><td align="left">● Silicon Graphics 公司设计硬件图形引擎（Geometry Engine）<br>● 工业光魔（Industrial Light and Magic）公司制作第一部计算机动画电影《Startrek 》<br>● 3D 计算机辅助设计软件公司 Autodesk 成立</td></tr><tr><td align="center">1984 年</td><td align="left">● 第一家专攻计算机动画电影的公司 Pixar 成立<br> ● Apple 公司发布第一台拥有图形界面的个人计算机</td></tr><tr><td align="center">1985 年</td><td align="left">● 2D 图形标准 GKS（graphical kernel system）发布 <br>● ATI 公司（后来被 AMD 公司收购）成立</td></tr><tr><td align="center">1987 年</td><td align="left">● 美国自然科学基金开始专门资助图形学研究<br> ● Marching Cubes 可视化算法提出</td></tr><tr><td align="center">1988 年</td><td align="left">● 2D 图形标准 PHIGS 发布 <br>● 3D 图形标准 ISO GKS-3D 发布</td></tr><tr><td align="center">1989 年</td><td align="left">● 第一部真实 3D 角色电影《Abyss》<br>● 3D 渲染软件 Renderman 公开发布</td></tr><tr><td align="center">1991 年</td><td align="left">数据可视化工具 OpenDX 推出</td></tr><tr><td align="center">1992 年</td><td align="left">Silicon Graphics 公司推出 OpenGL 标准、图形流水线标准化</td></tr><tr><td align="center">1993 年</td><td align="left">NVIDIA 公司成立</td></tr><tr><td align="center">1994 年</td><td align="left">Sony 公司的 Playstation 游戏机和任天堂的 N64 游戏机问世</td></tr><tr><td align="center">1995 年</td><td align="left">● Microsoft 公司定义 Direct3D 图形接口 <br>● 3D 第一人称设计游戏 Quake 发布</td></tr><tr><td align="center">1996 年</td><td align="left">3DFX Voodoo 图形加速器获得巨大成功</td></tr><tr><td align="center">1997 年</td><td align="left">Titanic 获得奥斯卡特效奖，其中大量使用了人群仿真和流体力学仿真</td></tr><tr><td align="center">2000 年</td><td align="left">Sony 公司的 Playstation 2 问世</td></tr><tr><td align="center">2001 年</td><td align="left">Imagination 公司设计 PowerVR MBX GPU 内核，并在移动 GPU 市场取得成功</td></tr><tr><td align="center">2002 年</td><td align="left">● Microsoft Xbox 游戏机出现 <br>● 奥斯卡首次颁发最佳动画形象奖并由 Shrek 获得</td></tr><tr><td align="center">2009 年</td><td align="left">第一部大量使用面部表情捕捉动画技术的电影《Avatar》</td></tr></tbody></table><p>1960 ～ 1980 年是计算机图形学的“少年期”，图形渲染的基本理论在这 20 年得到充分发展，如曲面建模、着色渲染、Z-buffer 可见度判断、光线追踪和纹理映射等方法都是在这段时期形成的。同时，计算机图形学的主要应用也涌现出来：最早的带有图形特征的计算机游戏 Spacewar 在 1962 年出现 ，1967 年 NASA 设计了第一个全彩色实时飞行模拟器，1980 年迪斯尼制作的电影《TRON》包含了超过 20 分钟的计算机合成动画。同期的硬件重大发明是随机访问存储器（Random Access Memory，RAM）和光栅化显示器，这些硬件技术的进步使得大众消费级别的高性能图形显示成为可能。在这段时间内，计算机图形学学术圈也逐渐形成：1968 年首届计算机图形学会议（SIGGRAPH)召开，至今其仍是该领域最为重要的学术会议和相关技术展示平台，与 1980 年出现的欧洲图形学会议以及此后出现的 SIGGRAPH Asia 并称为计算机图形学的三大会议。</p><p><img src="https://s2.loli.net/2021/12/10/64D5WqrUaBP3FTe.png" alt="image-20211209131958113"></p><center>图 1-1 Ivan Sutherland 与 Sketchpad 图形交互工具</center><p> 20 世纪八九十年代是计算机图形学的“青年时代”。首先，计算机图形工业逐渐形成。著名的图形特效制作公司工业光魔、动画电影制片厂 Pixar 成立，图形 CAD 软件公司AutoCAD、图形硬件制造商如 SGI、显卡制造商纷纷出现。Pixar 设计了著名的专业渲染软件 Renderman，几乎成为电影级渲染的标准；美国电影工业开始大量使用计算机图形学技术， 其标志性电影《Titanic》大量使用人群仿真和流体力学仿真方法制作电影特效，并且于 1997 年获得奥斯卡特效奖。继 1984 年 Apple 公司的个人计算机出现后，具有图形化人机界面的个人计算机也得到了普及，Sony 公司和任天堂也分别推出了著名的游戏机平台 Playstation 和N64。图形应用对硬件性能要求极高，早期的图形处理硬件在这样的大背景下应运而生，SGI 首先设计了著名的 Geometry Engine。此后一系列专注于图形硬件的公司如 ATI、S3、3DFX、NVIDIA 就像雨后春笋般出现了，纷纷推出专用图形处理芯片。由于此时图形硬件尚不具备编程能力，因此一般被称为图形加速器，以显卡的形式体现功能。1991 年 S3 公司首先设计出第一块 2D 图形加速芯片，1995 年 NVIDIA 公司设计首个 3D 图形加速芯片 NV1，1996 年3DFX Voodoo 图形加速器在市场上取得巨大成功。从这时开始，高端图形显示硬件形成了以显卡作为功能载体的基本模式，而显卡功能以图形加速芯片为核心，辅之以图形存储器。此外，IBM 公司设计了专用数据可视化工具 OpenDX，标志着一个新的图形学应用出现。随着工业化程度的深入，工业界和学术界提出了图形处理的标准化需求。早期的标准包括 2D 图形标准 GKS、PHIGS 和 3D 图形标准 ISO GKS-3D，而随后 SGI 公司提出的 OpenGL 则成为事实上的工业标准，Microsoft 公司也推出了 Direct3D，形成了图形标准的另一大阵营。OpenGL 和 Direct3D 的出现标志着计算机图形操作的标准化，使得图形应用跨平台兼容成为可能，极大加速了图形软硬件技术的发展，成为今天所有图形软件和硬件的基础。</p><p><img src="https://s2.loli.net/2021/12/10/pnCAWo83O7aI1sv.jpg" alt="How Historically Accurate Was James Cameron&#39;s &#39;Titanic&#39;?"></p><center>图1-2 《Titanic》电影中的海水特效</center><p>2000 年后，计算机图形学进入加速发展阶段。在硬件方面，自 2001 年 NVIDIA 公司推出第一个可编程渲染图形处理器 GeForce 3 以来，图形处理器的概念正式出现。此后，计算机图形硬件市场形成了 NVIDIA 公司、ATI 公司（后来被 AMD 公司收购）和 Intel 公司三雄并立的局面。其中 Intel 公司专注于集成显卡，在中低端市场具有显著优势，而 NVIDIA 公司和 ATI 公司则在高端独立显卡市场展开白热化竞争，双方的竞争一度使得 GPU 芯片集成度的上升速度超过了摩尔定律。与此同时，移动平台同样需要 GPU。类似于早期计算机的 GPU 市场，移动 GPU 的竞争更加激烈，目前主要的移动 GPU 供应商包括 Imagination、QualComm、NVIDIA、ARM 等多家公司，其中 Imagination 和 QualComm 的市场份额较大， 但并不具备绝对优势。另一方面，随着硬件技术的进步，使得全局光照和物理仿真等技术能够应用在各种图形中。好莱坞大片越来越依靠计算机制作的特效，动画人物的衣物、头发、皮肤、表情等普遍通过物理仿真技术生成，而光线追踪等物理真实渲染技术也被大量使用。2002 年开始，奥斯卡新设的一个奖项——最佳动画形象奖由 Shrek 获得。2009 年上映的</p><p>《 Avatar》是面部表情捕捉、光线追踪、物理仿真等技术的集大成体现。图 1-3 是《 Avatar》中使用光线追踪技术制作的一个镜头，其中远处的植被和动物具有极其真实的光照效果。</p><p><img src="https://s2.loli.net/2021/12/10/YblgjoOGtMrCS1N.png" alt="YblgjoOGtMrCS1N"></p><center>图 1-3 《Avatar》中用光线追踪技术制作的镜头</center><h1 id="图形流水线"><a href="#图形流水线" class="headerlink" title="图形流水线"></a>图形流水线</h1><p>OpenGL 和 Direct3D 都定义了图形流水线（graphics pipeline)概念，包括一系列计算机图形显示过程中必须执行或可选的图形操作。目前，所有 GPU 的操作都是围绕图形流水线设计的。因此，接下来将分析图形流水线的主要操作，从中了解图形应用对 GPU 硬件体系结构提出了怎样的要求。当前的图形流水线非常复杂，下面以图 1-4 中只包含基本操作的简化图形流水线来说明。</p><p><img src="https://s2.loli.net/2021/12/10/cQ4iyjChkqpSmsI.png" alt="cQ4iyjChkqpSmsI"></p><p>一般来说，应用程序中需要现实的场景由 CPU 产生，包含图形对象的形状、材质及光源信息等。图形对象的形状可以任意复杂，计算机图形学发展了以基本多边形网格</p><p>（mesh）近似复杂形状的方法，从而能够以有限的空间复杂度逼近真实形状。将图形对象切割为三角形或其他多边形网格的工作一般由 CPU 负责。该网络中的基本图形元素称为图元</p><p>（primitive），本书只考虑最为常见的三角形网格。CPU 将需要显示的三角形网格以元素数组的形式传送给 GPU，该数组的每个元素为一个三角形，由三个顶点表示。各个顶点的三维坐标和图形操作指令同时也传递给 GPU。在通用计算机平台（服务器、台式机或笔记本电脑） 上，CPU 和 GPU 普遍使用 PCI Express 总线传递信息；在移动平台（手机或平板电脑）上， 以上信息由相应的数据总线（如 ARM 公司的 AMBA 总线）传递。</p><p>图形数据传递到 GPU 后首先进行顶点处理（vertex processing）。顾名思义，这一级操作针对顶点进行，包括坐标变换（transformation）和光照（lightning）两个范畴的操作，因此经常被简称为 T&amp;L。前者包括一系列空间坐标变换以及从三维空间到二维显示屏幕的投影映射，后者根据场景设置决定每个顶点接受的光照。在早期图形硬件中，这个步骤的操作是固定的，按照坐标转换、顶点光照和投影变换的固定属性进行。现在几乎所有的 GPU 都支持可编程顶点处理，相应的程序称为顶点渲染程序（vertex shader）。注意各个顶点的操作没有依赖关系，可以并行进行。</p><p>接下来的步骤是图元组装（primitive assembly），将各个顶点重新组合为基本图元，并且根据屏幕视野将不可见的图元裁剪掉。由于一般都使用三角形作为基本图元，所以这一步骤也经常被称为三角形设置（triangle setup）。几何渲染（geometry shading）是图元组装之后的一个可选步骤，以图元作为单位处理。</p><p>接下来 GPU 对这些图元进行光栅化操作，即空间采样，将图元分解为像素大小的元素， 称为片元（fragment）。片元处理（fragment processing）是图形流水线中操作最复杂、计算量最大的一个步骤，因此该步骤是 GPU 中最早实现可编程化的部分。必须注意的是，每一个图元都会产生自己的一组片元。来自不同图元的片元可能在二维显示屏上重叠，但是在这一阶段所有可见或不可见的片元都被平等对待。这当然是简化处理方式，引入了冗余后，该问题只有在使用光线追踪算法时才能得到完美解决。片元处理根据顶点光照结果进行内插，以决定当前位置的光照；同时一般还要进行纹理映射（texture mapping）操作，将事先存储的纹理像素复制到片元。该步骤为每一个片元产生渲染结果和深度值。不同片元的处理可以完全并行化，GPU 普遍配置多个片元处理单元进行并行处理。较早的 GPU 硬件中，片元的渲染结果完全通过对顶点结果进行内插获得，所以片元处理与光栅化经常合成一个步骤，称为光栅化和内插。</p><p>图形流水线的最后一个阶段是像素处理，现代 GPU 通常配置大量渲染输出单元（render output unit）并行完成这一步骤。渲染输出单元一般被称为 ROP（raster operation pipeline）。该步骤的主要任务是决定最终的显示结果。由于多个片元可能对应同一像素，因此需要由Z-buffer 等可见性算法决定最终渲染结果，并送到帧缓冲（frame buffer）输出。帧缓冲用于显示存储器中直接对应显示输出的地址空间正好存储一帧的显示结果。</p><p>图 1-4 是简化的图形流水线，而 OpenGL 4.0［3］定义的图形流水线要远为复杂，如图 1-5 所示。其中，较深颜色方框表示缓冲或存储器，较浅颜色方框表示可编程模块，其他方框表示固定功能模块。有兴趣的读者可以查阅相关标准和教科书了解现代图形流水线的细节。<img src="https://s2.loli.net/2021/12/10/IvLBx9PDhOGFXk7.png" alt="IvLBx9PDhOGFXk7"></p><h1 id="GPU的发展过程"><a href="#GPU的发展过程" class="headerlink" title="GPU的发展过程"></a>GPU的发展过程</h1><p>虽然专用图形硬件从 1944 年 MIT 的 Whirlwind 项目就开始出现，并于 20 世纪 80 年代逐渐成形，但图形处理器或 GPU 这个名词直到 1999 年才由 NVIDIA 公司创造，此后逐渐发展成为同时具备高速图形处理能力和通用计算能力的强大硬件。表 1-2 列出了 GPU 发展史上的重要里程碑。</p><p>表 1-2  GPU 发展史的重要里程碑</p><table><thead><tr><th>时间</th><th>GPU 发展史中的重要成就</th></tr></thead><tbody><tr><td>1944 年</td><td>MIT 开展的“Whirlwind”项目首次设计实时图形显示硬件</td></tr><tr><td>1982 年</td><td>以 Geometry Engine 为代表的专用图形处理硬件芯片出现</td></tr><tr><td>1985 年</td><td>图形加速硬件出现在大规模市场产品（如 Commodore 公司的 Amiga 计算机）中</td></tr><tr><td>1991 年</td><td>S3 公司设计首个 2D 图形加速芯片 S3 86C911</td></tr><tr><td>1995 年</td><td>NVIDIA 公司设计首个 3D 图形加速芯片 NV1</td></tr><tr><td>1999 年</td><td>NVIDIA 公司提出 GPU 概念，其 GeForce 256 GPU 首次实现基于硬件的变换与光照（transform  and lighting）</td></tr><tr><td>2001 年</td><td>NVIDIA 公司推出第一个可编程渲染图形处理器（GeForce 3）</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>2005 年</td><td>ATI 公司推出首个统一渲染图形处理器，用于 Xbox 360</td></tr><tr><td>2006 年</td><td>NVIDIA 公司推出首个针对计算机统一渲染图形的处理器</td></tr><tr><td>2011  年</td><td>AMD 公司推出 CPU  ／ GPU  融合处理器（APU）</td></tr></tbody></table><p>1980 年以前的图形硬件都只具备固定的图形功能，其中多数只支持帧缓冲的功能，因此属于图形加速器范畴，还不能称为 GPU。1980 年后出现了以 IBM Professional Graphics Controller［4］为代表的专用图形卡，用 Intel 8088 芯片实现图形功能，是现代显卡的雏形。1982 年出现的 Geometry Engine［5］和 1985 年出现的 Pixel-Planes［6］是最早的专用图形处理器，开始具备有限编程处理能力。Geometry Engine 拥有图形处理指令集，支持流水线式指令处理。如图 1-6a 所示，其硬件组织为 12 级流水线，其中前 4 个用于顶点坐标变换，中间 6 个用于图形剪裁（即判断图形是否位于用户可见屏幕)，最后两个用于投影变换或者按比例伸缩。Geometry Engine 还不是完整的处理器，不具备取指令功能，因此只能作为协处理器工作， 由主处理器向其发送控制指令和数据。图 1-6b 是 Geometry Engine 的芯片管芯照片。该芯片在 1982 年就能够支持 256 彩色、1024×1024 显示分辨率，的确是了不起的成就。虽然单个芯片只能支持流水线式并行，后来的 Reality Engine［7］将 8 个 Geometry Engine 配置在一张显卡上，能够支持数据级并行。Geometry Engine 是顶点处理可编程硬件的先驱，后续像素级处理需要由其他硬件实现。其功能与 Pixel-Planes 芯片［6］正好互补，后者实际上是在帧缓冲存储器上叠加逻辑功能的芯片，能够方便地对多个像素进行各种编程操作.</p><p><img src="https://s2.loli.net/2021/12/10/bwZW9UEs6I2QOMA.jpg" alt="engine path"></p><p><img src="https://s2.loli.net/2021/12/10/IMeqTtaB29KSUbR.jpg" alt="engine chip"></p><p><img src="https://s2.loli.net/2021/12/10/R3ar1vZxMhwbu2e.png" alt="R3ar1vZxMhwbu2e"></p><p>在当时的背景下，Geometry Engine 和 Pixel-Planes 属于高端图形硬件范畴，价格昂贵， 尚不能被大众消费市场接受。但是这些技术为此后 GPU 的发展提供了技术储备，从 1985 年开始，ATI、S3、3DFX、ViewLogic、Matrox、NVIDIA、Imagination、Rendition 等专业图形加速硬件公司如雨后春笋般出现，普遍把目标定位于消费级市场。早期产品大多定位于 2D 显示加速卡，直到 1996 年 3DFX 公司推出 Voodoo 图形芯片组，标志着 3D 图形加速卡市场正式出现。事实上，该芯片组不是单一的处理器，而是由帧缓冲处理芯片、纹理映射芯片和显示数模转换芯片组成的系列。因此，我们将 Voodoo 图形芯片组称为第 0 代 GPU。图 1-7 是使用 Voodoo 图形芯片组的 Diamond Monster 3D 显卡。Voodoo 图形芯片组实现了图形流水线中从光栅化到帧缓冲的功能，顶点处理仍由 CPU 完成并经由 PCI 总线传输给 GPU，如图 1-8 所示。Voodoo 图形芯片组取得了巨大成功，一度占据 80% 以上的相关市场，此后GPU 的发展就是在此技术上沿着图形流水线继续增加功能。但是，3DFX 公司之后的发展并不顺利，2001 年不得不停止运营。不过，3DFX 公司的技术专利被 NVIDIA 公司收购，而核心技术人员之后也加入了 NVIDIA 公司，因此 Voodoo 的血脉通过 NVIDIA GPU 一直保存至今。</p><p>20 世纪 90 年代末，GPU 市场逐渐形成 NVIDIA 公司和 ATI 公司双雄争霸的情形。</p><p>1999 年，NVIDIA 公司设计了 GeForce 256 图形处理器，正式定义了 GPU 这个名词。因此， GeForce 256 图形处理器是当之无愧的第一代 GPU，图 1-9 是采用该 GPU 的显卡。差不多同一时期，ATI 公司也推出了 Radeon 7500 GPU。如图 1-10 所示，GeForce 256 GPU 首次将完整的图形流水线集成到单一芯片上，从 CPU 接收绘图命令和场景数据，并且用性能更好的AGP（advanced graphics port）总线代替了 PCI。也就是说，GeForce 256 集成了顶点处理（即T&amp;L）、图元组装（包括剪裁）、光栅化和像素级处理，支持每秒 1500 万多边形和 48 000 万像素的处理速度，在显示帧速率上 GPU 产品提升了 50%。GeForce 256 的出现第一次使得 GPU 能够用于消费级市场，改变了 GPU 一般用于高端计算机辅助设计应用的局面。应该注意的是，第一代 GPU 仍然只能支持固定功能的图形流水线。有趣的是，GeForce 256 还集成了一个运动补偿单元，以支持视频处理，这也是在 GPU 上集成专用加速硬件的开端。</p><p><img src="https://s2.loli.net/2021/12/10/N6n3EH4yj8Af7tI.jpg" alt="VGA Legacy MKIII - Diamond Monster 3D (3Dfx Voodoo 1)"></p><center>图 1-7 使用 Voodoo 图形芯片组的 Diamond Monster 3D 显卡</center><p><img src="https://s2.loli.net/2021/12/10/UliYOTt1pVh4kgN.png" alt="UliYOTt1pVh4kgN"></p><p><img src="https://s2.loli.net/2021/12/10/aNImTe7GFXMpYzj.jpg" alt="GeForce 256 - Wikipedia"></p><center>图 1-9 使用 GeForce 256 显卡</center><p><img src="https://s2.loli.net/2021/12/10/wPTlchALpFX8t6r.png" alt="wPTlchALpFX8t6r"></p><p>2001 年，真正具有编程能力的第二代 GPU 出现了，代表产品为 NVIDIA 公司的GeForce 3 GPU（内部代号 NV20，如图 1-11 所示）和 ATI 公司的 Radeon 7500 和 8500 GPU。如图 1-12 所示，第二代 GPU 的编程能力体现在顶点处理阶段，GPU 可以接受顶点渲染程序（vertex shader）和片元级渲染程序（fragment shader) 。同时，片元级渲染程序还可以使用专用的纹理存储器。GeForce 3 不仅增加了编程能力，其处理能力也大幅度提高了，支持每秒5000 万多边形和 96 000 万像素的处理速度。可编程渲染程序已经可以支持复杂的动画效果，如脸部的皱纹和水波的涟漪都可以呈现复杂的光照效果。Doom 3 是最早成功利用可编程渲染的游戏，经过全新设计的顶点和片元渲染代码，其图形效果相对早期版本实现了飞跃。</p><p><img src="https://s2.loli.net/2021/12/10/UnhOvGwAs4MgiKX.jpg" alt="NVIDIA GeForce3 Specs | TechPowerUp GPU Database"></p><center>图 1-11 GeForce 3 GPU</center><p><img src="https://s2.loli.net/2021/12/10/gmsw4APOXaSEihI.png" alt="gmsw4APOXaSEihI"></p><p>2004 年出现的 NVIDIA GeForce 6 系列 GPU 是对第二代 GPU 的丰富和拓展，因此笔者将其归类为第 2.5 代 GPU。图 1-13 显示的是 GeForce 6800 GPU 的体系结构，图 1-14 是其实现的图形流水线功能，该 GPU 拥有 6 个顶点处理器、16 个片元处理器和 16 个 ROP。其中， 顶点处理器和片元处理器具有完整的可编程功能，能够支持条件和循环编程结构。相比第二代 GPU，GeForce 6800 的顶点处理器也拥有纹理存储器。第 2.5 代 GPU 的峰值计算能力全面超过了同期的 CPU，因此基于 GPU 的通用计算概念也是在这个时期产生的［9］。此时， GPU 拥有顶点处理器和片元处理器两种计算资源，采用不同的硬件体系结构，其中前者为矢量浮点单元，功能相对简单，而后者具有较强的编程能力。因此，这个阶段的通用计算一般使用编程性更好的片元处理器。</p><p>早期的 GPU、显卡的型号和命名比较混乱，随着市场的逐渐成形，目前已逐渐形成规律。一般来说，制造商会在研发阶段为每一代 GPU 芯片分配特殊的代号和名字，形成产品后按照性能分级形成新的型号， 相应地显卡还会有自己的代号。例如，NVIDIA 公司的 NV40 GPU 是其研发代号，产品化后根据性能有GeForce 6500、GeForce 6700、GeForce 6800 等多个型号、其中 GeForce 6800 是功能较强的成熟产品，相应显卡有 GeForce 和 Quadro 两个序列，前者针对消费市场，后者针对高端图形应用市场。<img src="https://s2.loli.net/2021/12/10/auJf3hxGq1EyWcz.png" alt="image-20211209140032601"></p><p><img src="https://s2.loli.net/2021/12/10/lcz3teFp5JiobT8.png" alt="lcz3teFp5JiobT8"></p><p>到2005 年，主要的GPU 制造商都使用顶点处理器和片元处理器两种计算资源。然而， 合理配置这两种资源的问题却始终没有得到完美解决。特别是两种处理器数量的最佳比例是 随应用的变化而变化的，因此经常出现一种处理器不够用而另一种处理器闲置的情况。因 此，从2005 年开始，GPU 体系结构方面的最大变化在于引入了统一渲染内核（unified shader processor）概念，即GPU 装备一组完全相同的、具有较强编程能力的内核，根据任务情况在顶点和片元处理任务之间动态分配。最早拥有统一内核的GPU 是ATI 公司为Microsoft Xbox 游戏机设计的Xenos，其体系结构如图1-15 所示。与以往GPU 明显不同的是，Xenos 拥有64 个完全相同的流处理单元（streaming processing units）。每个单元配备5 个计算单元和1 个分支处理部件，以超长指令字（Very Long Instruction Word，VLIW）方式调度执行程序。2006 年，NVIDIA 公司推出G80 处理器，装备GeForce 8000 系列显卡，标志着GPU 全面采用统一渲染内核。从 G80 开始，NVIDIA GPU 体系结构已经全面支持通用编程，同时NVIDIA 公司也推出了著名的 CUDA 编程技术，为 GPU 通用程序设计提供了第一套完整工具。图 1-16 是 NVIDIA G80 GPU 的体系结构，其组织形式比 Xenos 的多一个层次。NVIDIA G80 GPU 拥有 8 个流多处理器（streaming multiprocessor），各自独立执行。每个流多处理器拥有 8 个流处理器（也被称为 CUDA 内核)，以 SIMD 方式并行执行。NVIDIA G80 GPU采用硬件多线程技术，多组线程共享一个流多处理器的硬件，分时执行，以隐藏存储器延时。      </p><p>​          <img src="https://s2.loli.net/2021/12/10/Shl9iNrbw1R8dL4.png" alt="Shl9iNrbw1R8dL4"></p><p>从此，GPU 设计厂商必须在设计 GPU 时兼顾图形和通用计算的需求。NVIDIA 公司在 G80 之后又推出 G90、Fermi、Kepler 和 Maxwell 等多代 GPU，其通用计算能力越来越强大。ATI/AMD 公司后续推出的 GPU 开始采用新一代图形内核（graphics core next），并且借助 OpenCL 标准的推出，全面支持 GPU 通用计算。特别是在 2011 年，AMD 公司首先将多个 CPU 内核和 GPU 内核集成在同一芯片上，称为加速处理器（Acceleration Processing Unit， APU），从而形成了一类新的处理器。图 1-17 是 AMD Llano APU 的示意图，其中 SIMD 引擎阵列（SIMD ENGINE ARRAY)就是 GPU 内核。之后，AMD 公司还联合各大厂商定义了异构系统体系结构（Heterogeneous System Architecture，HSA），包括平台定义［11］、程序参考手册［12］和动态运行环境定义［13］，实现了 CPU 和 GPU 访存地址空间的统一化，为集成 CPU ／ GPU 处理器生态系统（包括硬件、编程技术以及上下游产品开发)奠定了基础。</p><p><img src="https://s2.loli.net/2021/12/10/qCpOYgXMi6Uhmrx.jpg" alt="10 years ago, Nvidia launched the G80-powered GeForce 8800 and changed PC  gaming, computing forever - ExtremeTech"></p><center>图 1-18 NVIDIA G80 体系结构 </center><p><img src="https://s2.loli.net/2021/12/10/CZrlF9k6jVR8a45.png" alt="CZrlF9k6jVR8a45"></p><h1 id="GPU通用计算的发展历程"><a href="#GPU通用计算的发展历程" class="headerlink" title="GPU通用计算的发展历程"></a>GPU通用计算的发展历程</h1><p>21 世纪的最初 5 年是 GPU 硬件发展的分水岭。一方面，CPU 经历了平均每年性能提升50% 以上的 20 年高速发展，逐渐进入性能饱和阶段，如图 1-18 所示。另一方面，GPU 由于可以充分利用图形显示过程的内在并行性，同时凭借图形应用的旺盛需求，性能却可以继续增加，终于在 2003 年全面超越 CPU。预计 GPU 将保持现有性能增长趋势直到 2020 年，届时单片 GPU 的性能将达到单片 CPU 的 100 倍左右。既然 GPU 表现出了这样出色的性能， 自 2004 年就有很多研究人员开始利用 GPU 进行耗时的科学计算。不过，当时人们还只能使用 OpenGL 或其他渲染语言编写通用计算程序，程序员需要将通用计算使用的数据结构翻译成图形结构（例如各种图元），因此开发调试困难较大。2006 年 CUDA 编程语言和工具的推出，虽然极大简化了 GPU 通用编程，但是只能使用 NVIDIA 公司的图形处理器。OpenCL 推出以后，真正的 GPU 通用编程时代来临了。</p><p><img src="https://s2.loli.net/2021/12/10/FI7zESRO9qMutv6.png" alt="FI7zESRO9qMutv6"></p><p>此后，GPU 通用计算被广泛应用于各种应用中，图 1-19 是对现有应用的不完全分类。其中，GPU 已经被用于油气勘探、军事、生命科学、金融、制造业等多种工业和科研领域，并为其中很多应用带来了革命性的突破。例如，此前分子动力学仿真需要 8 个月的时间才能计算百万数量级的原子在纳秒时间量级内的相互作用，随着 GPU 的引入，现在已经可以处理十亿数量级的原子。另一个例子是暴力密码破解，NVIDIA Fermi 级别的GPU 可以在 15 分钟左右破解 7 个字母的 MD5 密码，而 CPU 需要 4 天才能破解。随着大数据应用的蓬勃发展，GPU 通用计算的前景异常广阔。有兴趣的读者可以阅读参考文献［9］、［15］、［16］，了解 GPU 通用计算的早期应用，参考文献［17］是对较新研究成果的综述。同时，由于 GPU 在单位功耗下提供的计算性能远高于 CPU，很多超级计算机也采用GPU 作为基本计算资源，如世界超级计算机前 10 名中有 5 个使用 NVIDIA Kepler GPU 和Intel Xeon Phi 众核处理器 ，绿色 500 超级计算机的前 10 名中有 9 个使用 GPU。</p><p><img src="https://s2.loli.net/2021/12/10/lM1v5np7sgWuHdT.png" alt="image-20211209140744085"></p><p>从峰值计算能力而言，GPU 相对 CPU 的优势是明显的，图形程序一般能够比较充分地发挥 GPU 的计算潜力。然而，并不是所有的通用程序都能完全利用计算平台的处理能力，除了部分稠密矩阵运算能够达到峰值运算能力的 80% 以外［19］，大部分程序的利用率受限于其内部控制结构和内存访问模式等因素。那么，在通用计算应用中，GPU 的表现如何呢？参考文献 [20] 对现有应用进行了归纳总结，图 1-20 是相应的结果。首先，GPU 擅长执行计算密度比较高的程序，即每一字节需要浮点或整数运算较多的代码。图 1-20 的横轴是FLOP/Byte，即每字节数据的浮点运算。所以，横轴越靠右位置的程序计算密度越高，属于计算受限型应用，即影响性能的主要因素是计算资源不足；横轴越靠左位置的程序计算密度越低，属于存储受限型应用，即影响性能的主要因素是存储器带宽不足。对于计算受限型应用，GPU 执行性能一般比同代 CPU 高 10 ～ 20 倍，而对于存储受限型应用，一般加速比为5 ～ 10 倍。必须说明的是，图 1-20 中用到的程序仍然是比较适合 GPU 实现的程序。对于控制流程和访存模式复杂以及并行性不足的代码，GPU 的性能甚至可能低于 CPU。因此，CPU 和 GPU 更多的是互补关系，而不是互相取代的关系，这也是 AMD 在单片芯片上集成 CPU 和 GPU 的出发点。</p><p> Intel Xeon Phi 是作为 GPU 设计的，当时代号为 Larrabee［18］，不过后来定位为专用计算加速器。<img src="https://s2.loli.net/2021/12/10/S6Relr4kdxIhWgj.png" alt="S6Relr4kdxIhWgj"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>［ 1 ］ C O’Hanlon. A Conversation with John Hennessy and David Patterson [J]. ACM Queue, 2006-2007, 4(10): 14-22.</p><p>［ 2 ］ T Theoharis, G Papaioannou, N Platis, et al. Graphics &amp; Visualization Principles &amp; Algorithms [M]. A. K. Peters, Ltd., 2008.</p><p>［ 3 ］ Khronos. OpenGL Shading Language 4.40 Speciﬁcation [S]. 2013.</p><p>［ 4 ］ K A Duke, W A Wall. A Professional Graphics Controller [J]. IBM Systems Journal, 1985, 24(1): 14-25.</p><p>［ 5 ］ J H Clark. The Geometry Engine: A VLSI Geometry System for Graphics [C]. Computer Graphics and Interactive Techniques, 1982, 127-133.</p><p>［ 6 ］ H Fuchs, J Goldfeather, J P Hultquist, et al. Fast Spheres, Shadows, Textures, Transparencies, and Image Enhancements in Pixel-Planes [C]. Advances in Computer Graphics, 1985, 111-120.</p><p>［ 7 ］ K Akeley. Reality Engine Graphics [C]. SIGGRAPH, 1993, 109-116.</p><p>［ 8 ］ J Montrym, H Moreton. The GeForce 6800 [J]. IEEE Micro, 2005, 25(2): 41-51.</p><p>［ 9 ］ J D Owens, D Luebke, N Govindaraju, et al. A Survey of General-Purpose Computation on Graphics Hardware [J]. Computer Graphics Forum, 2007, 26(1):80–113.</p><p>［10］ J Nickolls, W Dally. The GPU Computing Era [J]. IEEE Micro, 2010, 30(2): 56-69.</p><p>［11］ HSA Foundation. HSA Platform System Architecture Specification 1.0 [EB/OL]. 2014. <a href="http://www.hsafoundation.com/?ddownload=4944">http://www.hsafoundation.com/?ddownload=4944.</a></p><p>［12］ HSA Foundation. HSA Programmer Reference Manual Speciﬁcation 1.0 [EB/OL]. 2014.</p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加访客地图</title>
      <link href="/2021/12/05/928a/"/>
      <url>/2021/12/05/928a/</url>
      
        <content type="html"><![CDATA[<p>前往 clustrmaps 网站注册一个帐号。找到 Free Tools下面的 Website Widget, 点击 Get Map Widget。输入你的博客网址，点击Next。根据你自己的喜好选择样式Map widget 或 Globe Widget（本人使用后者）。找到如下代码，记住 src (** 的部分):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> id=<span class="string">&quot;clstr_globe&quot;</span> src=<span class="string">&quot;**********************&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在 themes\Butterfly\layout\includes\widget文件夹新建card_map.pug文件，文件内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card-widget</span><span class="selector-class">.card-map</span></span><br><span class="line">  <span class="selector-class">.card-content</span></span><br><span class="line">    <span class="selector-class">.item-headline</span></span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_map&#x27;)</span><br><span class="line">    script#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;此处填入你自己的代码&quot;)</span><br></pre></td></tr></table></figure><p>编辑 themes\Butterfly\layout\includes\widget\index.pug 文件，在你想要显示的位置插入以下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!=partial(&#x27;includes/widget/card_map&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>具体放置位置，可以参考下图（⚠️切记：如果主题版本大于3.6，请务必将{cache:theme.fragment_cache} 改为 { cache:true }）：</p><p>编辑_config.butterfly.yml 文件，在card_webinfo 下面添加一行card_map: true</p><p>编辑themes\Butterfly\languages\zh-CN.yml文件 (请根据你的网站语言选择)，找到card_announcement: 公告 , 在下面添加一行card_map: 访客地图 (后面的文本可自定义),繁体字方法一样，修改themes\Butterfly\languages\zh-TW.yml文件就行。</p><p>如果不想显示，直接把 _config.butterfly.yml文件的card_map: true 改为 card_map: false 即可。</p><p>以下是全部源代码</p><h3 id="themes-Butterfly-layout-index-pug"><a href="#themes-Butterfly-layout-index-pug" class="headerlink" title="themes/Butterfly/layout/index.pug"></a>themes/Butterfly/layout/index.pug</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#aside-content</span><span class="selector-class">.aside-content</span></span><br><span class="line">  //- post</span><br><span class="line">  if is_post()</span><br><span class="line">    if showToc &amp;&amp; theme<span class="selector-class">.toc</span><span class="selector-class">.style_simple</span></span><br><span class="line">      <span class="selector-class">.sticky_layout</span></span><br><span class="line">        include ./card_post_toc<span class="selector-class">.pug</span></span><br><span class="line">    else</span><br><span class="line">      !=partial(&#x27;includes/widget/card_author&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_top_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)      </span><br><span class="line">      <span class="selector-class">.sticky_layout</span></span><br><span class="line">        if showToc</span><br><span class="line">          include ./card_post_toc<span class="selector-class">.pug</span></span><br><span class="line">        !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  else</span><br><span class="line">    //- page</span><br><span class="line">    !=partial(&#x27;includes/widget/card_author&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    !=partial(&#x27;includes/widget/card_top_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)      </span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.sticky_layout</span></span><br><span class="line">      !=partial(&#x27;includes/widget/card_map&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_newest_comment&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_categories&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_tags&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_archives&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_webinfo&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_bottom_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>themes/Butterfly/layout/card_map.pug</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card-widget</span><span class="selector-class">.card-map</span></span><br><span class="line">  <span class="selector-class">.card-content</span></span><br><span class="line">    <span class="selector-class">.item-headline</span></span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=&quot;true&quot;)</span><br><span class="line">      span= _p(&#x27;aside.card_map&#x27;)</span><br><span class="line">    script#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;//clustrmaps.com/globe.js?d=xxxxxxxxx&quot;)</span><br></pre></td></tr></table></figure><p>themes/Butterfly/languages/zh-CN.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">framework:</span> <span class="string">框架</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">主题</span></span><br><span class="line"></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">success:</span> <span class="string">复制成功</span></span><br><span class="line">  <span class="attr">error:</span> <span class="string">复制错误</span></span><br><span class="line">  <span class="attr">noSupport:</span> <span class="string">浏览器不支持</span></span><br><span class="line"></span><br><span class="line"><span class="attr">page:</span></span><br><span class="line">  <span class="attr">articles:</span> <span class="string">文章总览</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">category:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line"></span><br><span class="line"><span class="attr">card_post_count:</span> <span class="string">条评论</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sticky:</span> <span class="string">置顶</span></span><br><span class="line"><span class="attr">no_title:</span> <span class="string">无题</span></span><br><span class="line"></span><br><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">created:</span> <span class="string">发表于</span></span><br><span class="line">  <span class="attr">updated:</span> <span class="string">更新于</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="string">字数总计</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="string">阅读时长</span></span><br><span class="line">  <span class="attr">min2read_unit:</span> <span class="string">分钟</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="string">阅读量</span></span><br><span class="line">  <span class="attr">comments:</span> <span class="string">评论数</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">文章作者</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">文章链接</span></span><br><span class="line">    <span class="attr">copyright_notice:</span> <span class="string">版权声明</span></span><br><span class="line">    <span class="attr">copyright_content:</span> <span class="string">&#x27;本博客所有文章除特别声明外，均采用</span></span><br><span class="line"><span class="string">      &lt;a href=&quot;%s&quot; target=&quot;_blank&quot;&gt;%s&lt;/a&gt; 许可协议。转载请注明来自 &lt;a href=&quot;%s&quot; target=&quot;_blank&quot;&gt;%s&lt;/a&gt;！&#x27;</span></span><br><span class="line">  <span class="attr">recommend:</span> <span class="string">相关推荐</span></span><br><span class="line">  <span class="attr">edit:</span> <span class="string">编辑</span></span><br><span class="line"></span><br><span class="line"><span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">input_placeholder:</span> <span class="string">搜索文章</span></span><br><span class="line">  <span class="attr">hits_empty:</span> <span class="string">&#x27;找不到您查询的内容：$&#123;query&#125;&#x27;</span></span><br><span class="line">  <span class="attr">hits_stats:</span> <span class="string">&#x27;找到 $&#123;hits&#125; 条结果，用时 $&#123;time&#125; 毫秒&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">本地搜索</span></span><br><span class="line">  <span class="attr">input_placeholder:</span> <span class="string">搜索文章</span></span><br><span class="line">  <span class="attr">hits_empty:</span> <span class="string">&#x27;找不到您查询的内容：$&#123;query&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pagination:</span></span><br><span class="line">  <span class="attr">prev:</span> <span class="string">上一篇</span></span><br><span class="line">  <span class="attr">next:</span> <span class="string">下一篇</span></span><br><span class="line"></span><br><span class="line"><span class="attr">comment:</span> <span class="string">评论</span></span><br><span class="line"></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">articles:</span> <span class="string">文章</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">card_announcement:</span> <span class="string">公告</span></span><br><span class="line">  <span class="attr">card_map:</span> <span class="string">访客地图</span></span><br><span class="line">  <span class="attr">card_categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">card_tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">card_archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">card_recent_post:</span> <span class="string">最新文章</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">headline:</span> <span class="string">网站资讯</span></span><br><span class="line">    <span class="attr">article_name:</span> <span class="string">文章数目</span></span><br><span class="line">    <span class="attr">runtime:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">已运行时间</span></span><br><span class="line">      <span class="attr">unit:</span> <span class="string">天</span></span><br><span class="line">    <span class="attr">last_push_date:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">最后更新时间</span></span><br><span class="line">    <span class="attr">site_wordcount:</span> <span class="string">本站总字数</span></span><br><span class="line">    <span class="attr">site_uv_name:</span> <span class="string">本站访客数</span></span><br><span class="line">    <span class="attr">site_pv_name:</span> <span class="string">本站总访问量</span></span><br><span class="line">  <span class="attr">more_button:</span> <span class="string">查看更多</span></span><br><span class="line">  <span class="attr">card_newest_comments:</span></span><br><span class="line">    <span class="attr">headline:</span> <span class="string">最新评论</span></span><br><span class="line">    <span class="attr">loading_text:</span> <span class="string">正在加载中...</span></span><br><span class="line">    <span class="attr">error:</span> <span class="string">无法获取评论，请确认相关配置是否正确</span></span><br><span class="line">    <span class="attr">zero:</span> <span class="string">没有评论</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">图片</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">链接</span></span><br><span class="line">    <span class="attr">code:</span> <span class="string">代码</span></span><br><span class="line">  <span class="attr">card_toc:</span> <span class="string">目录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">date_suffix:</span></span><br><span class="line">  <span class="attr">just:</span> <span class="string">刚刚</span></span><br><span class="line">  <span class="attr">min:</span> <span class="string">分钟前</span></span><br><span class="line">  <span class="attr">hour:</span> <span class="string">小时前</span></span><br><span class="line">  <span class="attr">day:</span> <span class="string">天前</span></span><br><span class="line">  <span class="attr">month:</span> <span class="string">个月前</span></span><br><span class="line"></span><br><span class="line"><span class="attr">donate:</span> <span class="string">打赏</span></span><br><span class="line"><span class="attr">share:</span> <span class="string">分享</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rightside:</span></span><br><span class="line">  <span class="attr">readmode_title:</span> <span class="string">阅读模式</span></span><br><span class="line">  <span class="attr">font_plus_title:</span> <span class="string">放大字体</span></span><br><span class="line">  <span class="attr">font_minus_title:</span> <span class="string">缩小字体</span></span><br><span class="line">  <span class="attr">translate_title:</span> <span class="string">简繁转换</span></span><br><span class="line">  <span class="attr">night_mode_title:</span> <span class="string">浅色和深色模式转换</span></span><br><span class="line">  <span class="attr">back_to_top:</span> <span class="string">回到顶部</span></span><br><span class="line">  <span class="attr">toc:</span> <span class="string">目录</span></span><br><span class="line">  <span class="attr">scroll_to_comment:</span> <span class="string">直达评论</span></span><br><span class="line">  <span class="attr">setting:</span> <span class="string">设置</span></span><br><span class="line">  <span class="attr">aside:</span> <span class="string">单栏和双栏切换</span></span><br><span class="line"></span><br><span class="line"><span class="attr">copy_copyright:</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">作者</span></span><br><span class="line">  <span class="attr">link:</span> <span class="string">链接</span></span><br><span class="line">  <span class="attr">source:</span> <span class="string">来源</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Snackbar:</span></span><br><span class="line">  <span class="attr">chs_to_cht:</span> <span class="string">你已切换为繁体</span></span><br><span class="line">  <span class="attr">cht_to_chs:</span> <span class="string">你已切换为简体</span></span><br><span class="line">  <span class="attr">day_to_night:</span> <span class="string">你已切换为深色模式</span></span><br><span class="line">  <span class="attr">night_to_day:</span> <span class="string">你已切换为浅色模式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">loading:</span> <span class="string">加载中...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">error404:</span></span><br><span class="line">  <span class="attr">error_title:</span> <span class="string">页面没有找到</span></span><br><span class="line">  <span class="attr">back_button:</span> <span class="string">回到主页</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>config.butterfly.yml</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-weixin</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">微信</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://raw.githubusercontent.com/geekdanny/images/master/wechat.jpg</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">每天进步一点点</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">updated</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_map:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为麒麟解漫画为你解读数字信号的“速算家</title>
      <link href="/2021/12/04/eeae/"/>
      <url>/2021/12/04/eeae/</url>
      
        <content type="html"><![CDATA[<p>今天看到一篇非常好的关于DSP的科普文。SoC厂商很少把DSP芯片作为卖点，但是DSP又是一个特别重要的IP。今天转一篇关于DSP的漫画科普文。原文出处应该来自华为的麒麟。但是本文转自：<a href="https://www.sohu.com/a/405305932_635179">https://www.sohu.com/a/405305932_635179</a></p><p>DSP作为一种独特的微处理器，是业内人士经常接触的芯片。然而对于广大吃瓜小白来说，DSP是一种声名在外，却很少见到真面目的芯片。目前来看，各大厂商对DSP的宣传和描述很少，深度的科普文章对于小白来说又比较些晦涩难懂，怎样才能轻松理解DSP呢？</p><p><img src="https://s2.loli.net/2021/12/05/jxSrBWng9vO8Iqd.png" alt="img"></p><p>其实，认识DSP并不难，DSP即Digital Signal Processor，数字信号处理器。如果把DSP拟人的话，TA一定是位数学能力超强，性格单纯的技术派。今天我们通过华为麒麟发布的漫画小故事来认识DSP。</p><p><strong>应势而生，超强数字信号计算能力“惊呆”众人</strong></p><p>很久很久以前，森林中有一家“麒麟工坊”，工坊由CPU创办，起初只有CPU、Memory、Modem三位合伙人，慢慢的GPU、ISP、NPU、DSP等新成员相继加入。工坊内每个人都有自己独特的职能，成员之间相互合作慢慢将工坊发展壮大。</p><p><img src="https://s2.loli.net/2021/12/05/NHlsxpaTJohu8SD.png" alt="img"></p><p>可是，如今实力雄厚的麒麟工坊，在发展过程中也并非一帆风顺。比如在DSP加入前，工坊就曾遇到一次难关。随着数字技术不断发展，更高清的语音、融合虚拟与现实AR摄影、速度更快的5G等，都对芯片的数字信号处理能力提出了更高要求。因此，麒麟工坊的工作量逐渐堆积成山。</p><p><img src="https://s2.loli.net/2021/12/05/xt8HXIDu43LAWaJ.png" alt="img"></p><p>为了完成这些任务，CPU与GPU只能加班加点地工作。然而，高压的工作不仅令CPU、CPU疲于应付，电源管理芯片也要累瘫了。</p><p><img src="https://s2.loli.net/2021/12/05/9WeHu7CdsmP2qvc.png" alt="img"></p><p>会造成这种情况，主要是因为现有的微处理器不够擅长数字信号处理。还好，麒麟工坊的外援神秘博士现身，推荐了一位新成员——DSP。</p><p><img src="https://s2.loli.net/2021/12/05/3ManpxJC1VfRstj.png" alt="img"></p><p>与想象中“身强力壮”的形象有些不符，DSP的结构与CPU相似，都具有完整的内核、指令集、内存等，是独立的微处理器，但是个头却比CPU小了很多，相比CPU高达2.86GHz的主频，DSP的主频只有几百MHz，不过也正因如此，DSP的能效比要更高。</p><p>举个例子，假设在同一天时间里，CPU处理30件数字信号任务需要消耗5格电，GPU处理50件数字信号任务需要消耗3格电，那么DSP完成100件任务仅消耗1格电，能效明显更优秀。这样一来，不仅能快速完成堆积的任务，电源管理芯片也得救了。</p><p><img src="https://s2.loli.net/2021/12/05/Ilp9zoRK4WMcCvx.png" alt="img"></p><p><strong>小而精的DSP，为什么能够力挽产能问题？</strong></p><p>DSP虽然也是一块独立的微处理器，但是由于架构、指令集等之间的差异，使得DSP的能力有些“偏科”。相比较来说，CPU擅长控制、处理多样化任务，而DSP更擅长各种与数字相关的运算。</p><p>当然，偏科并非不好，CPU与DSP相比就像厨师套刀与削皮刀一样，虽然厨师刀能够擅长各种丰富多样的任务，但是在削皮方面却无法与DSP相比。在芯片领域中，CPU虽然能力出众，但在处理数字信号任务时却不如“削皮刀”DSP效率高。也正是因为如此，DSP更适合处理自己擅长的数字信号任务，充分发挥自己的价值。</p><p><img src="https://s2.loli.net/2021/12/05/v1suQVCcY6NZebk.png" alt="img"></p><p>DSP为什么在处理数字信号任务上如此出色，我们从架构、核心、指令集三个角度来解读。</p><p>首先在架构方面，DSP采用了哈佛架构，这一结构中程序存储器和数据存储器采用不同的总线，通过指令、数据分开的方式，两条总线能够重叠访问两个空间。这样一来DSP就有更大的存储器带宽，数据的移动和交换更加方便，本质上是非常适合处理数字信号任务的。</p><p><img src="https://s2.loli.net/2021/12/05/wjZL3rblQAiqUx9.png" alt="img"></p><p>另外DSP的核心频率比较低。一般来讲，高频运行时钟需要更高的电压，会导致功耗迅速增长。因此频率更低的DSP采用了复杂的并行计算，能够在更短时间内以更高性能、更低功耗来完成任务。</p><p><img src="https://s2.loli.net/2021/12/05/P2yNTmuXbtfCgYe.png" alt="img"></p><p>在指令集方面DSP同样拥有很多专项优势，比如DSP具有专门的硬件乘法器，加入了单周期加指令、逆序加减指令、块重复指令等，甚至将很多常用操作组成的序列专门设计一个指令，最大化每个时钟周期能完成的工作，提升数字信号处理速度。可以说，DSP设计的初衷就是为了兼具更强大的数据处理能力和超低功耗。</p><p><img src="https://s2.loli.net/2021/12/05/579aYBrKspxAfuR.png" alt="img"></p><p>在展现出过人的数字信号处理能力之后，DSP受到了工坊老员工们的认可。其后，工坊向神秘博士申请了另一位DSP。两位DSP一位负责AP内的相机、语音等任务，一位负责基带中的数字信号处理任务。</p><p><img src="https://s2.loli.net/2021/12/05/g8xXHKmuvloVALG.png" alt="img"></p><p>故事讲到这里，想必大家已经知道所谓的“麒麟工坊”是指麒麟SoC了。DSP在SoC设计中起到的关键性作用，就是通过高效的数字信号处理能力提升SoC的整体能效比。除此之外，DSP加入SoC后，其他元件也能够发挥更强的性能。比如ISP能够完成更加复杂的图像算法，实现了如“AR敦煌”等打破文化与时空界限的出色应用。</p><p><img src="https://s2.loli.net/2021/12/05/qp8YcAJ5nbO7i6l.png" alt="img"></p><p>另外随着5G的发展，通信系统的任务量相比以往也有巨大的膨胀和增长。DSP加入“通信部”后，通过其专长帮助基带内的数字信号任务走上快车道，保证了5G时代依然能够实现性能、能效同步升级。</p><p><img src="https://s2.loli.net/2021/12/05/9L13B4kzNlTvPwI.png" alt="img"></p><p>小而精的“偏科学霸”DSP，其实是从“芯”赋能芯片性能的好手。未来，DSP也将持续升级，与SoC内的其他元件一起努力实现更好的综合体验。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 5G手机基带射频全景图</title>
      <link href="/2021/12/03/7de8/"/>
      <url>/2021/12/03/7de8/</url>
      
        <content type="html"><![CDATA[<p>今天看到平安证券投资公司在2020年发布的一份《5G手机全景图之基带射频篇》报告，如今已经是2021年底。今天回头看这份报告，虽然觉得有部分出入，但是依然觉得这份报告当时的整体的分析和预期是非常精准。今天拿出来，做一些围绕2021年的数据的修正和重新解读。这份报告发出的时候，正是全世界5G的元年，也是世界疫情爆发的第4个月。</p><p>报告指出：</p><ol><li>“Soc(含基带)在手机BOM里占比25%左右，是手机中最关键的芯片。进入5G时代，全球有能力研发5G的基带芯片公司剩下了<strong>高通、MTK、三星LSI、华为海思和紫光展锐</strong>。5G基带平均单价较4G有接近200%的提升。受益于5G手机放量，预计未来三年全球基带市场复合增长率达到10%。”</li><li>“高通独特的<strong>定价机制和强势的销售策略动摇了OEM的主导地位</strong>。为了减少对高通的依赖，手机OEM厂商亟需替代方案，国内芯片厂商迎来发展契机。华为海思和紫光展锐分别推出<strong>麒麟</strong>系列和<strong>虎贲</strong>系列实现了5G芯片的战略卡位，成为国产手机主芯片的“双子星”，引领国产替代潮流。”  但是，从2021年底的今天来看，海思的Balong Modem已经无法量产。所以，高通将依然保持不可动摇的基带市场领先地位。</li></ol><h2 id="基带芯片行业竞争格局变迁（2000-2021）"><a href="#基带芯片行业竞争格局变迁（2000-2021）" class="headerlink" title="基带芯片行业竞争格局变迁（2000~2021）"></a>基带芯片行业竞争格局变迁（2000~2021）</h2><p><img src="https://s2.loli.net/2021/12/04/aeX4kI9iCSVJFDx.png" alt="aeX4kI9iCSVJFDx"></p><h2 id="基带出货量与手机出货量挂钩"><a href="#基带出货量与手机出货量挂钩" class="headerlink" title="基带出货量与手机出货量挂钩"></a>基带出货量与手机出货量挂钩</h2><p>智能手机是基带出货量的主要驱动力,功能机和智能功能机次之，三者出货量比例约为75%、20%、5%；从趋势来看，14年以后，随着华为、三星自研Soc的占比增加，高通、MTK的份额出现下降；以出货量来看，2019年基带市场出货量22.3亿片，份额依次为：高通28%、MTK27%、紫光展锐16%、英特尔11%、海思10%、三星8%；</p><p><img src="https://s2.loli.net/2021/12/04/QK49kMdjn8S1IRO.png" alt="QK49kMdjn8S1IRO"></p><p><img src="https://s2.loli.net/2021/12/04/Lnph9GODqPotTYN.png" alt="image-20211203184258803"></p><p>以金额来看，2019年整个基带市场规模达到209亿美金，其中高通收入87亿美金（42%）、海思收入34亿美金（16%）、英特尔收入28亿美金（14%）、MTK收入27亿美金（13%）、三星LSI收入25亿美金（12%）、紫光展锐收入7.2亿美金（3%）；</p><p><img src="https://s2.loli.net/2021/12/04/tvY5hS9Lbrsglcn.png" alt="tvY5hS9Lbrsglcn"></p><p><img src="https://s2.loli.net/2021/12/04/OkCvxrUmhRLlgsp.png" alt="OkCvxrUmhRLlgsp"></p><h2 id="基带芯片产业链"><a href="#基带芯片产业链" class="headerlink" title="基带芯片产业链"></a>基带芯片产业链</h2><h3 id="标准组织："><a href="#标准组织：" class="headerlink" title="标准组织："></a>标准组织：</h3><p>3GPP和ITU作为技术标准的建立者，负责制定包括2G/3G/4G/5G在内的通信技术标准，决定了整个行业的发展方向。</p><h3 id="芯片产业链："><a href="#芯片产业链：" class="headerlink" title="芯片产业链："></a>芯片产业链：</h3><p>基带芯片的制造和其他芯片类似，主要有IP授权、设计、晶圆制造、封装测试四大环节；IP授权有ARM、Ceva等；设计公司主要有高通、MTK、海思、展锐、三星LSI。<img src="https://s2.loli.net/2021/12/04/HlSxqQ6UtVMP2aY.png" alt="HlSxqQ6UtVMP2aY"></p><h3 id="终端应用产业链："><a href="#终端应用产业链：" class="headerlink" title="终端应用产业链："></a>终端应用产业链：</h3><p>终端应用产业链主要有仪器仪表、入网认证、OEM和外包测试四个部分：</p><p>1）测试仪表是芯片设计和终端开发必不可少的工具，提供包括通信协议一致性、射频一致性、功耗等KPI指标的测试环境。测试仪表行业受国产替代和5G商用的双重利好，国内的星河亮点、大唐联仪有望未来三年保持高速增长。入网认证机构有各大运营商以及官方部门的检测认证机构，例如工信部下属的泰尔实验室等；</p><p>2）OEM包括传统手机OEM和通信模组厂商；</p><p>3）外包测试企业为运营商、OEM等企业提供外场测试服务。</p><p><img src="https://s2.loli.net/2021/12/04/TbRelkE7r1fPISO.png" alt="TbRelkE7r1fPISO"></p><h2 id="芯片公司走势"><a href="#芯片公司走势" class="headerlink" title="芯片公司走势"></a>芯片公司走势</h2><p>海思受打压，便宜了高通，展锐引领5G国内市场，苹果字眼基带芯片，以取代高通</p><p>Soc(含基带)在手机BOM里占比25%左右，是手机中最关键的芯片。苦于高通独特的定价机制和强势的销售策略，天下苦“高通”久矣；华为14年就开始使用自研麒麟，目前麒麟9000已经达到了一流水平，可惜受美国制裁无法生产芯片；</p><p>展锐的前身是展讯，在3G时代几乎靠一己之力支撑起了TDS移动芯片供应，4G时代展讯的多模基带整合不利一度让公司陷入困境，18年底拥有海思背景的CEO楚庆加盟，开始大刀阔斧改革。未来展锐有望依靠紫光集团和大基金的支持，重新进入第二梯队，引领5G国内市场。而从下图2020年来看，海思当时还占据主要的国内基带市场份额。</p><p><img src="https://s2.loli.net/2021/12/04/I5N3aWeYhiEFjwp.png" alt="I5N3aWeYhiEFjwp"></p><h3 id="欧美厂商处于领先位置"><a href="#欧美厂商处于领先位置" class="headerlink" title="欧美厂商处于领先位置"></a>欧美厂商处于领先位置</h3><p>下图是对2020年基带和射频产业的营收总结。目前北美还是处于领先位置。</p><p><img src="https://s2.loli.net/2021/12/05/KYjLPkEx2UpNRSZ.png" alt="KYjLPkEx2UpNRSZ"></p><h3 id="中国公司梳理"><a href="#中国公司梳理" class="headerlink" title="中国公司梳理"></a>中国公司梳理</h3><p><img src="https://s2.loli.net/2021/12/05/QAYizrd9X2LyS46.png" alt="image-20211204101950758"></p><p>下图的数据还以2020年的芯片为主。到了2021年12月，骁龙最新的发布的8 Gen1 芯片来看其5G下行速度已经是所有芯片里的最快的，达到10Gbps，支持毫米波。</p><p><img src="https://s2.loli.net/2021/12/04/fzNGC5O3DvtwYeP.png" alt="fzNGC5O3DvtwYeP"></p><h2 id="基带芯片概况"><a href="#基带芯片概况" class="headerlink" title="基带芯片概况"></a>基带芯片概况</h2><h3 id="基带芯片："><a href="#基带芯片：" class="headerlink" title="基带芯片："></a>基带芯片：</h3><p>基带芯片是实现UE与PLMN联网的关键，是终端实现通信功能必不可少的芯片。基带芯片包括基带处理器、收发器、电源管理芯片、WNC等。目前主流的基带芯片主要分为Soc和外挂基带两种形式。</p><p><img src="https://s2.loli.net/2021/12/05/iSgkepslBm56jQ8.png" alt="iSgkepslBm56jQ8"></p><h3 id="Soc（System-on-chip）"><a href="#Soc（System-on-chip）" class="headerlink" title="Soc（System on chip）:"></a>Soc（System on chip）:</h3><p>是将AP与BP集成在一个die内，AP与BP均为超大规模逻辑芯片，具有相似的硬件架构，所以能够使用相同的制程，做在一颗die上，一方面增加了集成度，可以缩小芯片面积、降低功耗，另一方面与AP绑定销售，提升了芯片价值。目前主流的Soc方案供应商主要有MTK、华为海思、三星LSI，客户主要有HOVM、三星。</p><h3 id="外挂式（Fusion）基带："><a href="#外挂式（Fusion）基带：" class="headerlink" title="外挂式（Fusion）基带："></a>外挂式（Fusion）基带：</h3><p>外挂式基带AP和BP独立封装成两颗芯片的形式，主要是苹果采用自研AP+外挂基带的方案；另外高通第二代5G旗舰平台865也采用外挂式基带的方案，主要是基于商业考量，另外X55支持毫米波频段，size大于sub6G基带，整合难度较高。</p><p><img src="https://s2.loli.net/2021/12/05/DUQJ5zrapVwYK7O.png" alt="DUQJ5zrapVwYK7O"></p><h2 id="基带芯片是软件与硬件的综合"><a href="#基带芯片是软件与硬件的综合" class="headerlink" title="基带芯片是软件与硬件的综合"></a>基带芯片是软件与硬件的综合</h2><h3 id="基带芯片硬件架构"><a href="#基带芯片硬件架构" class="headerlink" title="基带芯片硬件架构"></a>基带芯片硬件架构</h3><p><img src="https://s2.loli.net/2021/12/05/a3psCvbUS1VJ2NW.png" alt="a3psCvbUS1VJ2NW"></p><p>基带芯片的硬件架构采用MCU+DSP+ASIC的形式。硬件是基带芯片的躯体，决定了基带性能的下限；</p><p>MCU主要用于运行基带协议栈代码，目前主流的基带MCU多采用ARM内核，主要是Cortex A系列和Cortex R系列。另外，为了降低基带芯片功耗，还会额外采用一颗Cortex M作为基带芯片在飞行模式、待机等低功耗场景下的MCU；</p><p>DSP是基带芯片的核心硬件，用来实现无线通信物理层（L1）核心算法。主要功能有编解码、FFT/iFFT、CRC校验等，DSP决定了基带芯片数据吞吐能力。DSP有自行研发和IP授权两种，高通、MTK、海思采用自研方案，其他厂商采用Ceva公司的IP授权；ASIC：包括基带芯片内部调试接口，外围接口等附属功能的实现，这类芯片复杂度较低，一般采用IP授权的方式。</p><h3 id="基带芯片软件架构"><a href="#基带芯片软件架构" class="headerlink" title="基带芯片软件架构:"></a>基带芯片软件架构:</h3><p>基带芯片软件主要有实时操作系统（RTOS）、驱动程序（Drivers）和协议栈（Protocol Stack），协议栈是基带软件的核心。软件是基带芯片的灵魂，决定了芯片的性能上限。</p><p><img src="https://s2.loli.net/2021/12/05/pWmrNzU9I63otAd.png" alt="pWmrNzU9I63otAd"></p><h2 id="射频前端市场规模"><a href="#射频前端市场规模" class="headerlink" title="射频前端市场规模"></a>射频前端市场规模</h2><h3 id="5G驱动射频前端市场快速增长"><a href="#5G驱动射频前端市场快速增长" class="headerlink" title="5G驱动射频前端市场快速增长"></a>5G驱动射频前端市场快速增长</h3><p>5G带动全球射频前端市场快速增长根据Yole Development的统计与预测，2019年射频前端市场为167亿美元，到2022年有望达到221.75亿美元，以市场份额来看，Skyworks 20%、村田20%、Qorvo 19%、博通19%，高通依靠5G基带的优势在射频前端份额上升到3%；2019年国内手机制造商采购射频前端芯片（含分立器件）41亿美元，未来两年仍将保持快速增长，从份额来看，华为以44%的份额居首，Vivo 18%、Oppo、小米各12%、ODM 11%。</p><p><img src="https://s2.loli.net/2021/12/05/RYVsgWXLbn1A8OS.png" alt="RYVsgWXLbn1A8OS"></p><p><img src="https://s2.loli.net/2021/12/05/1vHOXgFma7pDNw9.png" alt="1vHOXgFma7pDNw9"></p><h3 id="国产手机品牌助力射频芯片国产化提速："><a href="#国产手机品牌助力射频芯片国产化提速：" class="headerlink" title="国产手机品牌助力射频芯片国产化提速："></a>国产手机品牌助力射频芯片国产化提速：</h3><p>根据Strategy Analytics 数据显示，2019年全球5G智能手机出货量为1870万部，销量前三名分别为华为、三星、vivo，国产手机厂商在5G智能手机的市场份额合计超过50%。在我国移动互联网跳跃式发展的背景下，国内智能手机市场保持高速增长，同时中美贸易摩擦推动了芯片领域国产化进程加速。</p><p><img src="https://s2.loli.net/2021/12/05/7UjTebLEVDc5KfS.png" alt="image-20211204093255985"></p><p><img src="https://s2.loli.net/2021/12/05/Q8MKewvcyulm3YB.png" alt="Q8MKewvcyulm3YB"></p><h2 id="5G射频前端工艺相较4G变化有限"><a href="#5G射频前端工艺相较4G变化有限" class="headerlink" title="5G射频前端工艺相较4G变化有限"></a>5G射频前端工艺相较4G变化有限</h2><p><img src="https://s2.loli.net/2021/12/05/GwuUoHeZy9dcvQM.png" alt="GwuUoHeZy9dcvQM"></p><h3 id="功率放大器："><a href="#功率放大器：" class="headerlink" title="功率放大器："></a>功率放大器：</h3><p>目前的主流依然是GaAs PA。基于GaAsp-HMET工艺的PA以其耐高压、高功率、纵相电流特性和良好的衬底特性而特别适</p><p>合射频功率放大器应用，在3G、4G智能手机领域有着不可撼动的地位，这些优势延续到了5G。</p><h3 id="开关-LNA-Tuner"><a href="#开关-LNA-Tuner" class="headerlink" title="开关/LNA/Tuner:"></a>开关/LNA/Tuner:</h3><p>射频开关采用包括SOI 、CMOS 、GaAs-PHEMT等材料工艺，SOI是射频开关的主要技术平台，SOI工艺预计长期维持在</p><p>90%左右的出货份额，CMOS工艺约占比7%-8%左右。在5G时代，SOI仍然是类开关器件的主流工艺。</p><h3 id="滤波器-Duplexer"><a href="#滤波器-Duplexer" class="headerlink" title="滤波器/Duplexer:"></a>滤波器/Duplexer:</h3><p>4G多采用SAW/BAW，对于Band3、Band8、Band41等特殊频段采用BAW、TC-SAW；5G频段对于滤波器的宽容度高于4G，首先N41可以延续Band41设计，N78、N79频段周边干扰较少，对滤波器的截止带宽要求较低，因此大多采用成本较低的LTCC或者IPD工艺。</p><h3 id="射频前端是推动5G手机价格上涨的主要原因之一"><a href="#射频前端是推动5G手机价格上涨的主要原因之一" class="headerlink" title="射频前端是推动5G手机价格上涨的主要原因之一"></a>射频前端是推动5G手机价格上涨的主要原因之一</h3><p><img src="https://s2.loli.net/2021/12/05/BPgebnfU9TlIHKw.png" alt="BPgebnfU9TlIHKw"></p><h2 id="2020年Sub6G助力5G渗透率提升"><a href="#2020年Sub6G助力5G渗透率提升" class="headerlink" title="2020年Sub6G助力5G渗透率提升"></a>2020年Sub6G助力5G渗透率提升</h2><p>根据全球5G标准化组织的3GPP协议规定，5G使用的频段包括两类，一类范围为450MHz<del>6GHz，也被称为Sub 6GHz频段；另一类范围为24.25GHz</del>52.6GHz，因其波长在1毫米~10毫米之间，故也通常被称为毫米波。</p><h3 id="主流频段集中在sub-6G："><a href="#主流频段集中在sub-6G：" class="headerlink" title="主流频段集中在sub 6G："></a>主流频段集中在sub 6G：</h3><p>目前阶段，5G射频前端的主流频段集中在sub 6G。国内是N41、N78和N79；欧洲以N28、N78为主，日韩以N78为主；在5G时代，N78将成为全球通用频段。</p><p><img src="https://s2.loli.net/2021/12/05/HzvX3C64ISMKYPV.png" alt="HzvX3C64ISMKYPV"></p><h3 id="新功能增加接收端数量："><a href="#新功能增加接收端数量：" class="headerlink" title="新功能增加接收端数量："></a>新功能增加接收端数量：</h3><p>5G引入了4*4 MIMO、SRS和EN-DC等功能，要求射频前端的接收端必须具备单频段四路接收的能力，相较于4G使用的两路接收方案，价格提升了229%。以国内5G手机为例，高端机型普遍采用221方案，即2路N41、2路N78和1路N79主集芯片，接收端相应需要额外的2路N41、2路N78和3路N79分集芯片；中低端机型普遍采用211方案，即2路N41、1路N78和1路N79主集芯片，则接收端需要额外的2路N41、3路N78和3路N79分集芯片，主集芯片大多采用PAMid方案，供应商为国外的高通、Qorvo、Sky；分集芯片是国内厂商最大的机会，国内的卓胜微、唯捷创芯、昂瑞微有望进入国内Tier1 OEM供应商名单。<img src="https://s2.loli.net/2021/12/05/u9kfzMEynYglJKB.png" alt="u9kfzMEynYglJKB"></p><h2 id="2022年毫米波开始逐步落地"><a href="#2022年毫米波开始逐步落地" class="headerlink" title="2022年毫米波开始逐步落地"></a>2022年毫米波开始逐步落地</h2><p>毫米波雨衰、穿透性等性能指标较差，难以实现大规模部署。现阶段采用毫米波布网的主要是美国，日本、韩国跟进。美国。在现有5G的技术标准框架下，毫米波的发展不容乐观，原因有以下两点：</p><p>1、在北电宣布倒闭之后，北美已经没有一家主设备商有能力支持美国的毫米波产业的发展；</p><p>2、华为、中兴被禁止进入美国市场则加剧了对毫米波阵营的孤立，爱立信、诺基亚面对华为、中兴在欧洲市场的竞争，不会放弃sub 6G市场去全力押注毫米波，而高通作为移动芯片公司则没有能力推动整个运营商网络建设。</p><p>不过，随着移动通信快速演进，低频段资源面临耗尽挑战，而毫米波技术因更新迭代，在攻克成本与性能两大传统技术软肋后，也再次被启用。截至目前，全球已有28家运营商在毫米波频段进行了商用部署。</p><p>当然，随着美国 Sub-6 中频段逐渐开放，可以和毫米波形成互补之势，前者负责拓展覆盖范围，后者可以专注于应对体育场、商场等人群密集的应用场景。</p><p>先 Sub-6，后毫米波，两条技术路线双管齐下，这是很多国家早就采用的思路。现在看来，此前一直押注毫米波的美国最终也不得不走上相似的道路。</p><p>据GSMA大中华区总裁斯寒透露，从亚太区域及全球来看，26GHz现在是被部署和发放牌照最多的、最热门的毫米波频段，另外37GHz~40GHz也在美国和其他国家与地区得到了部署或牌照，是仅次于26GHz的热门频段。</p><p>在国内，5G毫米波也同样发展迅速。据闻库指出，目前我国5G毫米波技术标准逐渐成熟。在3GPP完成34.25GHz~35.25GHz频段毫米波的标准化工作后，工信部已经确定了我国5G研发技术的实验，并在实验室和5G外场进行实验。</p><p>与此同时，闻库表示，5G毫米波的应用场景也在不断扩大。“5G毫米波不仅能够面向to C的用户提升体育赛事的直播体验，提高上行速率，还可以面向工业制造领域的大带宽、低时延的to B场景，提高高速率传输和定位能力。”在闻库看来，这也代表5G毫米波正在走向行业应用。</p><p>此外，闻库表示，国内厂商也在不断加快研发进度。在24.75GHz~27.5GHz频段、独立组网和非独立组网、800M带宽同时上下行工作、大上行帧结构等研发方面取得了卓有成效的进展。</p><p>而在终端及芯片领域，记者了解到，高通、海思、三星、联发科等也都推出了毫米波芯片。截至目前，全球商用的毫米波终端芯片已有约70款，以手机和CPE（客户前置设备）为主。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>BOM：（Bill of Material）物料清单，也就是以数据格式来描述产品结构的文件，是计算机可以识别的产品结构数据文件，也是ERP的主导文件。</p><p>Die：Die指的是芯片未封装前的晶粒,是从硅晶元(Wafer)上用激光切割而成的小片(Die)，每一个Die就是一个独立的功能芯片，最终将被作为一个单位而被封装起来成为我们常见的芯片。Die是不能直接使用的，没有引脚，没有散热片。</p><p><img src="https://s2.loli.net/2021/12/05/jBGRpDHPlIAnNh9.png" alt="jBGRpDHPlIAnNh9"></p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 手机终端芯片竞品对比</title>
      <link href="/2021/12/01/e774/"/>
      <url>/2021/12/01/e774/</url>
      
        <content type="html"><![CDATA[<p>在天玑9000芯片发布不到两周，高通昨天发布了<strong>Snapdragon 8 Gen1</strong>, 命名上没有继承上一代888+的规范。采用三星 4nm 工艺，CPU 性能提升 20%，GPU 提升 30%，搭载全新 X65 基带。那么到此为止。2021年底之前露面的主要芯片都已经聚齐。我们来做一下对比和梳理。</p><p><img src="https://i.loli.net/2021/12/02/6Gxt1XgfMdlUeqn.png" alt="6Gxt1XgfMdlUeqn"></p><p>从整体的芯片配置规格上来对比，似乎天玑9000略占优势。两者都采用了最新的ARMv9指令集，CPU 微架构方面跟骁龙8Gen1 规格基本一致，但是L3 cache和System Level Cache 都要大很多。另外，两者都采用了集成的集成Modem的SoC，</p><p>我们先来看一下知乎上的一篇跑分文章。</p><p>骁龙8 Gen 1和<a href="https://www.zhihu.com/search?q=天玑900&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">天玑900</a>0到底谁更强？这是一个数码圈都在关心的问题。</p><p><img src="https://i.loli.net/2021/12/02/Fkwenb1qvPyGpRI.png" alt="Fkwenb1qvPyGpRI"></p><p>根据数码闲聊站带来的消息，骁龙8 Gen 1的安兔兔联网跑分首次确认，搭载机型为realme新机，总分是1025215分。</p><p><img src="https://i.loli.net/2021/12/02/piFcBRO4jNfAnET.jpg" alt="img"></p><p>事情开始有趣了起来，相信很多人都还记得，天玑9000的安兔兔跑分，是1007396分。也就是说，骁龙8 Gen 1的综合性能和天玑9000非常接近，<a href="https://www.zhihu.com/search?q=极限&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">极限</a>性能差距不会超过2%。</p><p>在性能非常接近的情况下，天玑9000采用的是台积电4nm制程，而骁龙8 Gen 1采用的是三星4nm制程。问题来了，骁龙8 Gen 1那点微弱的领先，能拉平三星4nm和<a href="https://www.zhihu.com/search?q=台积电4nm&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">台积电4nm</a>之间的差距吗？</p><p><img src="https://i.loli.net/2021/12/02/3oOQ1KdPCI5ye7F.jpg" alt="img"></p><p>很遗憾，答案是不能。</p><p><strong><a href="https://www.zhihu.com/search?q=台积电5nm&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">台积电5nm</a>＞三星4nm＞三星5nm</strong></p><p>原因很简单：三星4nm看起来和台积电4nm是同代工艺，但是真实水平差了一大截。</p><p>举个例子，根据公开资料显示，三星4nm的<a href="https://www.zhihu.com/search?q=晶体管&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">晶体管</a>密度是145.8MTr/mm²，而台积电5nm的晶体管密度已经达到了171.3MTr/mm²。</p><p>晶体管密度是半导体工艺最关键的指标，三星4nm工艺，连台积电第一代5nm都比不过，更别说增强后的台积电4nm了。</p><p><img src="https://i.loli.net/2021/12/02/ABGsVMWC78TNSye.jpg" alt="img"></p><p>换句话来说，你可以粗暴地理解为：台积电4nm＞台积电5nm＞三星4nm＞三星5nm。按照目前曝光的跑分，骁龙8 Gen 1虽然比天玑9000强2%，但是工艺制程至少落后一代半。</p><p>毫无疑问，在台积电版骁龙8 Gen 1上市前，天玑9000会首次占据上风，联发科真的翻盘了——当然，这个结论从跑分里是看不出来的，但是如果有人做功耗测试，结果一定会彻底反转。</p><p><img src="https://i.loli.net/2021/12/02/Y34QkPCAqeLZNBK.jpg" alt="img"></p><h2 id="性能策略的巨大区别"><a href="#性能策略的巨大区别" class="headerlink" title="性能策略的巨大区别"></a><strong>性能策略的巨大区别</strong></h2><p>更有意思的是，天玑9000和骁龙8 Gen 1的安兔兔总分虽然很接近，但是在策略上有非常大的区别！</p><p>根据此前曝光的消息，骁龙8 Gen 1在CPU方面，算是挤牙膏了，提升非常小，可能是基于功耗考虑，避免再次翻车——要注意的是，这个跑分是和骁龙865同频率下的成绩，基本没有提升空间了。</p><p><img src="https://i.loli.net/2021/12/02/kmJ1AOMBYegyRKw.jpg" alt="img"></p><p>而天玑9000把重点都放在了CPU上，CPU单核跑分预计在1332左右，多核跑分预计在4500左右。要知道，iPad mini 6上搭载的A15，CPU单核是1596，多核是4558。</p><p><strong>这意味着两个信息：1，对比iPad mini6上没<a href="https://www.zhihu.com/search?q=超频&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">超频</a>的A15，天玑9000只落后半代，CPU<a href="https://www.zhihu.com/search?q=多核性能&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">多核性能</a>几乎持平；2，骁龙8 Gen 1还停留在<a href="https://www.zhihu.com/search?q=骁龙888&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A438164121}">骁龙888</a>的水平，CPU性能远不如天玑9000。</strong></p><p><img src="https://i.loli.net/2021/12/02/gAdJTFvQCzn9t3K.jpg" alt="img"></p><p>既然如此，为什么骁龙8 Gen 1的安兔兔总分，还要比天玑9000高一点呢？这个变数，就出现在GPU上。</p><h2 id="GPU差距实在太大"><a href="#GPU差距实在太大" class="headerlink" title="GPU差距实在太大"></a><strong>GPU差距实在太大</strong></h2><p>骁龙8 Gen 1的GPU架构将升级到Adreno 730，听说规格十分“炸裂”，预计性能提升40%以上，有希望能打败A15的丐版。</p><p>而天玑9000，采用的是Mali-G710十核GPU，比之前有35%的提升。问题来了，GPU性能是联发科的祖传短板，而且差距非常大。</p><p><img src="https://i.loli.net/2021/12/02/RX3PkzruZh85vAf.jpg" alt="img"></p><p>在曼哈顿3.1测试中，骁龙870的成绩是100FPS/5.7W，天玑1200的成绩是89FPS/7.8W。也就是说，骁龙870在极限性能比天玑1200强12%的同时，功耗还比天玑1200低27%。</p><p>光是对比骁龙870，天玑1200就至少有40%的差距，天玑9000顶多是拉平这个差距——至于隔了两代的骁龙8 Gen 1，只能说一句：对不起，打扰了。</p><p><img src="https://i.loli.net/2021/12/02/tWSsOrLqYn4BcbR.jpg" alt="img"></p><p>说到这里，情况已经很明朗了，安兔兔总分只有2%的差距，也有了一个合理的解释——骁龙8 Gen 1更侧重GPU，而天玑9000更侧重CPU。</p><p>尽管如此，在手机厂商的眼中，骁龙在高端市场的“地位”仍然高于天玑——毕竟，游戏性能才是优先级别最高的“换机驱动力”。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞品分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全世界最大半导体公司2022版</title>
      <link href="/2021/11/22/d6af/"/>
      <url>/2021/11/22/d6af/</url>
      
        <content type="html"><![CDATA[<p>主要分为四类（集成器件制造商，无晶圆厂供应商，晶圆代工厂，虚拟元件供应商）</p><ul><li><strong>集成器件制造商</strong>：指不仅设计和销售微芯片，也运营自己的晶圆生产线。例如：Intel，三星，东芝，意法半导体，英飞凌和恩智浦半导体。</li><li><strong>无晶圆厂供应商</strong>：公司自己开发和销售半导体器件，但把芯片转包给独立的晶圆代工厂生产。例如：Altera(FPL)，爱特(FPL)，博通(网路器件)，CirrusLogicCrystal(音频，视频芯片)，莱迪思(FPL)，英伟达(FPL)，PMC-Sierra(网路器件)，高通(CDMA无线通信)，铁电(不挥发性存储器)，Sun公司(UltraSPARC处理器)，赛灵思(FPL)</li><li><strong>晶圆代工厂</strong>：有自己的晶圆生产线，为其他公司提供制造服务的公司。例如：台 积电，联华电子</li><li><strong>虚拟元件供应商</strong>：只开发综合包并把它们授权给其他公司集成到IC里。例如：ARM，Sci-worx和新思科技。</li></ul><p><img src="https://i.loli.net/2021/11/24/RDivhwBJNp7mzPY.png" alt="RDivhwBJNp7mzPY"></p><p>半导体行业大公司介绍，以下排名不分先后</p><h2 id="1-上海海思技术有限公司"><a href="#1-上海海思技术有限公司" class="headerlink" title="1.上海海思技术有限公司"></a><strong>1.上海海思技术有限公司</strong></h2><p>海思是全球领先的Fabless半导体与器件设计公司。前身为华为集成电路设计中心，1991年启动集成电路设计及研发业务，为汇聚行业人才、发挥产业集成优势，2004年注册成立实体公司，提供海思芯片对外销售及服务。致力于为千行百业客户提供智能家庭、智慧城市及智能出行等泛智能终端芯片解决方案。海思产品覆盖智慧视觉、智慧IoT、智慧媒体、智慧交通及汽车电子、显示、手机终端、数据中心及光收发器等多个领域。</p><p><img src="https://i.loli.net/2021/11/23/iF3y4GqBSNCDxhg.png" alt="iF3y4GqBSNCDxhg"></p><p>海思在深圳、北京、上海、成都、武汉以及新加坡、韩国、日本、欧洲等全球设有12个办事处和研发中心，拥有7000多名员工。经过20多年的发展与积累，海思掌握了国际一流的IC设计与验证技术，拥有先进的EDA设计平台、开发流程和规范，已经成功开发出200多款自主知识产权的芯片，共申请专利8000多项。海思致力于使能全场景智能终端，为全球客户提供品质好、服务优、响应快速的芯片及解决方案，以客户需求为己任、持续为客户创造价值。</p><h2 id="2-中芯国际集成电路制造有限公司"><a href="#2-中芯国际集成电路制造有限公司" class="headerlink" title="2.中芯国际集成电路制造有限公司"></a><strong>2.中芯国际集成电路制造有限公司</strong></h2><p>中芯国际集成电路制造有限公司（“中芯国际”，上交所科创板证券代码：688981，港交所股份代号：00981，美国场外市场交易代码：SMICY）及其控股子公司是世界领先的集成电路晶圆代工企业之一，也是中国内地技术最先进、配套最完善、规模最大、跨国经营的集成电路制造企业集团，提供0.35微米到14纳米不同技术节点的晶圆代工与技术服务。中芯国际总部位于上海，拥有全球化的制造和服务基地。在上海建有一座300mm晶圆厂和一座200mm晶圆厂，以及一座控股的300mm先进制程合资晶圆厂；在北京建有一座300mm晶圆厂和一座控股的300mm合资晶圆厂；在天津和深圳各建有一座200mm晶圆厂；在江阴有一座控股的300mm合资凸块加工厂。中芯国际还在美国、欧洲、日本和中国台湾设立营销办事处、提供客户服务，同时在中国香港设立了代表处。</p><p><img src="https://i.loli.net/2021/11/23/gwCrIBznil2ZhQD.png" alt="gwCrIBznil2ZhQD"></p><p>中芯国际建立全员参与、品质第一、持续改善的观念，坚守质量标准，落实到每项具体工作。鼓励在产品技术研发、提高生产率和优化工作流程上持续创新、积极实践。主动了解客户的期望，在遵守公司信息安全政策的前提下，努力满足客户的需求，与客户建立合作共赢的长期伙伴关系。</p><h2 id="3-紫光股份有限公司"><a href="#3-紫光股份有限公司" class="headerlink" title="3.紫光股份有限公司"></a><strong>3.紫光股份有限公司</strong></h2><p>紫光股份有限公司结合全球信息产业的发展趋势及自身优势业务的特点，将公司战略聚焦于IT服务领域，致力于打造一条完整而强大的“云—网”产业链，向云计算、移动互联网和大数据处理等信息技术的行业应用领域全面深入，并成为集现代信息系统研发、建设、运营、维护于一体的全产业链服务提供商。目前，紫光股份的核心业务基本覆盖IT服务的重要领域：硬件方面提供智能网络设备、存储系统、全系列服务器等为主的面向未来计算架构的先进装备。软件方面提供从桌面端到移动端的各重点行业的应用软件解决方案。技术服务方面涵盖技术咨询、基础设施解决方案和支持服务。软硬件产品和服务都在紫光股份领先的顶层设计中得到有效整合，使信息化系统展现出最优化、完整一体的运行效果。紫光股份有能力为任何大型客户的信息化需求提供完整、领先的IT服务。</p><p><img src="https://i.loli.net/2021/11/23/5bg6KFl3IHPZ9Bv.png" alt="5bg6KFl3IHPZ9Bv"></p><p>紫光股份源自清华，依托清华大学的综合性人才和科技资源优势，健康可持续发展，2019年公司全年实现营业收入540.99亿元。紫光股份是国家重点高新技术企业、国家863计划成果产业化基地、历年入选中国电子信息“百强”企业。新的历史时期，紫光希望在“中国梦”的感召下，持续创新、跨越成长，与客户、合作伙伴、股东、员工一起，携手同行，共创辉煌！</p><h2 id="4-台湾积体电路制造股份有限公司"><a href="#4-台湾积体电路制造股份有限公司" class="headerlink" title="4.台湾积体电路制造股份有限公司"></a><strong>4.台湾积体电路制造股份有限公司</strong></h2><p>台湾积体电路制造股份有限公司，中文简称：台积电，英文简称：tsmc，属于半导体制造公司。成立于1987年，是全球第一家专业积体电路制造服务（晶圆代工foundry）企业，总部与主要工厂位于中国台湾省新竹市科学园区。2020年7月16日，在台积电二季度业绩说明会上，发言人在会上透露，未计划在9月14日之后为华为技术有限公司继续供货。而美国政府5月15日宣布的对华为限制新规将于9月15日生效。2020年7月13日，台媒钜亨网曾报道，台积电已向美国政府递交意见书，希望能在华为禁令120天宽限期满之后，可继续为华为供货。</p><p><img src="https://i.loli.net/2021/11/23/MorlJzYxUVQkw7S.png" alt="GsPwAnWmoj8RISE"></p><p>2020年1月，2020年全球最具价值500大品牌榜发布，台积电排名第218位。2020年5月10日，“2020中国品牌500强”排行榜发布，台积电排名第80位。2020年5月13日，台积电名列2020福布斯全球企业2000强榜第108位。 2020年8月10日，台积公司（TAIWAN SEMICONDUCTORMANUFACTURING)名列2020年《财富》世界500强排行榜第362位。2020年8月26日，台积电（南京）有限公司总经理罗镇球在2020世界半导体大会上表示，台积电的5纳米产品已经进入批量生产阶段，3纳米产品将在2021年面世，并于2022年进入大批量生产。</p><h2 id="5-中国台湾联发科技股份有限公司"><a href="#5-中国台湾联发科技股份有限公司" class="headerlink" title="5.中国台湾联发科技股份有限公司"></a><strong>5.中国台湾联发科技股份有限公司</strong></h2><p>中国台湾联发科技股份有限公司（<a href="https://link.zhihu.com/?target=http%3A//MediaTek.Inc">MediaTek.Inc</a>）是全球著名IC设计厂商，专注于无线通讯及数字多媒体等技术领域。其提供的芯片整合系统解决方案，包含无线通讯、高清数字电视、光储存、DVD及蓝光等相关产品。2020年5月13日，联发科名列2020福布斯全球企业2000强榜第870位。</p><p><img src="https://i.loli.net/2021/11/23/r8At2yzM5DjW7kZ.png" alt="qJ4o5i2avUWds9c"></p><p>联发科技成立于1997 年，已在台湾证券交易所公开上市。总部设于中国台湾地区，并设有销售或研发团队于中国大陆、印度、美国、日本、韩国、新加坡、丹麦、英国、瑞典及阿联酋等国家和地区。2016年联发科营业收入高达2755.1亿元新台币（约合86亿美元），同比增长了29.2%。分析人士认为，这样的成绩主要是由于国产手机的表现优异，同时联发科也在智能手机芯片市场扩大了份额。</p><h2 id="6-联华电子股份有限公司"><a href="#6-联华电子股份有限公司" class="headerlink" title="6.联华电子股份有限公司"></a><strong>6.联华电子股份有限公司</strong></h2><p>联电成立于1980年，为台湾第一家半导体公司。集团旗下有5家晶圆代工厂，包括联电、联诚、联瑞、联嘉以及最新投资的合泰半导体，是全球半导体投资第四大，仅次于英特尔、摩托罗拉及西门子。根据台湾”经济部中央标准局”公布的近5年台湾百大”专利大户”名单，以申请件数排名，联电第一、工研院第二、台积电第三；就取得美国专利件数而言，1993年至1997年所累积的件数，联电是台积电的两倍、台湾工研院的3倍。</p><p><img src="https://i.loli.net/2021/11/23/hfzQEKq2AowxTe1.jpg" alt="img"></p><p>身为半导体晶圆专工业界的领导者，联电提供先进工艺与晶圆制造服务，为IC产业各项主要应用产品生产芯片，并且持续推出尖端工艺技术，联电的客户导向解决方案能让芯片设计公司利用尖端技术的优势，包括28奈米工艺、混合信号/RFCMOS技术，以及其它多样的特殊工艺技术。联电在全球约有超过13,000名员工，在台湾、日本、新加坡、欧洲及美国均设有服务据点，以满足全球客户的需求。</p><h2 id="7-东芝"><a href="#7-东芝" class="headerlink" title="7.东芝"></a><strong>7.东芝</strong></h2><p>东芝（Toshiba），是日本最大的半导体制造商，也是第二大综合电机制造商，隶属于三井集团。公司创立于1875年7月，原名东京芝浦电气株式会社，1939年由东京电气株式会社和芝浦制作所合并而成。东芝业务领域包括数码产品、电子元器件、社会基础设备、家电等。20世纪80年代以来，东芝从一个以家用电器、重型电机为主体的企业，转变为包括通讯、电子在内的综合电子电器企业。进入90年代，东芝在数字技术、移动通信技术和网络技术等领域取得了飞速发展，成功从家电行业的巨人转变为IT行业的先锋。</p><p><img src="https://i.loli.net/2021/11/23/2wtCfLqbhQg9ST3.png" alt="img"></p><p>2019年5月，ICinsghts发布了2019年Q1季度全球半导体市场报告，东芝公司营收下滑了31%，排名从2018年的第八降至现在的第九。东芝集团以尊重人为根本，力争成为能创造丰富的价值并能为全人类的生活、文化作贡献的企业集团。</p><h2 id="8-瑞萨科技"><a href="#8-瑞萨科技" class="headerlink" title="8.瑞萨科技"></a><strong>8.瑞萨科技</strong></h2><p>公司介绍：瑞萨科技是世界十大半导体芯片供应商之一，在很多诸如移动通信、汽车电子和PC/AV 等领域获得了全球最高市场份额。瑞萨科技在2003年4月1日正式成立，以领先的科技实现人类的梦想。结合了日立与三菱电机在半导体领域上的丰富经验和专业知识，配合全球二万七千名员工的无限创意，我们将无处不在，超乎你的想像。</p><p><img src="https://i.loli.net/2021/11/23/YwhHinIP4glvoZq.png" alt="9sFOYe5DMojlZXk"></p><p>科技的价值在于让一切变得可能，身为一家具有领导性和值得信赖的智能晶片解决方案供应商，我们对于拓展明日无处不在的网络世界，担当重要的角色。我们的创造力具前瞻性，为人类创造出更舒适美好的生活。</p><h2 id="9-索尼"><a href="#9-索尼" class="headerlink" title="9.索尼"></a><strong>9.索尼</strong></h2><p>索尼是日本一家全球知名的大型综合性跨国企业集团。总部设于日本东京都港区港南1-7-1。索尼是世界视听、电子游戏、通讯产品和信息技术等领域的先导者，是世界最早便携式数码产品的开创者，是世界最大的电子产品制造商之一、世界电子游戏业三大巨头之一、美国好莱坞六大电影公司之一。其旗下品牌有Xperia，Walkman，Sony Music，哥伦比亚电影公司，PlayStation等。曾有vaio旗下品牌，但在2014年2月6日，索尼剥离VAIO业务，Vaio品牌将由Japan Industrial Partners Inc接手运营。</p><p><img src="https://i.loli.net/2021/11/23/EijGZVhLXoeQA1s.jpg" alt="img"></p><p>2019年3月28日，索尼董事长平井一夫宣布退休，6月18日正式退休，交由公司原首席财务官吉田宪一郎担任。 2020年5月13日，索尼集团发布19～20财年财报，集团销售收入82599亿日元，实现营业利润8455亿日元。去除股权出售及上财年EMI业绩计入等一次性因素，营业利润同比增长1%。</p><h2 id="10-夏普"><a href="#10-夏普" class="headerlink" title="10.夏普"></a><strong>10.夏普</strong></h2><p>夏普公司（Sharp Corporation，シャープ株式会社）是一家日本的电器及电子公司，于1912年由创始人早川德次创立，总公司设于日本大阪。夏普公司自创业以来，开展的业务从收音机、太阳能电池、再到液晶显示器，夏普相继推出了多个“日本首次”、“世界首次”的产品。目前，夏普现已在世界26个国家，64个地区开展业务，是一个大型的综合性电子信息公司。</p><p><img src="https://i.loli.net/2021/11/23/i9TztjWq2lfmHny.png" alt="pm6QIVhFrl1n7CL"></p><p>2016年2月，日本夏普公司同意中国台湾富士康公司提出的收购要约。这是日本技术企业有史以来接受的最大一起海外企业收购。这意味着富士康将对夏普投资超过6500亿日元（约合58亿美元）。夏普董事会全票通过这一收购协议。2016年3月30日下午，鸿海在台湾证券交易所召开记者会，宣布将投资2888亿日元收购夏普普通股，持有66%的股权；与此同时，还将斥资999.999亿日元购买夏普特别股，共计砸3888亿日元（约合224.7亿人民币)取得夏普过半股权。2016年8月11日，富士康表示，中国反垄断部门已经批准了公司对夏普的收购交易。这一进展为富士康全面完成38亿美元收购夏普铺平了道路。</p><h2 id="11-富士通"><a href="#11-富士通" class="headerlink" title="11.富士通"></a><strong>11.富士通</strong></h2><p>Fujitsu（富士通）是世界领先的日本信息通信技术（ICT）企业，提供全方位的技术产品、解决方案和服务。在全球拥有约159,000名员工，客户遍布世界100多个国家。富士通凭借在ICT领域的丰富经验和实力，致力于与客户携手共创美好的未来社会。富士通集团（东京证券交易所上市代码：6702）截至2015年3月31日财政年度的合并收益为4.8兆日元（400亿美元）。</p><p><img src="https://i.loli.net/2021/11/23/BAzVpDFYNErO7dn.png" alt="gWtUHZYd93j4Jei"></p><p>富士通是日本排名第一的IT厂商，全球第四大IT服务公司，全球前五大服务器和PC机生产商，曾经是世界第二大企业用硬盘驱动器的制造商（硬盘业务于2009年第一季度转移到东芝公司旗下）和第四大移动硬盘制造商，是世界财富500强企业。富士通拥有32,000个产品专利技术，名列美国2005年拥有专利最多的前十位。在Dow Jones Sustainability Indexes 和 FTSE4Good Index Series指数中表现卓著，2008年富士通连续第十次在道琼斯 Sustainability Indexs 股指中表现卓越。2013年富士通被美国《财富》杂志评为世界“最受尊敬企业”。</p><h2 id="12-NEC"><a href="#12-NEC" class="headerlink" title="12.NEC"></a><strong>12.NEC</strong></h2><p>日本电气股份有限公司（英语：NEC Corporation，日语：日本电気），简称NEC，是日本的一家跨国信息技术公司，总部位于日本东京港区。NEC为商业企业、通信服务以及政府提供信息技术（IT）和网络产品。在台湾被称为恩益禧。日本电气股份有限公司的经营范围主要分成三个部分：IT解决方案、网络解决方案和电子设备。IT解决方案主要是向商业企业、政府和个人用户提供软件、硬件和相关服务。</p><p><img src="https://i.loli.net/2021/11/23/X8UaDpPdoLZJ4zw.jpg" alt="img"></p><p>网络解决方案主要是设计和提供宽带系统、移动和无线通信网络系统、移动电话、广播和其他系统。NEC的电子设备包括半导体、显示器以及其他的电子器件。NEC还生产面向国际市场的Versa系列笔记本电脑和面向日本国内市场的Lavie系列笔记本电脑。NEC还是地球模拟器（Earth Simulator）的制造商，当时是最快的超级计算机。NEC是住友集团（Sumitomo Group）的成员。</p><h2 id="13-三星"><a href="#13-三星" class="headerlink" title="13.三星"></a><strong>13.三星</strong></h2><p>三星集团是韩国最大的跨国企业集团，三星集团包括众多的国际下属企业，旗下子公司有：三星电子、三星物产、三星人寿保险等，业务涉及电子、金融、机械、化学等众多领域。三星集团成立于1938年，由李秉喆创办。三星集团是家族企业，李氏家族世袭，旗下各个三星产业均为家族产业，并由家族中的其他成员管理，集团领导人已传至李氏第三代，李健熙为现任集团会长，其子李在镕任三星电子副会长。</p><p>旗下子公司包含：三星电子、三星SDI、三星SDS、三星电机、三星康宁、三星网络、三星火灾、三星证券、三星物产、三星重工、三星工程、三星航空和三星生命等，由家族内的李氏成员管理，其中三间子公司被美国《财富》杂志评选为世界500强企业。三星电子是旗下最大的子公司，2009年全球500强企业中，三星电子占据了第40位的一席之地。全球最受尊敬企业排名第50位，三星的品牌价值排名第19位，较2008年又有了2位的进步。在2011年的全球企业市值中为1500亿美元。 </p><p>2016年11月4日晚间消息，三星电子美国公司宣布，将主动召回280万台特定型号的顶部开盖洗衣机。2018年二季度三星在印度的手机发货量为800万部，市场份额为23%，排名第二，仅次于小米。 李克强总理表示：三星电子在华设立的全资子公司累计完成投资108.7亿美元，预计总投资150亿美元。2020年4月，三星宣布退出LCD面板市场，于2020年年底关停旗下在韩国和中国的所有LCD面板产线。</p><h2 id="14-海力士"><a href="#14-海力士" class="headerlink" title="14.海力士"></a><strong>14.海力士</strong></h2><p>Hynix 海力士芯片生产商，源于韩国品牌英文缩写”HY”。海力士即原现代内存，2001年更名为海力士。海力士半导体是世界第三大DRAM制造商，也在整个半导体公司中占第九位。海力士半导体在1983年以现代电子产业有限公司成立，在1996年正式在韩国上市，1999年收购LG半导体，2001年将公司名称改为(株)海力士半导体,从现代集团分离出来。</p><p>2004年10月将系统IC业务出售给花旗集团，成为专业的存储器制造商。2012年2月，韩国第三大财阀SK集团宣布收购海力士21.05%的股份从而入主这家内存大厂。2019年9月5日，据韩国《中央日报》报道，在日本政府限制向韩国出口氟化氢、光刻胶、含氟聚酰亚胺等尖端半导体材料后，SK海力士设在中国无锡的半导体工厂已经完全使用中国生产的氟化氢取代了日本产品。</p><h2 id="15-意法半导体"><a href="#15-意法半导体" class="headerlink" title="15.意法半导体"></a><strong>15.意法半导体</strong></h2><p>意法半导体（ST）集团于1987年成立，是由意大利的SGS微电子公司和法国Thomson半导体公司合并而成。1998年5月，SGS-THOMSON Microelectronics将公司名称改为意法半导体有限公司。意法半导体是世界最大的半导体公司之一。公司2019年全年净营收95.6亿美元; 毛利率38.7%；营业利润率12.6%; 净利润10.32亿美元。</p><p>意法公司销售收入在半导体工业第七大高速增长市场之间分布均衡（五大市场占2007年销售收入的百分比）：通信（35%），消费（17%），计算机（16%），汽车（16%），工业（16%）。据最新的工业统计数据，意法半导体(STMicroelectronics)是全球第五大半导体厂商，在很多市场居世界领先水平。例如，意法半导体是世界第一大专用模拟芯片和电源转换芯片制造商，世界第一大工业半导体和机顶盒芯片供应商，而且在分立器件、手机相机模块和车用集成电路领域居世界前列。</p><h2 id="16-英飞凌"><a href="#16-英飞凌" class="headerlink" title="16.英飞凌"></a><strong>16.英飞凌</strong></h2><p>英飞凌科技公司于1999年4月1日在德国慕尼黑正式成立，是全球领先的半导体公司之一。其前身是西门子集团的半导体部门，于1999年独立，2000年上市。其中文名称为亿恒科技，2002年后更名为英飞凌科技。总部位于德国Neubiberg的英飞凌科技股份公司，为现代社会的三大科技挑战领域——高能效、移动性和安全性提供半导体和系统解决方案。</p><p>Infineon 英飞凌专注于迎接现代社会的三大科技挑战： 高能效、 移动性和 安全性，为汽车和工业功率器件、芯片卡和安全应用提供半导体和系统解决方案。英飞凌的产品素以高可靠性、卓越质量和创新性著称，并在模拟和混合信号、射频、功率以及嵌入式控制装置领域掌握尖端技术。英飞凌的业务遍及全球，在美国加州苗必达、亚太地区的新加坡和日本东京等地拥有分支机构。2018财年（截止 2018年9 月 30 日），公司在全球市场的总营收为75.99亿欧元。</p><h2 id="17-恩智浦"><a href="#17-恩智浦" class="headerlink" title="17.恩智浦"></a><strong>17.恩智浦</strong></h2><p>恩智浦的前身是荷兰飞利浦公司的半导体事业部。2006年，该业务部门从飞利浦拆分出来，并正式成立NXP Semiconductors - 恩智浦半导体。NXP 这个名字来自 “新的体验”（Next Experience），也保留了飞利浦的基因，强调恩智浦累积了过去在飞利浦53年以来的珍贵经验与丰富资源。</p><p>恩智浦独立之初，CEO Richard Clemmer和管理团队就确立了公司的战略，开发市场领先且高度差异化的业务并获取盈利。2015年，恩智浦与另一家领先的半导体公司–飞思卡尔合并，得以在物联网和汽车领域进一步拓展业务，并着重发展安全可靠的边缘计算、连接技术和高效的电源管理解决方案。并在在ADAS、下一代电动汽车以及跨物联网、移动设备和汽车生态系统的安全连接等关键领域确立了市场领导地位。</p><h2 id="18-英特尔"><a href="#18-英特尔" class="headerlink" title="18.英特尔"></a><strong>18.英特尔</strong></h2><p>英特尔是美国一家以研制CPU为主的公司，是全球最大的个人计算机零件和CPU制造商，它成立于1968年，具有52年产品创新和市场领导的历史。1971年，英特尔推出了全球第一个微处理器。微处理器所带来的计算机和互联网革命，改变了整个世界。在2016年世界五百强中排在第51位。2016年4月 ，英特尔推出处理器至强7290F采用了多达72个处理器核心，成为英特尔核心数最多的处理器。2019年2月，英特尔推出至强铂金9282，它有112个线程，是线程最多的处理器。2014年8月14日，英特尔6.5亿美元收购Avago旗下公司网络业务。2015年12月斥资167亿美元收购了Altera公司。2016年4月底，原定在2016年推出的移动处理器凌动产品线的两个新版本取消发布，英特尔将会退出智能手机芯片市场。2016年7月，英特尔宣布该公司历史上规模最大的裁员计划，准备削减1.2万人。</p><p>2016年11月30日，英特尔正在组建Automated Driving Group（自动驾驶事业部，简称ADG）。2018年6月21日英特尔宣布接受CEO布莱恩·科再奇(Brian Krzanich)的辞职。首席财务官罗伯特·斯旺（Robert “Bob” Swan）被任命为临时首席执行官，他于2019年1月31日成为正式CEO。2018年12月，世界品牌实验室编制的《2018世界品牌500强》揭晓，英特尔排名第17位。2019年7月英特尔第二财季净利润41.79亿美元 同比下降17%。2019年全球品牌百强排名13。2020年7月，福布斯2020全球品牌价值100强发布，英特尔排名第12位。9月3日，英特尔推出了新的极简主义 Logo。</p><h2 id="19-美光"><a href="#19-美光" class="headerlink" title="19.美光"></a><strong>19.美光</strong></h2><p>美光科技成立于美国爱达荷州博伊西一家牙科诊所的地下室，最初是一家仅有四名员工的半导体设计公司。美光签订的第一份合约是为 Mostek Corporation 设计 64K 存储芯片。美光(Micron)身为世界第二大内存颗粒制造商。产品在国内极少现身。这是因为美光很少将自己的优质颗粒卖给其他内存品牌。其极品颗粒供自家DIY品牌Crucial使用及品牌机OEM市场。在IBM.COMPAQ.HP.Dell等国际知名品牌都可以看到其内存颗粒的产品。可知其稳定性及超频性好。</p><h2 id="20-高通"><a href="#20-高通" class="headerlink" title="20.高通"></a><strong>20.高通</strong></h2><p>高通（英文名称：Qualcomm，中文简称：高通公司、美国高通或美国高通公司）创立于1985年，总部设于美国加利福尼亚州圣迭戈市，35,400多名员工遍布全球。高通是全球领先的无线科技创新者，变革了世界连接、计算和沟通的方式。把手机连接到互联网，高通的发明开启了移动互联时代。今天，高通的基础科技赋能了整个移动生态系统，每一台3G、4G和5G智能手机中都有其发明 。高通公司是全球3G、4G与5G技术研发的领先企业，目前已经向全球多家制造商提供技术使用授权，涉及了世界上所有电信设备和消费电子设备的品牌。在中国，高通开展业务已逾20年，与中国生态伙伴的合作已拓展至智能手机、集成电路、物联网、大数据、软件、汽车等众多行业 。</p><p>公司股票是标准普尔100和500指数的成分股，在纳斯达克股票市场上的股票交易代码为QCOM。2018年12月，世界品牌实验室发布《2018世界品牌500强》榜单，高通排名第392 。2019福布斯全球数字经济100强榜排名第32位。在《财富》2019“改变世界的公司”榜单中，高通因其对无线技术发展的巨大贡献和对5G的推动，位列第一 。高通还被《快公司》（Fast Company）评选为“2020年全球最具创新力公司”。自2016年起，高通中国连续四年荣获“中国最受尊敬企业”称号，该项评选由《经济观察报》和北京大学联合主办，是体现企业运营、技术创新、社会责任及美誉度等多维度实力的权威奖项。</p><h2 id="21-博通"><a href="#21-博通" class="headerlink" title="21.博通"></a><strong>21.博通</strong></h2><p>Broadcom Corporation （博通公司）（Nasdaq：BRCM）是全球领先的有线和无线通信 半导体公司。其产品实现向家庭、 办公室和移动环境以及在这些环境中传递语音、 数据和多媒体。 Broadcom 为计算和网络设备、数字娱乐和宽带 接入产品以及移动设备的制造商提供业界最广泛的、 一流的片上系统和软件解决方案。2018年7月，博通和企业软件公司CA Technologies宣布，双方已经达成189亿美元现金收购协议。2019年，入选“2019福布斯全球数字经济100强”，排第30位。</p><p>Broadcom 是世界上最大的无线生产半导体公司之一， 年收入超过 25 亿美元。公司总部在美国加利福尼亚州 的尔湾 (Irvine)，在北美洲、亚洲和欧洲有办事处 和研究机构。Broadcom 拥有 2,600 多项美国专利和 1,200 项外国专利，还有 7,450 多项专利申请，并且拥有最广泛的知识产权组合之一，能够解决语音、视频、数据和多媒体的有线和无线传输。Broadcom 总部在美国加利福尼亚州的尔湾 (Irvine)，在北美洲、亚洲和欧洲有办事处和研究机构。</p><h2 id="22-英伟达"><a href="#22-英伟达" class="headerlink" title="22.英伟达"></a><strong>22.英伟达</strong></h2><p>NVIDIA（纳斯达克股票代码：NVDA）是一家人工智能计算公司 [1]  。公司创立于1993年，总部位于美国加利福尼亚州圣克拉拉市。美籍华人Jensen Huang（黄仁勋）是创始人兼CEO。1999年，NVIDIA定义了GPU，这极大地推动了PC游戏市场的发展，重新定义了现代计算机图形技术，并彻底改变了并行计算。 [3]  2017年6月，入选《麻省理工科技评论》“2017 年度全球50大最聪明公司”榜单。 </p><p>在GTC 2020主题演讲中，NVIDIA宣布推出Ampere架构，这是NVIDIA发布的第八代GPU架构，包含超过540亿个晶体管，性能相较于前代提升了高达20倍，也是NVIDIA 8代GPU历史上最大的一次性能飞跃。 [5]  NVIDIA A100是首款基于NVIDIA Ampere架构的GPU。作为一款通用型工作负载加速器，A100还被设计用于数据分析、科学计算和云图形。2020年5月21日，NVIDIA发布了截至2020年4月26日的2021财年第一季度财务报告。第一季度收入达30.8亿美元，较去年同期的22.2亿美元增长39%。数据中心收入创下11.4亿美元的纪录，较去年同期增长80%。GAAP毛利润率创下65.1%的纪录。</p><h2 id="23-AMD"><a href="#23-AMD" class="headerlink" title="23.AMD"></a><strong>23.AMD</strong></h2><p>美国AMD半导体公司专门为计算机、通信和消费电子行业设计和制造各种创新的微处理器（CPU、GPU、主板芯片组、电视卡芯片等)，以及提供闪存和低功率处理器解决方案，公司成立于1969年。AMD致力为技术用户——从企业、政府机构到个人消费者——提供基于标准的、以客户为中心的解决方案。2006 年7 月24 日,AMD 宣布收购ATI,从此ATI成为了AMD的显卡部门。</p><p>AMD提出3A平台的新标志，在笔记本领域有“AMD VISION”标志的就表示该电脑采用3A构建方案(CPU、GPU、主板芯片组均由AMD制造提供)。2018年12月，世界品牌实验室发布《2018世界品牌500强》榜单，amd排名第485。2020年10月27日 AMD 同意以股票交易的形式，按照 350 亿美元的价值收购 Xilinx（赛灵思），AMD 预计交易在 2021 年底完成。</p><h2 id="24-赛灵思"><a href="#24-赛灵思" class="headerlink" title="24.赛灵思"></a><strong>24.赛灵思</strong></h2><p>Xilinx(赛灵思)是全球领先的可编程逻辑完整解决方案的供应商。Xilinx研发、制造并销售范围广泛的高级集成电路、软件设计工具以及作为预定义系统级功能的IP（Intellectual Property）核。2018年7月18日，全球最大的可编程芯片（FPGA）厂商赛灵思宣布收购中国 AI 芯片领域的明星创业公司——深鉴科技。有“中国英伟达”之称的AI芯片初创企业将继续在其北京办公室运营。目前，交易金额及细节尚未公布。</p><p>2019年10月23日， 2019《财富》未来50强榜单公布，赛灵思（Xilinx）排名第17。2020年10月27日 AMD 同意以股票交易的形式，按照 350 亿美元的价值收购 Xilinx（赛灵思），AMD 预计交易在 2021 年底完成。</p><h2 id="25-德州仪器"><a href="#25-德州仪器" class="headerlink" title="25.德州仪器"></a><strong>25.德州仪器</strong></h2><p>德州仪器（英语：Texas Instruments，简称：TI），是美国德克萨斯州一家半导体跨国公司，以开发、制造、销售半导体和计算机技术闻名于世，主要从事创新型数字信号处理与模拟电路方面的研究、制造和销售。除半导体业务外，还提供包括传感与控制、教育产品和数字光源处理解决方案。</p><p>德州仪器（TI）总部位于美国德克萨斯州的达拉斯，并在25多个国家设有制造、设计或销售机构。德州仪器是世界第一大数字信号处理器(DSP)和模拟电路元件制造商，其模拟和数字信号处理技术在全球具有统治地位。在连续收购飞索半导体制造部门、成都成芯半导体之后,2011年德州仪器以65亿美元收购美国国家半导体（National Semiconductor）,进一步强化德仪的模拟半导体巨头地位。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 半导体行业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全球十大晶圆代工企业</title>
      <link href="/2021/11/22/7b14/"/>
      <url>/2021/11/22/7b14/</url>
      
        <content type="html"><![CDATA[<h1 id="台积电"><a href="#台积电" class="headerlink" title="台积电"></a><strong>台积电</strong></h1><p>　　台积公司成立于1987年，是全球首创专业积体电路制造服务的公司。身为专业积体电路制造服务业的创始者与领导者，台积公司在提供先进的晶圆制程技术与最佳的制造效率上已建立声誉。自创立开始，台积公司即持续提供客户最先进的技术及台积公司TSMCCOMPATIBLE®设计服务。</p><p>　　台积公司藉由与每个客户所建立的坚强的夥伴关系，稳定地创造了强而有力的成长。全球的IC供应商因信任台积公司独一无二的尖端制程技术、先锋设计服务、制造生产力与产品品质，将其产品交予台积公司生产。台积公司为约449个客户提供服务,生产超过9,275种不同产品，被广泛地运用在电脑产品、通讯产品与消费性电子产品等多样应用领域。</p><h1 id="格罗方德"><a href="#格罗方德" class="headerlink" title="格罗方德"></a><strong>格罗方德</strong></h1><p>　　格罗方德半导体股份有限公司由AMD拆分而来、与阿联酋阿布扎比先进技术投资公司(ATIC)和穆巴达拉发展公司(Mubadala)联合投资成立的半导体制造企业。</p><p>　　格罗方德是全球领先的提供全方位的半导体设计、研发和制造服务的公司。</p><h1 id="联华电子"><a href="#联华电子" class="headerlink" title="联华电子"></a><strong>联华电子</strong></h1><p>　　联华电子股份有限公司)是半导体晶圆制造业的领导者，提供先进制程技术与晶圆制造服务，为IC产业各项主要应用产品生产芯片。</p><p>　　联电成立于1980年，是台湾第一家半导体公司。联电是世界晶圆专工技术的领导者，持续推出先进制程技术并且拥有半导体业界为数最多的专利。联电的客户导向解决方案能让芯片设计公司利用本公司尖端制程技术的优势，包括通过生产验证的65纳米制程技术、45/40纳米制程技术、混合信号/RFCMOS技术，以及其它多样的特殊制程技术。联电在全球约有12,000名员工，在台湾、日本、新加坡、欧洲及美国均设有服务据点。</p><h1 id="中芯国际"><a href="#中芯国际" class="headerlink" title="中芯国际"></a><strong>中芯国际</strong></h1><p>　　中芯国际集成电路制造有限公司(“中芯国际”，纽交所代号：SMI，港交所股份代号：981)，是世界领先的集成电路晶圆代工企业之一，也是中国内地规模最大、技术最先进的集成电路晶圆代工企业，提供0.35微米到28纳米不同技术节点的晶圆代工与技术服务。</p><p>　　中芯国际总部位于上海，拥有全球化的制造和服务基地。目前，在上海建有一座300mm晶圆厂和一座200mm晶圆厂;在北京建有一座300mm晶圆厂和一座控股的300mm先进制程晶圆厂;在天津和深圳各建有一座200mm晶圆厂;在江阴有一座控股的300mm凸块加工合资厂;在意大利有一座控股的200mm晶圆厂。中芯国际还在美国、欧洲、日本和台湾地区设立行销办事处、提供客户服务，同时在香港设立了代表处。</p><h1 id="力晶半导体"><a href="#力晶半导体" class="headerlink" title="力晶半导体"></a><strong>力晶半导体</strong></h1><p>　　力晶在设立之初即和日本三菱电机缔结技术、生产与销售的策略联盟;目前则与日本DRAM大厂尔必达(Elpida)合作产销最尖端DRAM产品。另一方面，力晶亦为日商瑞萨科技(RenesasTechnologyCorp.)的主要代工夥伴，发展系统晶片(SystemLSI)产品。九十五年力晶和尔必达签订共同开发50奈米DRAM制程技术备忘录，掌握关键科技自主能力;同年，力晶也与瑞萨达成协议，取得AG-ANDFlash技术授权，成为我国第一家具备高容量快闪记忆体产销实力的半导体厂商。</p><h1 id="世界先进积体电路股份有限公司"><a href="#世界先进积体电路股份有限公司" class="headerlink" title="世界先进积体电路股份有限公司"></a><strong>世界先进积体电路股份有限公司</strong></h1><p>　　世界先进为「特殊积体电路制造服务」领导厂商，自1983年成立以来，在制程技术及生产效能上不断精进，并持续提供最具成本效益的完整解决方案及高附加价值的服务予客户。世界先进於新竹科学园区内拥有二座八寸晶圆厂，目前月产能约100,000片晶圆。</p><h1 id="华虹宏力"><a href="#华虹宏力" class="headerlink" title="华虹宏力"></a><strong>华虹宏力</strong></h1><p>　　上海华虹宏力半导体制造有限公司(以下简称“华虹宏力”)，由原上海华虹NEC电子有限公司和上海宏力半导体制造有限公司新设合并而成，是8英寸纯晶圆代工厂，主要专注于研发及制造专业应用的200mm晶圆半导体，尤其是嵌入式非易失性存储器及功率器件。华虹宏力在上海张江和金桥共有3条8英寸集成电路生产线，月产能达12.9万片。公司总部位于中国上海，在中国台湾地区、日本、北美和欧洲等地均提供销售与技术支持。截至2014年9月30日的200mm晶圆制造产能合计约为每月129,000片。</p><p>　　华虹宏力工艺技术覆盖1微米至90纳米各节点，在标准逻辑、嵌入式非易失性存储器、电源管理、功率器件、射频、模拟和混合信号等领域形成了先进的工艺平台，并正在持续开发多种微机电系统(MEMS)工艺解决方案。华虹宏力共有三座8英寸晶圆厂，洁净室面积达35,000平方米，厂区面积约42万平方米。华虹宏力还有一座12英寸规格厂房，目前租赁给上海华力微电子有限公司，华虹宏力是其主要投资方之一。华虹宏力提供包括各类IP库、设计流程支持、版图设计等芯片设计服务，并依托自有晶圆级芯片测试能力，为客户提供一站式服务。</p><h1 id="Dongbu-HiTek"><a href="#Dongbu-HiTek" class="headerlink" title="Dongbu HiTek"></a><strong>Dongbu HiTek</strong></h1><p>　　Dongbu HiTek在生产高增值化的特殊产品的基础上继续向世界级非储存半导体企业迈进。</p><p>　　非储存半导体行业是属于发达国家的行业领域，技术含量及盈利水平极高，占全球半导体市场的80%。韩国半导体行业发展偏重于储存半导体领域。为了消除这种不均衡格局，Dongbu HiTek正积极展开非储存半导体业务。</p><p>　　Dongbu HiTek除了促进Logic Foundry的先进化(Advanced Logic Foundry)外，还逐步扩大Analog、Mixed-Signal等盈利性高的专项半导体代工服务的比重，不断巩固事业基础。</p><p>　　同时，从2008年起，凭借自身技术成功研发出显示器产品，促进事业结构的尖端化。Dongbu HiTek的服务内容涵盖非储存半导体的设计、制造、营销等附加价值极高的所有环节，为达到世界级非储存半导体制造商的目标已做好充分准备。</p><h1 id="X-FAB"><a href="#X-FAB" class="headerlink" title="X-FAB"></a><strong>X-FAB</strong></h1><p>　　X-FAB是世界最大的模拟/混合信号集成电路技术及晶圆代工厂企业，从事混合信号集成电路(IC)的硅晶片制造。其营销网络和客户群遍布美洲、欧洲和亚洲，每年的产量大约为744,000个200mm等效晶片。作为最大的专业晶圆代工厂，X-FAB不同于一般的晶圆代工厂服务企业，因为它拥有先进模拟和混合信号工艺技术专长。这些技术并非用于具有最小可能结构尺寸的数字应用，而是针对可集成其他功能的模拟应用，例如高压，非易失存储器或传感器。结合可靠、专业化的先进模拟和混合信号工艺技术、优质服务、高水平反应度和一流技术支持，X-FAB能为客户的半导体产品最优地管理产品开发流程和供应链。</p><p>　　在分布于德国、英国、美国和马来西亚的五座晶圆代工厂，X-FAB采用范围从1.0至0.18μm的技术在模块CMOS和BiCMOS工艺上以及专用BCD、SOI和MEMS长寿命工艺上制造晶片。这些制造厂每月总共可处理大约62,000个8英寸等效晶片。X-FAB始终致力于通过专业技术的稳定性、可靠性和可信度来建立长期的客户关系，并且通过为客户提供卓越的技术支持来增加晶片制造工艺的价值。</p><h1 id="TowerJazz"><a href="#TowerJazz" class="headerlink" title="TowerJazz"></a><strong>TowerJazz</strong></h1><p>　　全球特种工艺晶圆代工的领导者，是由Tower半导体公司和Jazz半导体公司合并而来。</p><p>　　TowerJazz的先进工艺包括广泛的定制化工艺平台，如SiGe、BiCMOS、混合信号、CMOS、RF CMOS、CMOS图像传感器、集成电源管理(BCD 700V)和MEMS产品。TowerJazz同时提供世界级设计支持平台，旨在完善其先进的技术，并支持快速准确的设计流程。</p><p>　　此外，TowerJazz还向需要扩大产能的集成器件制造商(IDM)和设计公司提供技术优化流程服务(TOPS)。TowerJazz通过其位于以色列的两家工厂、美国两个工厂及日本的三家工厂，为客户提供额外产能满足客户的生产需求。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 晶元代工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM 架构家族史</title>
      <link href="/2021/11/21/d179/"/>
      <url>/2021/11/21/d179/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>关于ARM的介绍其实很多了。维基百科的介绍可以说非常详细，写这篇文章主要还是提炼一下几个关键点，和自我阶段性的回顾一家公司的过去，现在和未来。另外，我什么在意ARM，因为它所设计IP方案，仍然是目前主流半导体公司设计的基础方案。了解和熟悉ARM，对为了给顶层设计打好基础。</p><h2 id="ARM生命中的几个关键点"><a href="#ARM生命中的几个关键点" class="headerlink" title="ARM生命中的几个关键点"></a>ARM生命中的几个关键点</h2><p>1983年，出生。取名Acorn，3岁以前还都只是个开发项目。当时研发出来的第一款处理器芯片的型号，被定为ARM1。当时ARM1和同时期Intel的80286处理器(也就是常说的286)对比如下：<img src="https://i.loli.net/2021/11/24/5iQtRbLl4kN3MXY.png" alt="5iQtRbLl4kN3MXY"></p><p>1985年，ARM正式推出第一个能商用的产品ARM2。所以这一年可以认为是ARM真正的元年。 ARM2具有32位的<a href="https://zh.wikipedia.org/wiki/資料匯流排">数据总线</a>、26位的<a href="https://zh.wikipedia.org/wiki/定址空間">寻址空间</a>，并提供64 Mbyte的寻址范围与16个32-bit的<a href="https://zh.wikipedia.org/wiki/暫存器">寄存器</a>。ARM2可能是全世界最简单实用的32位微处理器，仅容纳了30,000个<a href="https://zh.wikipedia.org/wiki/電晶體">晶体管</a>（六年后的<a href="https://zh.wikipedia.org/wiki/Motorola_68000">摩托罗拉68000</a>包含了70,000颗）。同一年，英特尔发布了80386。</p><p><img src="https://i.loli.net/2021/11/24/qQpid8ZWuXSng2J.png" alt="Intel 80386"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">Intel 80386</center><p>1991年，跟苹果合作生产出ARM6，ARM6样品出来的时候，正好是ARM六岁。1994年投产了ARM 610 作为苹果Newton 产品的处理器。</p><p>从1994年之后，ARM便进入<strong>每隔两年</strong>的产品演进阶段。</p><p>这里有三个重要的时间点方便记忆：</p><table><thead><tr><th>重要时间点</th><th>Profile</th></tr></thead><tbody><tr><td>2004以前</td><td>ARM 32位旧有架构或Classic Core</td></tr><tr><td>2004~2011</td><td>Cortex 32位架构</td></tr><tr><td>2011~2021</td><td>Cortex 64位架构</td></tr></tbody></table><p><img src="https://i.loli.net/2021/11/24/fKecJ3UYtM2RA8B.png" alt="fKecJ3UYtM2RA8B"></p><h2 id="到底什么是ARM-架构"><a href="#到底什么是ARM-架构" class="headerlink" title="到底什么是ARM 架构"></a>到底什么是ARM 架构</h2><p>在读ARM相关的文档的时候，大家会发现，当提到ARM架构的时候，有两种写法，一种是ARMv， 一种是ARM。前者例如ARMv1、ARVv2等等，后者例如ARM1，ARM2等。</p><p>所有用v来标识的叫做指令集版本，也就是通常所说的ARM指令集架构。而没有v的表示的是ARM处理器的家族，也就是处理器架构。</p><table><thead><tr><th align="center">架构</th><th align="center">处理器家族</th></tr></thead><tbody><tr><td align="center">ARMv1</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=ARM1&action=edit&redlink=1">ARM1</a></td></tr><tr><td align="center">ARMv2</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=ARM2&action=edit&redlink=1">ARM2</a>、<a href="https://zh.wikipedia.org/w/index.php?title=ARM3&action=edit&redlink=1">ARM3</a></td></tr><tr><td align="center">ARMv3</td><td align="center">ARM6、<a href="https://zh.wikipedia.org/wiki/ARM7">ARM7</a></td></tr><tr><td align="center">ARMv4</td><td align="center"><a href="https://zh.wikipedia.org/wiki/StrongARM">StrongARM</a>、<a href="https://zh.wikipedia.org/wiki/ARM7TDMI">ARM7TDMI</a>、<a href="https://zh.wikipedia.org/wiki/ARM9">ARM9</a>TDMI</td></tr><tr><td align="center">ARMv5</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=ARM7EJ&action=edit&redlink=1">ARM7EJ</a>、<a href="https://zh.wikipedia.org/w/index.php?title=ARM9E&action=edit&redlink=1">ARM9E</a>、<a href="https://zh.wikipedia.org/w/index.php?title=ARM10E&action=edit&redlink=1">ARM10E</a>、<a href="https://zh.wikipedia.org/wiki/XScale">XScale</a></td></tr><tr><td align="center">ARMv6</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=ARM11&action=edit&redlink=1">ARM11</a>、<a href="https://zh.wikipedia.org/wiki/ARM_Cortex-M">ARM Cortex-M</a></td></tr><tr><td align="center">ARMv7</td><td align="center"><a href="https://zh.wikipedia.org/w/index.php?title=ARM_Cortex-A&action=edit&redlink=1">ARM Cortex-A</a>、<a href="https://zh.wikipedia.org/wiki/ARM_Cortex-M">ARM Cortex-M</a>、<a href="https://zh.wikipedia.org/w/index.php?title=ARM_Cortex-R&action=edit&redlink=1">ARM Cortex-R</a></td></tr><tr><td align="center">ARMv8</td><td align="center">Cortex-A35、Cortex-A50系列<a href="https://zh.wikipedia.org/wiki/ARM架構#cite_note-cortex-a50_announce-18">[18]</a>、Cortex-A70系列、Cortex-X1</td></tr><tr><td align="center">ARMv9</td><td align="center">Cortex-A510、Cortex-A710、Cortex-X2</td></tr></tbody></table><p>ARM从2004年以后对处理器架构的命名做了重大修改。也就是从ARM11处理器之后，引入Cortex 这个profile。Coretex又分为三个系列：</p><ul><li>“应用”配置: Cortex-A 系列</li><li>“嵌入式”配置: Cortex-R 系列</li><li>“微处理器”配置: <a href="https://zh.wikipedia.org/wiki/ARM_Cortex-M">ARM Cortex-M</a> 系列。</li></ul><p>ARM每次指令集架构版本的升级，都往往往意味着一次重大的改革。例如，ARMv8这一代是从32bits 到64bits 指令集的的一次重大演进。</p><p><img src="https://i.loli.net/2021/11/24/7wbvzTY9sJioanh.png" alt="7wbvzTY9sJioanh"></p><p><img src="https://i.loli.net/2021/11/24/Suto8653gLZj2ae.png" alt="nBAwmLIsWDUX31d"></p><h3 id="ARMv1架构"><a href="#ARMv1架构" class="headerlink" title="ARMv1架构"></a><strong>ARMv1架构</strong></h3><p>1985年，ARMv1架构诞生，该版架构只在原型机ARM1出现过，只有26位的寻址空间(64MB)，没有用于商业产品。</p><h3 id="ARMv2架构"><a href="#ARMv2架构" class="headerlink" title="ARMv2架构"></a><strong>ARMv2架构</strong></h3><p>1986年，ARMv2架构诞生，该版本架构对V1进行了扩展，首颗量产的ARM处理器ARM2就是基于该架构，包含了对32位乘法指令和协处理器指令的支持，但同样仍为26位寻址空间。其后还出现了变种ARMv2a，ARM3即采用了ARMv2a，是第一片采用Cache的ARM处理器。</p><h3 id="ARMv3架构"><a href="#ARMv3架构" class="headerlink" title="ARMv3架构"></a><strong>ARMv3架构</strong></h3><p>1990年，ARMv3架构诞生，第一个采用ARMv3架构的微处理器是ARM6(610)以及ARM7，ARM6作为IP核、独立的处理器、具有片上高速缓存、MMCU和写缓冲的集成CPU，寻址空间增大到32位(4GB)。变种版本有3G和3M。版本3G是不与版本2a相兼容的版本3。版本3M引入了有符号和无符号数乘法和乘加指令。</p><h3 id="ARMv4架构"><a href="#ARMv4架构" class="headerlink" title="ARMv4架构"></a><strong>ARMv4架构</strong></h3><p>1993年，ARMv4架构在V3版上作了进一步扩充，是目前应用最广的ARM架构，ARM7(7TDMI)、ARM8、ARM9(9TDMI)和Strong ARM均采用了该架构。ARM在这个系列中引入了T变种指令集，即处理器可工作在Thumb状态，增加了16位Thumb指令集。V4不再强制要求与26位地址空间兼容，而且还明确了哪些指令会引起未定义指令异常。</p><h3 id="ARMv5架构"><a href="#ARMv5架构" class="headerlink" title="ARMv5架构"></a><strong>ARMv5架构</strong></h3><p>1998年，ARMv5架构诞生，在V4版基础上增加了一些新的指令，ARM7(EJ)、ARM9(E)、ARM10(E)和Xscale采用了该架构，这版架构改进了ARM/Thumb状态之间的切换效率。这些新增命令有带有链接和交换的转移BLX指令；计数前导零CLZ指令；BRK中断指令；增加了数字信号处理指令(V5TE版)；为协处理器增加更多可选择的指令。此外还引入了DSP指令和支持JAVA。</p><h3 id="ARMv6架构"><a href="#ARMv6架构" class="headerlink" title="ARMv6架构"></a><strong>ARMv6架构</strong></h3><p>V6版架构于2001年正式发布，首先被应用在ARM11处理器。V6版架构在降低耗电量的同时，还强化了图形处理性能。它还引进了包括单指令多数据(SIMD)运算在内的一系列新功能。通过追加有效进行多媒体处理的SIMD(Single Instruction，Multiple Data，单指令多数据)功能，将语音及图像的处理功能提高到了原型机的4倍。此外，还引入了混合16位/32位的Thumb-2指令集和Trust Zone技术。</p><h3 id="ARMv7架构"><a href="#ARMv7架构" class="headerlink" title="ARMv7架构"></a><strong>ARMv7架构</strong></h3><p>2004年，ARMv7架构诞生，该版本架构采用了Thumb-2技术，它是在ARM的Thumb代码压缩技术的基础上发展出来的，并且保持了对已存ARM解决方案的完整的代码兼容性。此外，ARMv7还支持改良的运行环境，来迎合不断增加的JIT和DAC技术的使用。</p><p>ARMv7架构还包括NEON™技术扩展，可将DSP和媒体处理吞吐量提升高达400%，并提供改进的浮点支持以满足下一代3D图形和游戏以及传统嵌入式控制应用的需要。</p><p>从这个时候开始ARM以Cortex来重新命名处理器，Cortex-M3/4/7，Cortex-R4/5/6/7，Cortex-A8/9/5/7/15/17都是基于该架构。</p><h3 id="ARMv6-M架构"><a href="#ARMv6-M架构" class="headerlink" title="ARMv6-M架构"></a><strong>ARMv6-M架构</strong></h3><p>2007年，在ARMv6基础上衍生了ARMv6-M架构，该架构是专门为低成本、高性能设备而设计，向以前由8位设备占主导地位的市场提供32位功能强大的解决方案。Cortex-M0/1/0+即采用的该架构。</p><h3 id="ARMv8架构"><a href="#ARMv8架构" class="headerlink" title="ARMv8架构"></a><strong>ARMv8架构</strong></h3><p>2011年，ARMv8架构诞生，Cortex-A32/35/53/57/72/73采用的是该架构，这是ARM公司的首款支持64位指令集的处理器架构。由于ARM处理器的授权内核被广泛用于手机等诸多电子产品，故ARMv8架构作为下一代处理器的核心技术而受到普遍关注。</p><p>ARMv8是在32位ARM架构上进行开发的，主要被用于对扩展虚拟地址和64位数据处理技术有更高要求的产品领域。ARMv8是近20年来，ARM架构变动最大的一次。它引入的Execution State、Exception Level、Security State等新特性，已经颠覆了我们对旧的ARM架构的认知。</p><p>可以看出，从ARMv7架构开始，ARM的命名方式有所改变。新的处理器家族，改以Cortex命名，并分为三个系列，分别是Cortex-A，Cortex-R，Cortex-M。</p><p>Cortex-A：针对高性能计算。如我们目前手机SoC中常出现的Cortex-A76等。</p><p>Cortex-R：针对实时操作处理。主要是面向嵌入式实时处理器。在汽车的电子制动系统，工业控制领域等领域比较常见。</p><p>Cortex-M：专为低功耗、低成本系统设计。目前火热的IoT领域常常见到采用Cortex-M架构的处理器。</p><p>其实，除了上述三大系列之外，还有一个主打安全的Cortex-SC系列(SC：SecurCore)，主要用于政府安全芯片。</p><h2 id="ARM指令架构集跟处理器架构家族的关系图谱"><a href="#ARM指令架构集跟处理器架构家族的关系图谱" class="headerlink" title="ARM指令架构集跟处理器架构家族的关系图谱"></a>ARM指令架构集跟处理器架构家族的关系图谱</h2><p><img src="https://i.loli.net/2021/11/24/iIaoHuqkzF2eUDZ.png" alt="iIaoHuqkzF2eUDZ"></p><h2 id="ARM处理器架构家族跟产品关系图谱"><a href="#ARM处理器架构家族跟产品关系图谱" class="headerlink" title="ARM处理器架构家族跟产品关系图谱"></a>ARM处理器架构家族跟产品关系图谱</h2><p><img src="https://i.loli.net/2021/11/24/qcBAilFW43NTwtz.png" alt="qcBAilFW43NTwtz"></p>]]></content>
      
      
      <categories>
          
          <category> 芯片知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用GitHub和Gitbook写书</title>
      <link href="/2021/11/21/66d6/"/>
      <url>/2021/11/21/66d6/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步-在Github中建立一个仓库-并创建好书的目录"><a href="#第一步-在Github中建立一个仓库-并创建好书的目录" class="headerlink" title="第一步: 在Github中建立一个仓库, 并创建好书的目录"></a>第一步: 在Github中建立一个仓库, 并创建好书的目录</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p><img src="https://i.loli.net/2021/11/22/QhCOBgktR3iKzJX.png" alt="QhCOBgktR3iKzJX"></p><h1 id="第二步：-在Gibook-创建跟Github的Repo关联"><a href="#第二步：-在Gibook-创建跟Github的Repo关联" class="headerlink" title="第二步： 在Gibook 创建跟Github的Repo关联"></a>第二步： 在Gibook 创建跟Github的Repo关联</h1><p><img src="https://i.loli.net/2021/11/22/TZidWnot1vUbqxJ.png" alt="TZidWnot1vUbqxJ"></p><p><img src="https://i.loli.net/2021/11/22/LonTsk39uYdiZCf.png" alt="image-20211121112339977"></p><p><img src="https://i.loli.net/2021/11/22/2EDzrpsmcdkYno6.png" alt="2EDzrpsmcdkYno6"></p><p><img src="https://i.loli.net/2021/11/22/sodFDNwUGYjaPqn.png" alt="sIpFT7d6vGcqXzo"></p><p><img src="https://i.loli.net/2021/11/22/cS7JWGhIFjl9unK.png" alt="cS7JWGhIFjl9unK"></p><p><img src="https://i.loli.net/2021/11/22/qWvsdFOnGSXocfA.png" alt="qWvsdFOnGSXocfA"></p><p><img src="https://i.loli.net/2021/11/22/f2wQHDo7caZlRSq.png" alt="wcSpKhPREY1WslO"></p>]]></content>
      
      
      <categories>
          
          <category> 工程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>芯片里那些傻傻分不清的物理单位和指标</title>
      <link href="/2021/11/20/9614/"/>
      <url>/2021/11/20/9614/</url>
      
        <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>最近看了很多文章，也有很多朋友问我关于芯片的<strong>功耗，能耗，性能，能效，能效比</strong>等一大推专有名词。大家用的很杂乱，我写一篇文章从头给大家梳理一下，清晰的解释和理解这些名词是最关键的。</p><h1 id="初中物理单位回顾"><a href="#初中物理单位回顾" class="headerlink" title="初中物理单位回顾"></a>初中物理单位回顾</h1><p>大家还记得初中物理学的电学吗？我们先从最简单的两个单位回顾。Energy和 Power</p><h2 id="Energy"><a href="#Energy" class="headerlink" title="Energy"></a>Energy</h2><p>中文简称能量，国际单位为焦耳（J）。在营养学里又是也有卡路里（cal）做为能量单位。 </p><p>1cal=4.183J。</p><p>我们来看一段英文的解释：</p><blockquote><p>Energy is the ability to create a change, for example, creating motion. Tasks (like lifting a box) require an amount of energy to complete. A <a href="https://energyeducation.ca/encyclopedia/Battery">battery</a> will hold a particular amount of energy; so will a given amount of <a href="https://energyeducation.ca/encyclopedia/Fuel">fuel</a>, like food.</p><p>The base unit of energy is the <a href="https://energyeducation.ca/encyclopedia/Joule">joule</a>. This means that a task, like lifting a box in figure 1, takes a certain number of joules regardless of how quickly the box is picked up.</p></blockquote><p><img src="https://i.loli.net/2021/11/21/OeNvIXu5SC37TGL.png" alt="OeNvIXu5SC37TGL"></p><p>Lifting a box requires a specific amount of <strong>energy</strong>, no matter how quickly the box is picked up. Lifting faster will change the amount of <strong>power</strong> but not the amount of <strong>energy</strong>.<a href="https://energyeducation.ca/encyclopedia/Energy_vs_power#cite_note-1">[1]</a></p><p>能量是人们日常生活的根源，人活着就需要能量，人类汽车的驾驶，工作和生产都需要能量。人类睡觉都在消耗能量。光说单位，大家可能没有概念，打一个比方：一个水煮鸡蛋热量大概是80卡路里（545焦耳）左右。</p><p><img src="https://i.loli.net/2021/11/21/fsrcLNPylZ4eB1J.png" alt="fsrcLNPylZ4eB1J"></p><p>一个30岁成年男性每天消耗<strong>8400KJ</strong>，大概是<strong>2007</strong>卡的热量，女性为1000卡。（1大卡=1000calories=1kcal）</p><h2 id="Power"><a href="#Power" class="headerlink" title="Power"></a>Power</h2><p>中文简称功率，国际单位为瓦特（W）。定义为<a href="https://zh.wikipedia.org/wiki/能量">能量</a>转换或使用的速率，以单位<a href="https://zh.wikipedia.org/wiki/時間">时间</a>的能量大小来表示，即是作<a href="https://zh.wikipedia.org/wiki/功">功</a>的<a href="https://zh.wikipedia.org/wiki/比率">率</a></p><p>我们来看一段英文的解释：</p><blockquote><p>Power is how fast energy is used or transmitted - power is the amount of energy divided by the time it took to use the energy. Its unit is the <a href="https://energyeducation.ca/encyclopedia/Watt">watt</a>, which is one <a href="https://energyeducation.ca/encyclopedia/Joule">joule</a> per <a href="https://energyeducation.ca/encyclopedia/Second">second</a> of energy used. </p></blockquote><p>所以从上边的解释我们可以看出来<strong>Energy是个容量</strong>，<strong>Power是个效率</strong>。他们之间的关系用一个公式表达就是：</p><p><strong>Energy = Power x Time</strong>. </p><p>or<img src="https://i.loli.net/2021/11/21/Qq3bOWPICAG1NaK.png" alt="Qq3bOWPICAG1NaK"></p><p>上图中W代表做功，或者叫能耗，也就是Energy。</p><p>那么，现在我们再回来看看文章开头给的几个术语</p><p><strong>能耗</strong>，其实说的是Energy，也就是能量消耗。例如kWh（千万小时），表示一件功率为一千瓦的电器在使用一小时之后所消耗的能量。1kW·h = 3,600,000 焦耳= 3.6 百万焦耳，也就是一度电。</p><p><strong>功耗</strong>，其实说的是Power，<strong>功率的损耗，在单位时间中所消耗的能源的数量，单位为 W</strong>。</p><p>所以当我们评估一个电子器件是不是省电，我们更在乎的是他的功耗，<strong>功耗</strong>越低，那么它在一段时间内的<strong>能耗</strong>就越低，也就是说更省电。这一点在移动终端的SoC的设计中非常重要，因为手机的电池Engergy往往是很难提高的。</p><p><img src="https://i.loli.net/2021/11/21/MEsDSFjaR2GPkYt.png" alt="MEsDSFjaR2GPkYt"></p><h1 id="什么是性能（Performance）"><a href="#什么是性能（Performance）" class="headerlink" title="什么是性能（Performance）"></a>什么是性能（Performance）</h1><p>之前提到了能量和功率的问题。那么我们再看看什么是性能。英文对这个词的表达是最直接的。 Performance，即<strong>表现</strong>。</p><p>例如CPU的算力，或者表现可以从一下几个角度来评估：是不是时钟频率更高，指令所需周期（Cycles Per Instruction ）更低，浮点计算能力（FLOPS）更强等。</p><h1 id="什么是能耗比"><a href="#什么是能耗比" class="headerlink" title="什么是能耗比"></a>什么是能耗比</h1><p>能耗比， 是<strong>性能功耗比</strong>的缩写，也可称为<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=6507554">能效比</a> ，或者就简称为<strong>能效</strong>。即<strong>Performance per Watt</strong>，中文翻译为“<strong>每瓦性能</strong>”或者“<strong>性能功耗比</strong>”。 至于手机SoC，一般不说功耗，一般卖点都是提<strong>能效</strong>。 即Performance/Power 的值。 比如下面某厂的CPU性能提升75%，能效（或能效比）提升58%，意思就是用高一点的功耗换来更高的性能。那么1.75/1.58=1.1，也就是“<strong>性能的提升值</strong>”除以“<strong>能效比</strong>”可以求出来功耗（Power）相比之前提高到了1.1。 换句话就是说，<em>新一代产品能耗开销提高了10%，但是性能提高了75%。 能效比为58%.</em>    </p><p><img src="https://i.loli.net/2021/11/21/W8OfQMjXoSCP4q9.png" alt="gpjyilfUvhA7ICX"></p><p>一般我们也会反过来这么计算，一个SoC的性能提升了75%, 它的功耗升高了10%，那么他的能效比是1.75/1.1=1.58，也就是能效提高了58%。 大部分厂商其实是希望降低功耗，并提升性能。让分母降低，分子提高。进而提高能效比（能耗比）的数值。</p><p>以上是对SoC的性能和能效的一个具体的举例。  一般商家卖SoC，展示芯片的性能和能效的时候，都主要集中在CPU这块。我们再看一下GPU这块。如图，性能提升46%， 能效提升178%。 那么1.46/2.78=0.52.  那么0.52-1=-48%。也就是说，GPU在功耗下降了48%的情况下，性能还提升了46%。 这个是一个非常牛逼的提升。 </p><p><img src="https://i.loli.net/2021/11/21/uIyaFPVeGvhMt6p.png" alt="sNjBEIplmu7LG6i">但是，GPU的还有还会多一些数据作为亮点，那就是FPS。</p><p><img src="https://i.loli.net/2021/11/21/EU42CR8kJ3AhYM1.png" alt="sPIxNeLZKbF39dD"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我们来归纳相关术语如表</p><table><thead><tr><th align="center">术语</th><th align="left">描述</th><th align="center">单位</th></tr></thead><tbody><tr><td align="center">Energy、能量、能耗</td><td align="left">一段时间内的所做的功</td><td align="center">J（焦耳）</td></tr><tr><td align="center">Power、功耗，功率</td><td align="left">单位时间内的做功，也就是每秒中所消耗的焦耳</td><td align="center">W（瓦特）</td></tr><tr><td align="center">Performance、性能</td><td align="left">一种计算器件的表现，CPU通过时钟频率，CPI，FLOP等来表现，GPU通过 FPS， mW/frame 等来表示。</td><td align="center">一般都是%来对比</td></tr><tr><td align="center">Power Efficiency,  能效，能效比、能耗比</td><td align="left">Performance÷Power，即<strong>性能</strong>跟<strong>功耗</strong>的对比。一般是个%数值，例如能效提升30%等。 注意：能效提升不代表功耗就下降。只是将性能跟功耗对比来开跟上一代同类产品或同一代竞品的比对。</td><td align="center">一般都是%来对比</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 芯片知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门第二课:向量与线性代数</title>
      <link href="/2021/11/11/4602/"/>
      <url>/2021/11/11/4602/</url>
      
        <content type="html"><![CDATA[<p>图形学有个前置课程，就是线性代数。但是这门课的重点不是线性代数，我们以最快，最猛烈的的节奏将线性代数的重点迅速过一遍。线性代数并不难，这里假设你是个高中生哦，至少得懂数学方程吧。</p><p>本课程的学习课件来自<a href="https://sites.cs.ucsb.edu/~lingqi/index.html">闫令琪</a>教授的 《GAMES101: 现代计算机图形学入门》</p><p>课件下载链接：<strong>向量与线性代数</strong> [<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_02.pdf">课件</a>] 或 <a href="https://drive.google.com/file/d/1nB629JeHU-sZBbxjdH9wWSRn5KMr0fOI/view?usp=sharing">Google Drive</a> </p><p>那为什么我们需要学线性代数呢？</p><p>因为三维空间中的一个点（x,y,z），这实际上就是个向量表示。涉及到各种变换，例如，一个几何图形的平移，旋转，缩放，都可以表示成一个矩阵跟一个向量的乘法。</p><p>首先，Vector，数学上叫向量，物理上叫矢量。他表示的是一个方向。</p><p><img src="https://i.loli.net/2021/11/12/5NzRZK8iQWvm2Pd.png" alt="5NzRZK8iQWvm2Pd"></p><p>向量表示两个属性：</p><ol><li>方向</li><li>长度</li></ol><p>向量无论怎么移动，其向量本身不变。</p><p>![image-20211111122312193](/Users/admin/Library/Application Support/typora-user-images/image-20211111122312193.png)</p><p>图形学里，我们用单位向量来表示向量的方向。</p><p><strong>向量的加法</strong></p><p>两个向量可以相加。在几何学里的理解，一般采用平行四边形法则和三角形法则。</p><p><img src="https://i.loli.net/2021/11/12/mOjSqriu7QaVKI1.png" alt="mOjSqriu7QaVKI1"></p><p>在代数学里，向量可以用<strong>笛卡尔坐标系</strong>来描述。下图是笛卡尔直角坐标系。x是横坐标，沿着x方向走；y是纵坐标，沿着垂直向上的y的方向走。</p><p><img src="https://i.loli.net/2021/11/12/ANJ7KybMoYBfWTc.png" alt="ANJ7KybMoYBfWTc"></p><p>那么向量x 和 向量y 的和就可以表示成上图 的A。那么向量A的长度就是||A||。从上边的坐标系就可以看出来，代数的垂直坐标系可以非常方便的计算出向量的长度。</p><hr><p><strong>向量的乘法</strong></p><p>向量有两个主要的乘法</p><ol><li>Dot Product (点乘)</li><li>Cross Product （叉乘）</li></ol><p><strong>Dot(scalar) Product</strong></p><p><img src="https://i.loli.net/2021/11/12/HbvZJxoETPmwqkh.png" alt="q26Be9IFHgJ8bs1"></p><p>从上边的公式可以看出，两个向量的点乘是一个数。看右边的公式，当两个向量是单位向量的时候，两个向量的点乘就是两个向量的夹角的余弦。</p><p>那么向量的点乘到底怎么算呢？从代数上，点乘既然是一种运算，和其他运算法则一样都会满足三个性质：</p><ol><li>交换律</li><li>分配律</li><li>结合律</li></ol><p><img src="https://i.loli.net/2021/11/12/MB4nHDXfdctzyal.png" alt="MB4nHDXfdctzyal"></p><p>那么换成向量，在笛卡尔坐标系里，两个向量的点乘可以表示如下：</p><p><img src="https://i.loli.net/2021/11/12/hEqwaCHf4YR7ebV.png" alt="vU78xSYiKyR9qbk"></p><p>思考：在图形学里，两个向量的点乘有什么用呢？这里先思考一分钟再往下读。</p><p>答案：点乘在图形学里有两个重要的作用。</p><ol><li><p>用来寻找两个向量的夹角。</p></li><li><p>用来寻找一个向量投影到另一个向量长什么样子。什么叫一个向量在另外一个向量的投影呢？看下边的一个例子：</p></li></ol><p>   <img src="https://i.loli.net/2021/11/12/VThjGnfxE37t1MO.png" alt="XhLtZY9TpF6NruC">))</p><p>在上图中，a和b两个向量的方向是不一样的。现在，我们想把b向量投影在a向量上。假设有一束光垂直照在向量a上，那么b自然会投射一个阴影在a上。那么既然b向量投影在a向量上，那么b的投影一定沿着a向量。那么为了计算投影的长度，就可以依照直角三角形关系，投影的长度就是b向量的长度 乘 a和b的夹角余弦。</p><p><strong>Cross Product</strong> </p><p>叉乘是计算出垂直于两个输入向量的第三个向量。可以参考下边的示意图：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/z1XvDy.png" alt="z1XvDy"></p><p>上图黄色的向量就是向量a和b的叉乘。但是叉乘的结果既然是个向量，不光有长度，也会有方向。那么叉乘的结果怎么决定呢，这里要介绍“<em>右手螺旋定则</em>”：</p><p>两向量叉乘如a叉乘b，则结果向量的方向用右手螺旋定则判定。</p><p>右手螺旋定则：先将两向量移动到同一起点，右手四指从a转到b,则拇指所指方向，即为结果向量的方向。</p><p>a叉乘b所得向量方向一定是垂直于a,b所在平面的。</p><p>叉乘方向右手螺旋定则怎么判断方向</p><p>a×b的方向：四指由a开始，指向b，拇指的指向就是a×b的方向，垂直于a和b所在的平面</p><p>b×a的方向：四指由b开始，指向a，拇指的指向就是b×a的方向，垂直于b和a所在的平面</p><p>a×b的方向与b×a的方向是相反的，且有：a×b=-b×a</p><p>这告诉我们，叉乘并不满足乘法交换律。</p><p>思考：叉乘在图形学的里作用又是什么呢？</p><p>答案：我们可以用来建立一个三维空间的直角坐标系。在三维空间中，给出一个x轴和y轴，我们可以得到z轴。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/dXNjqF.png" alt="dXNjqF"></p><p>这里有个通用解释：如果看到</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"> <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/CryyTp.png" alt="CryyTp"></p><p>那么我们就说这是个<strong>右手坐标系</strong>。如果是-z，那就是<strong>左手坐标系</strong>。在我们这门课里，我们考虑的都是右手坐标系，但是在OpenGL里，它假设的是-z，也就是<strong>左手坐标系</strong>。</p><p>那么，上边的公式里,如果一个向量 叉乘 它自己，为什么是0？</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/JyoD1V-20211111133458532.png" alt="JyoD1V"></p><p>我们可以通过公式推导：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/77JKXV.png" alt="77JKXV"></p><p>两个向量的叉乘=两个向量的长度 X 他们的夹角的正弦值。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/iqvToj.png" alt="iqvToj"></p><p>这里帮助大家复习一下三角函数：</p><p>正弦值是在直角三角形中，對邊的長比上斜邊的長的值。任意銳角的正弦值等于它的餘角的餘弦值，任意銳角的餘弦值等于它的餘角的正弦值。所以，</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/YN2GFU.png" alt="YN2GFU"></p><p>另外，向量的叉乘在代数上的笛卡尔坐标系的也可以表达出来：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/YUtfu2.png" alt="YUtfu2"></p><p>一个向量可以用矩阵表示出来，然后叉乘另外一个矩阵。向量的矩阵形式叉乘，我们会在下一节课展开讲细节。</p><p>思考：向量的叉乘在图形学里有什么作用？</p><p>答案：</p><ol><li>判定左或右</li><li>判定内或外</li></ol><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/1kxqR2.png" alt="1kxqR2"></p><p><em>怎么判断左右呢？</em>参考上图，如果向量a叉乘向量b 得出来的z是正的，那么按照右手定则，就说明，b在a的左侧；否则，就在右侧。</p><p><em>怎么判断内或外呢？</em></p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/q8Tko0.png" alt="q8Tko0"></p><p>如图上，一个三角型按照三个向量逆时针排布。接下来我们按照右手定则，旋转AB和AP，那么可以判断p在AB的左侧；同样判断BC和AP，发现p在BC的左侧；同理判断CA和AP，发现p在AC的左侧。也就是说，p点在三角形的三边左侧，那么p就在三角形内。</p><p>对于任何一个三角型，如果一个点，一直都在一个三角形的三边的左边，或者三边的右边，那么则可以判断这个点在三角形的内部。</p><p>那么，线性代数的基础就复习完了，下一节课，我们重点来讲矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门第一课:计算机图形学概述</title>
      <link href="/2021/11/11/3a27/"/>
      <url>/2021/11/11/3a27/</url>
      
        <content type="html"><![CDATA[<p>本人计划从GPU开始，将用三个月时间带领大家学习图形学。本课程的主要目的是想把复杂的东西讲给小白，哪怕读者只是个中学生。</p><p>本课程的学习课件来自<a href="https://sites.cs.ucsb.edu/~lingqi/index.html">闫令琪</a>教授的 《GAMES101: 现代计算机图形学入门》</p><p>课件下载链接：<strong>计算机图形学概述</strong> [<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_01.pdf">课件</a>] 或 <a href="https://drive.google.com/file/d/16YooJ2hrOVlkzfoImmF16ku_jPQzs8ft/view?usp=sharing">Google Drive</a> </p><p>学习图形学的基础课要求。</p><ul><li>【必须】：高等数学（微积分、线性代数）、算法、数据结构</li><li>【非必须】：信号处理、数值分析、大学物理（光学）</li></ul><p>教材：</p><p>【非必须】：Steve Marschner and Peter Shirley，“Fundamentals of Computer Graphics”，第三版或更新版本。很遗憾中文版应该只有第二版，大家也可以对照着看。不过英文版写得非常好，浅显易懂，所以应该并无太大问题。</p><p><em>本课程内容部分素材来自互联网和加州大学图形学课程。如果引用缺失和不懂，望请指正。</em></p><p><strong>Lecture 1：计算机图形学概述</strong></p><p><img src="https://i.loli.net/2021/11/12/FStafHKJ5w91iGd.png" alt="ODfEJcY8Fi4tdkr"></p><p>跳过废话，直接上来讲干货。游戏，电影特效，VR， AR 世界，装潢设计，模拟，等方方面面都是图形学在现实生活中的应用。大家还记得《星际穿越》那部电影的各种特效吗？那个宏伟的黑洞？就是电脑模拟出来的。</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2021/11/12/vBCqaNtDj9LzMWw.png" alt="icBKHjJgNaLqID8"></h1><p>图形学是不是很cool！这门课主要主要分为四个部分:</p><ul><li>Rasterization(光栅化)</li><li>Curves and Meshes（曲线和网格）</li><li>Ray Tracing （光线追踪）</li><li>Animation、Simlulation （动画和模拟）</li></ul><hr><p><strong>Rasterization(光栅化)</strong></p><p>研究怎么把三维的几何形体现在屏幕上，例如如何表示光滑的曲面。</p><p><img src="https://i.loli.net/2021/11/12/RESNvpWOUa6ZzBw.png" alt="LcBiJ3VnoMvFk1U"></p><p><strong>Curves and Meshes（曲线和网格）</strong></p><p>研究如何用计算机图形学来表示几何形状</p><p><img src="https://i.loli.net/2021/11/12/gWQw73phzML5a6Z.png" alt="6LTt3WlNq5hSIF9"></p><p><strong>Ray Tracing （光线追踪）</strong></p><p>研究怎么把将光线投入到显示的物体上，达到更好，更真实的显示效果。</p><p><img src="https://i.loli.net/2021/11/12/NgqiShAJ5WuHrfj.png" alt="bqne4g2NZDaQxlE"></p><p><strong>Animation、Simlulation （动画和模拟）</strong></p><p>研究动画中的行为。例如一个小球撞到地上，发生了什么样的变型，是怎样弹跳起来的。</p><p><img src="https://i.loli.net/2021/11/12/FJ9MVnOUGzATjmP.png" alt="El9ZczNtubhK2Vf"></p><p>这门课主要和大家一起学习图形学，<em>并不教*</em>图形学API<strong>和</strong>编程语言***。任何一个科学学到一定程度以后，就会发现基础科学是一切的关键。基础科学才是上层应用科学大厦的基石。</p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解剖计算机构成的 39课入门</title>
      <link href="/2021/07/17/d0b3/"/>
      <url>/2021/07/17/d0b3/</url>
      
        <content type="html"><![CDATA[<p>带你解剖计算机构成的 39课入门课成为大佬（视频分享，直得收藏）</p><p>视频下载链接<br><a href="https://www.aliyundrive.com/s/S8MHbQCerK9">https://www.aliyundrive.com/s/S8MHbQCerK9</a></p><p>图文并茂，风趣解说，真心不错。<br>第一课：《计算机早期历史》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET4M4D_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET4M4D_shd.mp4</a><br>第二课：《电子计算机》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET3FQK_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET3FQK_shd.mp4</a><br>第三课：《布尔逻辑和逻辑门》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET4D1T_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET4D1T_shd.mp4</a><br>第四课：《二进制》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET4UJ9_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET4UJ9_shd.mp4</a><br>第五课：《算术逻辑单元》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET6SLB_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET6SLB_shd.mp4</a><br>第六课：《寄存器&amp;内存》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET6D36_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET6D36_shd.mp4</a><br>第七课：《中央处理器(CPU)》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET70AQ_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET70AQ_shd.mp4</a><br>第八课：《指令和程序》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET7MKU_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET7MKU_shd.mp4</a><br>第九课：《高级CPU设计》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET9H75_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET9H75_shd.mp4</a><br>第十课：《早期的编程方式》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET8NG4_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET8NG4_shd.mp4</a><br>第十一课：《编程语言发展史》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET9DSD_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET9DSD_shd.mp4</a><br>第十二课：《编程原理-语句和函数》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET9VSE_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGET9VSE_shd.mp4</a><br>第十三课：《算法入门》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETBL9C_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETBL9C_shd.mp4</a><br>第十四课：《数据结构》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETB6NO_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETB6NO_shd.mp4</a><br>第十五课：《阿兰·图灵》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETBRAI_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETBRAI_shd.mp4</a><br>第十六课：《软件工程》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETCCVF_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETCCVF_shd.mp4</a><br>第十七课：《集成电路&amp;摩尔定律》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETD05G_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETD05G_shd.mp4</a><br>第十八课：《操作系统》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETDILR_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETDILR_shd.mp4</a><br>第十九课：《内存&amp;储存介质》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETE71S_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETE71S_shd.mp4</a><br>第二十课：《文件系统》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETEN8R_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETEN8R_shd.mp4</a><br>第二十一课：《压缩》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETFAFE_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETFAFE_shd.mp4</a><br>第二十二课：《命令行界面》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETFTS2_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETFTS2_shd.mp4</a><br>第二十三课：《屏幕&amp;2D图形显示》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETGKVG_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETGKVG_shd.mp4</a><br>第二十四课：《冷战和消费主义》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/14/SDGR3AQ7P_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/14/SDGR3AQ7P_shd.mp4</a><br>第二十五课：《个人计算机革命》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETHR3V_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETHR3V_shd.mp4</a><br>第二十六课：《图形用户界面》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETIE0C_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETIE0C_shd.mp4</a><br>第二十七课：《3D图形》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETIVM7_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETIVM7_shd.mp4</a><br>第二十八课：《计算机网络》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETJK0A_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETJK0A_shd.mp4</a><br>第二十九课：《互联网》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETKCH4_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETKCH4_shd.mp4</a><br>第三十课：《万维网》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETKRTJ_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETKRTJ_shd.mp4</a><br>第三十一课：《计算机安全》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/11/SDGK7MKUF_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/11/SDGK7MKUF_shd.mp4</a><br>第三十二课：《黑客&amp;攻击》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETM5P2_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETM5P2_shd.mp4</a><br>第三十三课：《加密》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETNCVT_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETNCVT_shd.mp4</a><br>第三十四课：《机器学习&amp;人工智能》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/11/SDGK7P7N9_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/11/SDGK7P7N9_shd.mp4</a><br>第三十五课：《计算机视觉》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETQFKC_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETQFKC_shd.mp4</a><br>第三十六课：《自然语言处理》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETRIQV_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETRIQV_shd.mp4</a><br>第三十七课：《机器人》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETRP7C_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETRP7C_shd.mp4</a><br>第三十八课：《计算机心理学》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETSBRD_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETSBRD_shd.mp4</a><br>第三十九课：《教育科技》<br><a href="http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETT15E_shd.mp4">http://mov.bn.netease.com/open-movie/nos/mp4/2018/05/09/SDGETT15E_shd.mp4</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年自我提升计划</title>
      <link href="/2021/04/04/89dc/"/>
      <url>/2021/04/04/89dc/</url>
      
        <content type="html"><![CDATA[<h1 id="读书计划"><a href="#读书计划" class="headerlink" title="读书计划"></a>读书计划</h1><p>2020 年实在是太特殊了，这一年里读过的书其实也不多， 大多与专业相关，且好几本是本科时期读过再来重读的，这类书过于经典，每次读的收获都会有所不同。2021年更要好好的珍惜每分每秒，因为这对我来说是极其关键的一年！</p><h2 id="新书目录："><a href="#新书目录：" class="headerlink" title="新书目录："></a>新书目录：</h2><table><thead><tr><th align="center">编程类</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><strong>《Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14》</strong></td><td align="center"><img src="https://images-na.ssl-images-amazon.com/images/I/51qUGMia07L._SX379_BO1,204,203,200_.jpg" alt="vbdSMp" style="zoom:60%;"/></td></tr><tr><td align="center"><strong>《Optimized C++: Proven Techniques for Heightened Performance》</strong></td><td align="center"><img src="https://images-na.ssl-images-amazon.com/images/I/51v98JpO1aL._SX218_BO1,204,203,200_QL40_FMwebp_.jpg" alt="vbdSMp" style="zoom:100%;" /></td></tr><tr><td align="center"><strong>《Programming Rust: Fast, Safe Systems Development》</strong></td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/PiuFSb.png" alt="PiuFSb" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>工程类</strong></td><td align="center"></td></tr><tr><td align="center"><strong>《Software Engineering at Google: Lessons Learned from Programming Over Time》</strong><br>今年工程类的书籍读得非常少，一方面原因是因为比较具体的工程实践不在我的生活中，我不需要去花时间 来思考一些工程上的问题，相反而是需要花很多时间在科研文献上的阅读。唯一值得读的工程类的书籍是这本了！</td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/IOcS0M.png" alt="IOcS0M" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>架构设计</strong></td><td align="center"></td></tr><tr><td align="center"><strong>《Building Evolutionary Architectures: Support Constant Change》</strong></td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/sflBLq.png" alt="sflBLq" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>《Large-Scale C++ Volume I: Process and Architecture》</strong></td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/9zSqr5.png" alt="9zSqr5" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>图形学</strong></td><td align="center"></td></tr><tr><td align="center"><strong>《Fundamentals of Computer Graphics 》</strong>4th Edition</td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/YyDoGX.png" alt="YyDoGX" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>《OpenGL ES 3.0 Programming Guide》</strong></td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/4P3Jvg.png" alt="4P3Jvg" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>《Vulkan Programming Guide: The Official Guide to Learning Vulkan》</strong></td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/TtRp4B.png" alt="TtRp4B" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>社会财经</strong></td><td align="center"></td></tr><tr><td align="center"><strong>《一本书读懂财报》</strong><br>清华大学会计系系主任、喜马拉雅头部KOL肖星倾囊相授，接地气、易上手的财报分析技巧，豆瓣8.9分的经典之作全新修订.</td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/70CI3Y.png" alt="70CI3Y" style="zoom:50%;" /></td></tr><tr><td align="center"><strong>《预测：经济、周期与市场泡沫》</strong> <br>巴曙松、高善文、李迅雷、刘煜辉、彭文生、王庆重磅推荐。 洪灝首部力作。中国著名投资策略师、彭博评价为“精准预测了2015年泡沫的人”。</td><td align="center"><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Pfu3ii.png" alt="Pfu3ii" style="zoom:50%;" /></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 能力提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 细节知识点</title>
      <link href="/2021/01/14/dc7f/"/>
      <url>/2021/01/14/dc7f/</url>
      
        <content type="html"><![CDATA[<h1 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h1><p>4 ways to initialize variables：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>The us of {} was introdcuded by C++11。 It is called list initialization.</p><p>When used with variables of built-in type, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// error: narrowing conversion required</span></span><br><span class="line">int c(ld), d = ld; // ok: but value will be truncated</span><br></pre></td></tr></table></figure><h1 id="Default-Initializaiton"><a href="#Default-Initializaiton" class="headerlink" title="Default Initializaiton"></a>Default Initializaiton</h1><p>Variables defined outside any function body are initialized to zero. With one exception, which we cover in § 6.1.1 (p. 205), variables of built-in type defined inside a function are uninitialized.</p><p>Most classes let us define objects without explicit initializers. Such classes supply an appropriate default value for us. For example, as we’ve just seen, the library string class says that if we do not supply an initializer, then the resulting string is the empty string：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> empty; <span class="comment">// empty implicitly initialized to the empty string</span></span><br><span class="line">Sales_item item; <span class="comment">// default-initialized Sales_item object</span></span><br></pre></td></tr></table></figure><blockquote><p>Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.</p></blockquote><h1 id="Variable-Declarations-and-Definitiions"><a href="#Variable-Declarations-and-Definitiions" class="headerlink" title="Variable Declarations and Definitiions"></a>Variable Declarations and Definitiions</h1><blockquote><p>We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.</p></blockquote><p>To support separate compilation, C++ distinguishes between declarations anddefinitions. A declaration makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. A definition creates the associated entity.</p><p>A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value. To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="keyword">int</span> j; <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure><p>Any declaration that includes an explicit initializer is a definition. We can provide an initializer on a variable defined as extern, but doing so overrides the extern. An extern that has an initializer is a definition:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.1416</span>; <span class="comment">// definitio</span></span><br></pre></td></tr></table></figure><blockquote><p>It is an error to provide an initializer on an extern inside a function. <strong>Variables must be defined exactly once but can be declared many times.</strong></p><p><strong>Key Concept: Static Typing</strong></p><p>C++ is a statically typed language, which means that types are checked atcompile time. The process by which types are checked is referred to as type checking.</p></blockquote><h1 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h1><p>Identifiers（标识符） in C++ can be composed of letters, digits, and the underscore character. The language imposes no limit on name length. Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are distinct:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defines four different int variables</span></span><br><span class="line"><span class="keyword">int</span> somename, someName, SomeName, SOMENAME;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/36Tkab.png" alt="36Tkab"></p><h1 id="Scope-of-a-Name"><a href="#Scope-of-a-Name" class="headerlink" title="Scope of a Name"></a>Scope of a Name</h1><p>A scope is a part of the program in which a name has a particular meaning.</p><h1 id="const-Qualifier"><a href="#const-Qualifier" class="headerlink" title="const Qualifier"></a>const Qualifier</h1><p><strong>By Default, const Objects Are Local to a File</strong></p><p>To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = fcn();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize; <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure><p>In this program, file_1.cc defines and initializes bufSize. Because this declaration includes an initializer, it is (as usual) a definition. However, because bufSize is const, we must specify extern in order for bufSize to be used in other files.</p><blockquote><p>To share a const object among multiple files, you must define the variable as extern.</p></blockquote><h2 id="References-to-const"><a href="#References-to-const" class="headerlink" title="References to const"></a>References to const</h2><p>As with any other object, we can bind a reference to an object of a const type. To do so we use a reference to const, which is a reference that refers to a const type. Unlike an ordinary reference, a reference to const cannot be used to change the object to which the reference is bound:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">// ok: both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>; <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">// error: non const reference to a const object</span></span><br></pre></td></tr></table></figure><blockquote><p>Terminology: const Reference is a Reference to const</p><p>“C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.” This abbreviation makes sense—if you remember that it is an abbreviation.<br>Technically speaking, there are no const references. A reference is not an object, so we cannot make a reference itself const. Indeed, because there is no way to make a reference refer to a different object, in some sense all references are const. Whether a reference refers to a const or nonconst type affects what we can do with that reference, not whether we can alter the binding of the reference itself.”</p></blockquote><p><strong>A Reference to const May Refer to an Object That Is Not const</strong></p><p>It is important to realize that a reference to const restricts only what we can do through that reference. Binding a reference to const to an object says nothing about whether the underlying object itself is const. Because the underlying object might be nonconst, it might be changed by other means:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i; <span class="comment">// r1 bound to i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i; <span class="comment">// r2 also bound to i; but cannot be used to change i</span></span><br><span class="line">r1 = <span class="number">0</span>; <span class="comment">// r1 is not const; i is now 0</span></span><br><span class="line">r2 = <span class="number">0</span>; <span class="comment">// error: r2 is a reference to const</span></span><br></pre></td></tr></table></figure><h2 id="Pointers-and-const"><a href="#Pointers-and-const" class="headerlink" title="Pointers and const"></a><em>Pointers and</em> const</h2><p>Pointers can point to either const or nonconst types. A <em>pointer to</em> const (§ 2.4.1, p. 61) may not be used to change the object to which the pointer points. We may store the address of a const object only in a pointer to const:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// pi is const; its value may not be changed</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi; <span class="comment">// error: ptr is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">// ok: cptr may point to a double that is const</span></span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">// error: cannot assign to *cptr</span></span><br></pre></td></tr></table></figure><h3 id="const-Pointers"><a href="#const-Pointers" class="headerlink" title="const Pointers"></a>const <em>Pointers</em></h3><p>Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. Like any other const object, a const pointer must be initialized, and once initialized, its value (i.e., the address that it holds) may not be changed. We indicate that the pointer is const by putting the const after the *. This placement indicates that it is the pointer, not the pointed-to type, that is const:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip is a const pointer to a const</span></span><br><span class="line">object</span><br></pre></td></tr></table></figure><p>The fact that a pointer is itself const says nothing about whether we can use the pointer to change the underlying object. Whether we can change that object depends entirely on the type to which the pointer points. For example, pip is a const pointer to const. Neither the value of the object addressed by pip nor the address stored in pip can be changed. On the other hand, curErr addresses a plain, nonconst int. We can use curErr to change the value of errNumb:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*pip = <span class="number">2.72</span>; <span class="comment">// error: pip is a pointer to const</span></span><br><span class="line"><span class="comment">// if the object to which curErr points (i.e., errNumb) is nonzero</span></span><br><span class="line"><span class="keyword">if</span> (*curErr) &#123;</span><br><span class="line">errorHandler();</span><br><span class="line">*curErr = <span class="number">0</span>; <span class="comment">// ok: reset the value of the object to which curErr is bound</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/image-20210114121215974.png" alt="image-20210114121215974"></p><h2 id="Pointers-const-and-Type-Aliases"><a href="#Pointers-const-and-Type-Aliases" class="headerlink" title="Pointers, const, and Type Aliases"></a><em>Pointers,</em> const<em>, and Type Aliases</em></h2><p>Declarations that use type aliases that represent compound types and const can yield surprising results. For example, the following declarations use the type pstring, which is an alias for the the type char*:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr is a constant pointer to char</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">// ps is a pointer to a constant pointer to char</span></span><br></pre></td></tr></table></figure><p>The base type in these declarations is const pstring. As usual, a const that appears in the base type modifies the given type. The type of pstring is “pointer to char.” So, const pstring is a constant pointer to char—not a pointer to const char. It can be tempting, albeit incorrect, to interpret a declaration that uses a type alias by conceptually replacing the alias with its corresponding type:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>; <span class="comment">// wrong interpretation of const pstring cstr</span></span><br></pre></td></tr></table></figure><p><em>However, this interpretation is wrong. When we use</em> <em>pstring</em> <em>in a declaration, the</em> <em>base type of the declaration is a pointer type. When we rewrite the declaration using <strong>char*</strong>, the base type is</em> <em>char</em> <em>and the</em> <strong>** is part of the declarator. In this case,</strong>const  char<strong>* <em>is the base type. This rewrite declares</em> <em>cstr</em> <em>as a pointer to</em> <em>const char</em> *rather</strong> than as a <strong>const</strong> pointer to <strong>char</strong>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setup OpenGL Development with Clion on MacOS</title>
      <link href="/2021/01/12/2236/"/>
      <url>/2021/01/12/2236/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>伴随图形学课程进入中后期，我们也不能光讲理论，不做实践。在2021年的岁月里，让我们“撸起袖子加油干”！</p><p>今天，我们从比较容易上手的OpenGL开始。</p><p><strong>这门课程的前置基础：</strong></p><ol><li>杂货铺里Danny之前写的图形学入门课程</li><li>C/C++编程语言</li></ol><p><strong>开发环境：</strong></p><ul><li>Mac OS， Clion， XCode</li></ul><p>或者</p><ul><li>Windows，Clion，Visual Studio 2016。</li></ul><p>为了统一大家的开发环境，这门课里采用Clion。本人的工作环境是Macbook，所以接下来的内容主要会围绕Macbook+Clion环境配置OpenGL来讲解。</p><h1 id="配置C-C-开发环境"><a href="#配置C-C-开发环境" class="headerlink" title="配置C/C++开发环境"></a>配置C/C++开发环境</h1><h2 id="第一步：Install-Brew"><a href="#第一步：Install-Brew" class="headerlink" title="第一步：Install Brew"></a>第一步：Install Brew</h2><p>Brew 是Macbook上用来安装和管理各种工具的的command工具。</p><p>安装方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="第二步：确认自己的MacOS上安装了gcc："><a href="#第二步：确认自己的MacOS上安装了gcc：" class="headerlink" title="第二步：确认自己的MacOS上安装了gcc："></a>第二步：确认自己的MacOS上安装了gcc：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ ❯❯❯ gcc --version                                                                        prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/4.2.1Apple clang version 12.0.0 (clang-1200.0.32.28)Target: x86_64-apple-darwin20.1.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin</span><br></pre></td></tr></table></figure><p>如果没有安装的话会上面的指令会自动触发 <code>XCode</code> 下载并安装，根据提示安装完成之后再使用上面的指令检查一遍即可。</p><h3 id="第三步-下载Clion并安装"><a href="#第三步-下载Clion并安装" class="headerlink" title="第三步: 下载Clion并安装"></a>第三步: 下载Clion并安装</h3><p>Clion的下载路径地址：<a href="https://www.jetbrains.com/clion/download/#section=mac">https://www.jetbrains.com/clion/download/#section=mac</a></p><p>Clion并不是免费的，新下载的用户有30天试用。如果大家没有银子购买，可以参考网上一个大神提供的定期重新激活插件：<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset.html。">https://zhile.io/2020/11/18/jetbrains-eval-reset.html。</a></p><p>安装完 <code>CLion</code> 之后，可以在 <code>Settings</code> 中检查 <code>Toolchain</code> 是否正确识别，如下：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/rCLZXe.png" alt="rCLZXe"></p><p>通常来说只需要安装好 <code>gcc</code> 即可，因为 <code>cmake</code> 会在 <code>CLion</code> 中自带，而 <code>make</code> 会在 <code>MacOS</code> 系统中提供。</p><p>这里大家如果没听说cmake是什么，简单说一下，cmake是用来管理C/C++程序的依赖和构建工具，他可以生成makefile，并轻松的管理项目中各级文件夹下的makefile的调度关系。</p><p>好啦，上边这些都是在MacOS上C/C++开发环境的基本配置，哪怕你不做OpenGL编程，这些配置也是完成c和c++语言编程的的最基本配置。 </p><p>注意：在Macbook上，你可以用xcode来做c/c++ 甚至是OpenGL的编程，在windows操作系统上，Visual Studio用的比较多。这里，我们统一采用Clion这种可以跨平台的IDE。</p><p>接下来是重点了，我们开始配置有关OpenGL的开发环境。</p><h1 id="配置有关OpenGL的开发环境"><a href="#配置有关OpenGL的开发环境" class="headerlink" title="配置有关OpenGL的开发环境"></a>配置有关OpenGL的开发环境</h1><p>OpenGL的开发主要依赖两个庫：</p><ul><li><code>GLFW</code>: 提供跨平台的 <code>OpenGL</code> 上下文初始化与窗口创建等功能</li><li><code>GLAD</code>: 提供跨平台的 <code>OpenGL</code> 函数指针加载等功能</li></ul><p>两者的下载顺序没有前后，我们一个一个来吧。</p><h2 id="下载并配置GLFW"><a href="#下载并配置GLFW" class="headerlink" title="下载并配置GLFW"></a>下载并配置GLFW</h2><p>地址在这：<a href="https://www.glfw.org/download.html，`GLFW`">https://www.glfw.org/download.html，`GLFW`</a> 在不同的平台上都有预编译好的包，我们可以根据我们的系统下载 <code>MacOS</code> 版本的预编译包：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/XIEQIW.png" alt="XIEQIW"></p><p>但是，这里请注意，我建议用homebrew来下载和管理GLFW。因为homebrew作为统一的工具和庫的管理工具，可以方便以后对庫的删除和升级。这里用brew安装GLFW的命令如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>glfw3</span><br></pre></td></tr></table></figure><p>brew会默认把所有的文件安装在<strong>/usr/local/Cellar/</strong>的一个文件夹里。例如glfw就被安装在如下的一个目录里<strong>/usr/local/Cellar/glfw</strong></p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/UZFz8P.png" alt="UZFz8P"></p><p>不仅如此，brew 还会在/usr/local/include的目录里建立一个目录软连接，这个soft link 指向了 /usr/local/Cellar/glfw/3.3.2/include 这个目录。这样子，GLFW的头文件就被包含在IDE默认搜索的路径下了。</p><h2 id="接下来是-GLAD-的下载与配置"><a href="#接下来是-GLAD-的下载与配置" class="headerlink" title="接下来是 GLAD 的下载与配置"></a>接下来是 <code>GLAD</code> 的下载与配置</h2><p><code>GLAD</code> 作为一个加载器，根据不同的系统与 <code>OpenGL</code>，库本身都有所变化，需要灵活配置，官方提供了一个在线配置与生成库的网站：<a href="https://glad.dav1d.de/，我们根据我们的需要进行选择：">https://glad.dav1d.de/，我们根据我们的需要进行选择：</a></p><p>这里有两个配置要注意：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/DgI4P9.png" alt="DgI4P9"></p><ul><li>API我们选择3.3. 其实OpenGL到今天已经发展到4.6版本了，这里选择用3.3，是因为3.3版的OpenGL是跟它之前的版本的一个分水岭，之后其他的版本都是在3.3版本上的一个升级。</li><li>Profile选择Core。至于为什么选择Core，这里引用LearnOpenGL CN的原作者给出的解释：</li></ul><blockquote><p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p></blockquote><p>那点击Generate 并下载为glad.zip。</p><p>解压下载的glad.zip会得到如下的文件夹结构：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/41XFoS.png" alt="41XFoS"></p><p>我们复制glad文件夹，并把它粘贴到/usr/local/include这个目录，glad被复制到新的目录.</p><p>好的，到这里，让我们来记录下GLFW和GLAD的位置。</p><table><thead><tr><th>GLFW 被放置</th><th><strong>/usr/local/Cellar/glfw/3.3.2</strong></th></tr></thead><tbody><tr><td>GLAD 被放置</td><td><strong>/usr/local/include/glad</strong></td></tr></tbody></table><p>接下来我们来配置两个环境变量：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLFW_HOME</span>=<span class="string">&quot;/usr/local/Cellar/glfw/3.3.2&quot;</span>export <span class="attribute">GLAD_HOME</span>=<span class="string">&quot;/usr/local/include/glad&quot;</span></span><br></pre></td></tr></table></figure><p>推荐将这两条命令写入你的shell profile 里， 如果你用的bash，可以写入 <code>~/.bash_profile</code>，因为我用的是zsh，我会写入~/.zprofile这个文件里。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~<span class="string">/.zprofile</span></span><br></pre></td></tr></table></figure><p>把上边的两行放到shell profile 的最末端，然后激活shell profile。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/u/</span>l<span class="regexp">/i/g</span>lad ❯❯❯ <span class="keyword">source</span> ~/.zprofile</span><br></pre></td></tr></table></figure><h1 id="创建与配置项目"><a href="#创建与配置项目" class="headerlink" title="创建与配置项目"></a>创建与配置项目</h1><p>首先使用 <code>CLion</code> 创建一个 <code>C/C++</code> 工程，</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/p4ISPH.png" alt="p4ISPH"></p><p>创建完成之后应该可以看到项目根目录下有一个 <code>CMakeLists.txt</code> 文件</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/0Ov6XG.png" alt="0Ov6XG"></p><p>我们现在项目里创建的lib 文件夹，然后把<code>glad.c</code> 拖进去。<code>glad.c</code>是需要参与编译的。</p><p>这时候我们可以按照如下配置修改：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake的版本号</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="comment"># project 的名字</span></span><br><span class="line"><span class="keyword">project</span>(OpenglDemo)</span><br><span class="line"><span class="comment"># C++ version</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境变量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> ENV&#123;GLFW_HOME&#125;)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;found no env named GLFW_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> ENV&#123;GLAD_HOME&#125;)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;found no env named GLAD_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存环境变量</span></span><br><span class="line"><span class="keyword">set</span>(GLFW_HOME $ENV&#123;GLFW_HOME&#125;)</span><br><span class="line"><span class="keyword">set</span>(GLAD_HOME $ENV&#123;GLAD_HOME&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置头文件目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;GLFW_HOME&#125;/include&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;GLAD_HOME&#125;/include&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 GLFW3 预编译库</span></span><br><span class="line"><span class="keyword">add_library</span>(glfw SHARED IMPORTED)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(glfw PROPERTIES IMPORTED_LOCATION <span class="string">&quot;$&#123;GLFW_HOME&#125;/lib/libglfw.3.dylib&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(OpenglDemo main.cpp <span class="string">&quot;lib/glad.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 GLFW GLAD OpenGL</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(OpenglDemo glfw <span class="string">&quot;-framework OpenGL&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h1><p>完成项目配置后，改写 <code>main.cpp</code> 来写一个测试小程序吧，这里源代码用的是learnOpenGL 网站的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">                                   <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">                                   <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">                                   <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                                   <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">                                   <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader program</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="comment">// vertex shader</span></span><br><span class="line">    <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fragment shader</span></span><br><span class="line">    <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// link shaders</span></span><br><span class="line">    <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// check for linking errors</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">            <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left</span></span><br><span class="line">            <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right</span></span><br><span class="line">            <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line">    <span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// uncomment this call to draw in wireframe polygons.</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw our first triangle</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO); <span class="comment">// seeing as we only have a single VAO there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organized</span></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// glBindVertexArray(0); // no need to unbind it every time</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and</span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，如果你也和我一样一切都配置成功了：当你在clion上运行OpenglDemo project的时候，你应该可以看到一个三角形被成功的绘制出来了。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/qiyvUd.png" alt="qiyvUd"></p><p>项目代码：<a href="https://github.com/geekdanny/LearnOpenGL/tree/main/OpenglDemo">https://github.com/geekdanny/LearnOpenGL/tree/main/OpenglDemo</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setup Vulkan Development Environment with Clion on MacOS</title>
      <link href="/2021/01/12/2270/"/>
      <url>/2021/01/12/2270/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习图形学编程的时候，其实在MacOS的编程环境默认都是用Xcode，Windows又经常用Visual Studio。但是因为我经常要在Windows 和 MacOS上切换编程，偶尔还得跑到Ubuntu上去，也不想反复的切换不同的IDE，所以我选择了Clion。Clion 好的好处就是跨平台的使用。</p><p>今天花了几个小时在MacOS上配置了Clion+Vulkan的开发环境，对于后期学习Vulkan做铺垫。 了解Clion的人都知道，Clion的C/C++编程采用的是cmake 做工程构建，这样子又可以逼迫我使用一个跨平台的构架方案，对于底层的工程构建可以了如指掌，也可使促我更进一步的了解和学习cmake。</p><h1 id="我的工作环境"><a href="#我的工作环境" class="headerlink" title="我的工作环境"></a>我的工作环境</h1><h3 id="MacOS-Big-Sur"><a href="#MacOS-Big-Sur" class="headerlink" title="MacOS: Big Sur"></a>MacOS: Big Sur</h3><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/ACE1oA.png" alt="ACE1oA"></p><h3 id="gcc-verson"><a href="#gcc-verson" class="headerlink" title="gcc verson"></a>gcc verson</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/C/V/shaders ❯❯❯ gcc --version</span><br><span class="line">Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/4.2.1</span><br><span class="line">Apple clang version 12.0.0 (clang-1200.0.32.27)</span><br><span class="line">Target: x86_64-apple-darwin20.2.0</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</span><br></pre></td></tr></table></figure><h1 id="配置Vulkan所需要的Lib"><a href="#配置Vulkan所需要的Lib" class="headerlink" title="配置Vulkan所需要的Lib"></a>配置Vulkan所需要的Lib</h1><p>Vulkan的MacOS的配置主要参考Vulkan Tutorial的<a href="https://vulkan-tutorial.com/Development_environment">Development Environment</a>。但是很对MacOS的文章只提供了XCode的配置，但是其实对于文件包的依赖都是一样的。主要是需要三样东西: Vulkan SDK, GLFW，GLM.</p><p>我们分别看一下如何安装这三样东西。</p><h2 id="安装Vulkan-SDK"><a href="#安装Vulkan-SDK" class="headerlink" title="安装Vulkan SDK"></a>安装Vulkan SDK</h2><p>Vulkan SDK可以直接从<a href="https://vulkan.lunarg.com/sdk/home下载。其具体的安装过程可参考[Getting">https://vulkan.lunarg.com/sdk/home下载。其具体的安装过程可参考[Getting</a> Started with the macOS Vulkan SDK](<a href="https://vulkan.lunarg.com/doc/sdk/latest/mac/getting_started.html)。在具体安装的环节，我采用了**Install">https://vulkan.lunarg.com/doc/sdk/latest/mac/getting_started.html)。在具体安装的环节，我采用了**Install</a> the SDK - Alternate method using system paths**这一步。即通过运行sdk自带的python安装脚本来进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install_vulkan.py</span><br></pre></td></tr></table></figure><p>脚本的运行结果如下，主要是把vulkan sdk 的庫和头文件分别安装到了系统目录 /usr/local下。</p><p><em>/usr/local/lib is one of the directories that linker searches for required libraries. 用户安装的lib一般都会放在/usr/local 这个folder内。 Clion搜索庫的依据主要来自于cmake 所定义的include_directories所指定的路径。</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-opt to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/vkvia to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPVRemapperTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPIRV-Tools to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake<span class="regexp">/vulkan/</span>SPIRV-Tools</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-link to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-cfg to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-c-shared.0.44.0.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-val to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/i</span>nclude<span class="regexp">/vulkan to /u</span>sr<span class="regexp">/local/i</span>nclude/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPIRVTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPIRV.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/MoltenVKShaderConverter to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/g</span>lslangTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>share<span class="regexp">/vulkan to /u</span>sr<span class="regexp">/local/</span>share/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libshaderc_util.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPIRV-Tools.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/vulkaninfo to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-as to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPIRV-Tools-opt.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPIRVTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/Applications/</span>vkconfig.app to <span class="regexp">/Applications/</span>vkconfig.app</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/g</span>lslangValidatorTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>OGLCompilerTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-c-shared.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-cpp.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/glslc to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>HLSLTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/Applications/</span>vkcubepp.app to <span class="regexp">/Applications/</span>vkcubepp.app</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libGenericCodeGen.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-c-shared.0.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-glsl.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-msl.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-remap to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-dis to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/i</span>nclude<span class="regexp">/spirv_cross to /u</span>sr<span class="regexp">/local/i</span>nclude/spirv_cross</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPIRV-Tools-link to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake<span class="regexp">/vulkan/</span>SPIRV-Tools-link</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPVRemapperTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/dxc-3.7 to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPIRV-Tools-opt to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake<span class="regexp">/vulkan/</span>SPIRV-Tools-opt</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>OGLCompilerTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/glslangValidator to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-lesspipe.sh to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/Applications/</span>vkcube.app to <span class="regexp">/Applications/</span>vkcube.app</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>HLSLTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>spirv-remapTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/g</span>lslangValidatorTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPIRV-Tools-link.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-c.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-reflect to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/Applications/</span>vulkaninfo.app to <span class="regexp">/Applications/</span>vulkaninfo.app</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-hlsl.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/i</span>nclude<span class="regexp">/shaderc to /u</span>sr<span class="regexp">/local/i</span>nclude/shaderc</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPIRV-Tools-reduce.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libshaderc_combined.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-util.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libvulkan.1.2.162.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libOGLCompiler.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libshaderc_shared.1.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPIRV-Tools-shared.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libvulkan.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libOSDependent.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libshaderc.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/i</span>nclude<span class="regexp">/spirv-tools to /u</span>sr<span class="regexp">/local/i</span>nclude/spirv-tools</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>SPIRV-Tools-reduce to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake<span class="regexp">/vulkan/</span>SPIRV-Tools-reduce</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libglslang.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libdxcompiler.3.7.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libMoltenVK.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-reflect.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libHLSL.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libdxcompiler.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-cross to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libVkLayer_khronos_validation.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/i</span>nclude<span class="regexp">/glslang to /u</span>sr<span class="regexp">/local/i</span>nclude/glslang</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/spirv-reduce to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>OSDependentTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>bin<span class="regexp">/dxc to /u</span>sr<span class="regexp">/local/</span>bin</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libspirv-cross-core.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libSPVRemapper.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libVkLayer_api_dump.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>spirv-remapTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/</span>OSDependentTargets-release.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libvulkan.1.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/cmake/g</span>lslangTargets.cmake to <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>cmake/vulkan</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libshaderc_shared.dylib to /u</span>sr<span class="regexp">/local/</span>lib</span><br><span class="line">Copying <span class="regexp">/Volumes/</span>vulkansdk-macos-<span class="number">1.2</span>.<span class="number">162.0</span><span class="regexp">/macOS/</span>lib<span class="regexp">/libMachineIndependent.a to /u</span>sr<span class="regexp">/local/</span>lib</span><br></pre></td></tr></table></figure><h2 id="安装GLFW"><a href="#安装GLFW" class="headerlink" title="安装GLFW"></a>安装GLFW</h2><p>GLFW是用来创建window的，它支持不同的操作系统的。无论是OpenGL还是Vulkan，它们的只负责图形渲染到内存中用于显示到屏幕的桌面上，至于最后每个操作系统的桌面的创建，GL跟Vulkan都不负责。这就是GLFW的工作了。在苹果上，glfw可以通过brew来安装。我的mac已经安装好了brew，所以就直接通过brew来安装glfw就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install glfw</span><br></pre></td></tr></table></figure><h2 id="安装GLM"><a href="#安装GLM" class="headerlink" title="安装GLM"></a>安装GLM</h2><p>Vulkan也不包含线性代数的数学庫。所以我们之后做图形变化的时候，需要用到GLM。他也可以通过brew 来安装。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>glm</span><br></pre></td></tr></table></figure><p>安装以上所有需要的libs之后，我们可以设定一个shell 的profile 里设定自己的环境变量。这些设定的环境变量将用来为我后之后在clion IDE里使用cmake配置文件时指明需要搜索的庫的路径。因为我用的是zsh，所以，我在~/.zprofile 里添加了glfw和glm的lib的路径。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLFW_HOME</span>=<span class="string">&quot;/usr/local/Cellar/glfw/3.3.2&quot;</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GLM_HOME</span>=<span class="string">&quot;/usr/local/include/glm&quot;</span></span><br></pre></td></tr></table></figure><p>备注：brew 会把所有的安装都在一个叫Cellar的目录下，然后在/usr/local 下创建soft link连接到这些在Cellar下的目录。</p><p>然后我们重新source一下我.zprofile.</p><p>当一些都配置好了后，可以调用vksdk的命令<code>vkvia</code>来查询vulkan是否成功安装了。</p><p>也可以run一下vulkan sdk的 cube app来看一下。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/FtU9D7.png" alt="FtU9D7"></p><h1 id="创建Clion-项目"><a href="#创建Clion-项目" class="headerlink" title="创建Clion 项目"></a>创建Clion 项目</h1><p>让我们的创建一个VulkanDemo 项目。项目创建后非常简单，只有一个main.cpp 的helloworld代码。</p><p>这里我们来画一个三角形，所有，让我们配置cmake file 保证所需要的头文件和庫都被正确的加载了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(VulkanDemo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境变量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> ENV&#123;GLFW_HOME&#125;)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;found no env named GLFW_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> ENV&#123;GLM_HOME&#125;)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;found no env named GLM_HOME&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存环境变量</span></span><br><span class="line"><span class="keyword">set</span>(GLFW_HOME $ENV&#123;GLFW_HOME&#125;)</span><br><span class="line"><span class="keyword">set</span>(GLM_HOME $ENV&#123;GLM_HOME&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(VulkanDemo main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 GLFW3 预编译库</span></span><br><span class="line"><span class="keyword">add_library</span>(glfw SHARED IMPORTED)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(glfw PROPERTIES IMPORTED_LOCATION <span class="string">&quot;$&#123;GLFW_HOME&#125;/lib/libglfw.3.dylib&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GLM</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;GLM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Vulkan</span></span><br><span class="line"><span class="keyword">find_package</span>(Vulkan REQUIRED FATAL_ERROR)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> glfw Vulkan::Vulkan)</span><br><span class="line"><span class="comment">#include_directories($&#123;Vulkan_INCLUDE_DIRS&#125;)</span></span><br><span class="line"><span class="comment">#target_include_directories($&#123;PROJECT_NAME&#125; PUBLIC $&#123;Vulkan_INCLUDE_DIRS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy the shader files to the cmake-build-debug folder</span></span><br><span class="line"><span class="keyword">file</span>(COPY shaders DESTINATION <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cmake 配置好后我们开始画我么你的三角形。这篇文章直接用了Vulkan Tutorial的代码。把<a href="https://vulkan-tutorial.com/code/16_swap_chain_recreation.cpp">代码</a> 复制到<code>main.cpp</code> 里。因为画三角形我们这里要用到两个shaders。shader的代码来自<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules">这一章节</a>。所以我们需要添加两个shader文件，和一个compile 脚本帮我们生成SPIR-V文件。</p><p>大家可能留意到，cmake 的配置文件最后一行我用到了<code>file(COPY shaders DESTINATION $&#123;CMAKE_CURRENT_BINARY_DIR&#125;)</code>，主要因为在main的代码里调用了openfile 需要打开我们的shader文件。但是Clion run 项目的二进制文件的时候，它假设资源文件是放在<code>cmake-build-debug</code>这个文件夹里。所以我们必须把shader文件夹复制到<code>cmake-build-debug</code>里。</p><p>来看一下我么你的项目的整体的样子：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/lk33hI.png" alt="lk33hI"></p><p>好了，最后，我们在clion里运行我们的VulkanDemo程序吧。一个三角形孕育而生！</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/dUqc07.png" alt="dUqc07"></p><p>源代码：<a href="https://github.com/geekdanny/LearnVulkan">https://github.com/geekdanny/LearnVulkan</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan 导读3: 分配Image资源和创建Swapchain</title>
      <link href="/2021/01/11/b21/"/>
      <url>/2021/01/11/b21/</url>
      
        <content type="html"><![CDATA[<p>导读2学习了CB和内存管理。这一节对《Learning Vulkan》的第6章的导读。特介绍了两个主要概念，一个是image resources，另一个是swapchain 和 depth image。</p><p>主要内容如下：</p><ul><li>Getting started with image resources</li><li>Understanding an image resource</li><li>Memory allocation and binding an image resource</li><li>Introducing swapchains</li><li>Creating a depth image</li><li>Summarizing the application flow</li></ul><h1 id="Getting-started-with-image-resources"><a href="#Getting-started-with-image-resources" class="headerlink" title="Getting started with image resources"></a>Getting started with image resources</h1><p>Vulkan 的资源主要分成两种: 1. image; 2 buffer. 书中的第六章主要是讲解image resources。第七章开始讲解了buffer resources。 image resoure 主要是被用来创建swapchain。</p><p>Vulkan的images 主要为contiguous texture data in 1D/2D/3D form。 这些images主要被用作为attachment或texture。</p><p><strong>名词解释</strong></p><ul><li>Attachment: The image is attached to the pipeline for the framebuffer’s color or depth attachment and can also be used as an auxiliary surface for multipass processing purposes。附件为一种image， 可以被理解为挂载在pipeline上的framebuffer上的color 或 depth 附件。（原文这句话的理解感觉很奇怪。）</li><li>Texture: The image is used as a descriptor interface and shared at the shader stage (fragment shader) in the form of samplers。纹理是另外一种image，它被用作descriptor interface 并以samplers的形式在fragment shader stage被共用。 （这句话感觉也很奇怪）</li></ul><p>然后书中马上跟上了一点重点诠释：</p><blockquote><p>”If you come from an OpenGL background, note that the use of images in Vulkan is entirely different from its counterpart in OpenGL. In Vulkan, the image is created by specifying a number of bitwise fields indicating the kind of image usage, such as color attachment, depth/stencil attachment, a sampled image in a shader, image load/store, and so on. In addition, you need to specify the tiling information (linear or optimal) for the image. This specifies the tiling or swizzling layout for the image data in memory.” Page 148 《Learning Vulkan》</p></blockquote><p>主要是拿Vulkan跟OpenGL对比起images的使用。 支出Vulkan的image是通过specify 多个用来表示image 用途的 的 bitwise fields  来创建出来的，例如 color attachment， depth、stencil attachment。。。等。 并且，还需要image 的specify tiling info。这里要回顾一下，这三种image，在OpenGL里是怎么创建出来的。</p><p>Texture的标注主要通过3样东西：images，images layouts，和image views：</p><p><strong>名词解释</strong></p><p><strong>Image</strong>: An image represents the <em>texture object</em> in Vulkan. This contains metadata that is utilized for computing memory requirements. The gathered memory requirements are helpful during memory allocation. An image indicates other, and numerous types of information, such as the format, size, and type (sparse map, cube map, and so on). A single image may contain sub-resources, such as multiple images, based on the mipmap level or array layers. Each image or image sub-resource is specified with an image layout.</p><p><strong>Image layout</strong>: An image layout is an implementation-specific way to store image texture information in a grid coordinate representation in the image memory. The image stored in image memory is very implementation-specific; each image has a specific usage, for example, color attachment, a sampled image in a shader, image load/store, or sparse textures for large images. For these special purposes, the implementation provides image layouts that are specialized in image memory usage to offer optimal performance.</p><p><strong>Image view:</strong> Images cannot be used directly for reading and writing purposes by API calls or pipeline shaders; instead, image views are used. It not only acts like an interface to the image object, but it also provides the metadata that is used to represent a continuous range of image sub-resources.</p><h2 id="Image-creation-overview"><a href="#Image-creation-overview" class="headerlink" title="Image creation overview"></a>Image creation overview</h2><p>Image 的创建可以简单的用一张图来表示：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/image-20210111155306450.png" alt="image-20210111155306450"></p><h2 id="Memory-allocation-and-binding-image-resources"><a href="#Memory-allocation-and-binding-image-resources" class="headerlink" title="Memory allocation and binding image resources"></a>Memory allocation and binding image resources</h2><p>关于Image Create的过程是有一个重要的概念需要理解的。那就是当image resource object被创建的时候，它只是逻辑allocation。这个image本身还没有跟物理内存相关联。真正的物理内存关联是通过上图中2，3，4，5这几步来完成的。</p><h1 id="Introducing-swapchains"><a href="#Introducing-swapchains" class="headerlink" title="Introducing swapchains"></a>Introducing swapchains</h1><p><strong>名词解释</strong></p><p><strong>Swapchains</strong> are a mechanism by which the rendering of the drawing primitive is shown on a platform-specific presentation window/surface.</p><p>一个swapchain可能包括一个或多个drawing images。 这些drawing images也被称作为 color images。一个color image 其实就是内存中一个特殊layout中含有pixel info的数组。draw images 数量取决于其具体的实现。当两个images被用到，，它就叫做double buffering；三个被用到，则叫做triple buffering。</p><p>多个image的工作原理在导读1里做了解释，主要目的就是当一个image被GPU用作background buffer完成了draw的处理后，它就被换到presentation window去显示，此时，GPU就可以马上把下一个image作为backgournd buffer处理draw的结果并把结果输出到这个image上。使用多个image就大大增加的GPU的利用率，提高了的GPU的frame rate，减少了GPU的空闲时间。</p><p>其image swapping的频率书中介绍跟显示器的VBI的工作关系。原文写的比较清楚：</p><blockquote><p>The swapping or flipping of the drawing image is dependent upon the presentation mode; this may be updated during the Vertical Blanking Interval (VBI) or as soon as the drawing is made available. This means that when the monitor is refreshed, the background image is swapped with the front image displaying the new image. A swapchain is available in the form of an API extension, which needs to be enabled with <code>VK_KHR_SWAPCHAIN_EXTENSION_NAME.</code> Refer to the <em>Querying swapchain extensions</em> section for more information. P162 《Learning Vulkan》</p></blockquote><p>Swapchain的实现流程可以用一张简单图来表示：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/image-20210111162522093.png" alt="image-20210111162522093"></p><p>书中之后给出了swapchain的实现细节。这里就再赘述。</p><h1 id="Creating-a-depth-image"><a href="#Creating-a-depth-image" class="headerlink" title="Creating a depth image"></a>Creating a depth image</h1><p>前面提到了color image，并介绍了swapchain的工作原理和实现方式。接下来介绍的是depth image。depth image主要是做深度测试用的。在深度测试这个环节，每一个fragment的depth会被存储在一个特定的buffer里，这个buffer就叫做depth image。不同于color image被用作存储颜色信息，depth image从camera view的角度存储了图元所对应的像素的深度信息。depth image 的dimension通常跟color image一样大小。 一般来说，depth image 存储的深度信息都是16，24或者32位 float values。</p><p>书中在这里介绍一种image 储存方法：tiling。一般来说， Image data 一种把对应2D 类型image 数据 以线性方式存储在内存中。以线性排列的方式， texels（纹理像素）会按照连续的 row-by-row的方式布局在内存中。例如下图：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/image-20210111202016169.png" alt="image-20210111202016169"></p><p>Pitch 代表你的是image 的width。一个texel的偏差值（offset）可以通过所在row和column的位置搭配pitch来计算出来，就像上图那样。</p><p>但是linear布局是有缺陷的。大部分app要通过多个rows才能获取到image information。当image 非常大的时候，他的pitch的长度就会超出并横跨了多个rows。在multicache-level的系统中，寻址就是个性能损耗问题了。这种寻址有个名词称作<strong>translation lookaside buffer（TLB).</strong></p><p>为了解决这个问题，大部分GPU都采用了一种swizzle format的方式来储存texels，也被称作Optimal tiling。</p><p>注释：swizzle format 表示一种Z字形的存储方式。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/image-20210111203538502.png" alt="image-20210111203538502"></p><p>相比较linear的存储方式是把同样颜色的blocks岔开在内存中做线性排列，Optimal 布局可以让同样的颜色的blocks在内存中排列在一起。这种方式就可以让临近的texel的访问更加高效而避免性能损失。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一张主要介绍了image resource 的创建过程和swapchain的implementation，并重点讲了depth image的寻址问题。书中提供了很多细节在导读里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan 导读2: Command Buffer 和内存管理</title>
      <link href="/2021/01/11/7c7/"/>
      <url>/2021/01/11/7c7/</url>
      
        <content type="html"><![CDATA[<p>导读2 主要是讲解第五章，之所以跳过2，3，4章是因为这三章关键概念很少，更多的是围绕Vulkan初始化阶段的准备工作。第五章重点讲解了CB和内存的概念，值得对其细节进行整理。</p><p>一个command buffer就是a collection of commands. Command buffer 会被提交到一个合适的 hardware queue 让GPU来处理。driver会fetches和validates并compiles这些command buffers，然后再把它们交给GPU来处理。这一章节主要围绕command buffers 和 memory allocation的讲解了以下topics：</p><ul><li>Getting started with command buffers</li><li>Understanding the command pool and command buffer APIs</li><li>Recording command buffers</li><li>Implementing the command buffer wrapper class</li><li>Managing memory in Vulkan</li></ul><h1 id="Getting-started-with-command-buffers"><a href="#Getting-started-with-command-buffers" class="headerlink" title="Getting started with command buffers"></a>Getting started with command buffers</h1><p><strong>名词解释</strong></p><p><strong>Command Buffer</strong>：a command buffer is a buffer or collection of commands in a single unit.</p><p>一个CB 记录了多个可以被App调用和执行的Vulkan API commands。CB一旦被baked后，是可以<strong>反复使用</strong>的。CB们按照App的调用commands的次序来依次记录commands。这些commands是用来承载不同类型的jobs。这些jobs包括：binding vertex buffer， pipeline binding， recording Render Pass Commands， setting viewport and scissor， specifying drawing commands， controlling copy operations on imag and buffer contents 等。</p><p>Command Buffer  有两种：</p><ul><li><strong>Primary command buffers</strong>：这种buffer是SCB的owners，并负责执行SCB。PCB是可以被直接提交到queues上。</li><li><strong>Secondary command buffers：</strong>SCB是通过PCB来执行的。他们不可以直接被提交到queues上。</li></ul><p>一个APP可能会有成百上千个CB。由于数量巨大，所以CB都是通过command pool来创建的， CB本身是无法直接被创建的。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640-20210111143521475.jpg" alt="图片"></p><p>CB是persistent的；它们一旦被创建，就可以被持续地复用。如果一个CB不再有用了，它也可以通过reset command来被renew，然后为下一个recording做好准备。这种做法跟“destroy 再create”的做法比就显得更加高效，</p><h2 id="显式同步（Explicit-Synchronization）"><a href="#显式同步（Explicit-Synchronization）" class="headerlink" title="显式同步（Explicit Synchronization）"></a>显式同步（Explicit Synchronization）</h2><p>CB 是由每一个thread所负责的 command buffer pool来创建的。这种做法避免了不同threads之间需要显式地同步去创建CB。但是App必须要对在不同的threads之间共用的CBs做同步不管理。</p><p>书中用了一段话比较了OpenGL跟Vulkan两者，把CB提交给GPU过程的区别。值得留意：</p><p>*”Another differentiation is the submission of the command buffers in OpenGL: command* <em>buffers are pushed behind the scenes and are not in control of the application. An</em> <em>application that submits the commands has no guarantee when those jobs will be executed.</em> <em>This is because OpenGL executes command buffers in batches. It waits for the commands to</em> <em>build the batch and then it dispatches them together. On the other hand, Vulkan gives</em> <em>explicit control to the command buffer to allow the processing up front by submitting it to</em> <em>the desired queue.” P120, 《Learn Vulkan》</em></p><p>CB 包含了很多个 commands。 这些Commands可以归类为三种：</p><ul><li><strong>Action</strong>: This command performs operations such as draw, dispatch, clear, copy,query/timestamp operations, and begin/end a subpass</li><li><strong>State management:</strong> This includes descriptor sets, bind pipelines, and buffers, and it is used to set the dynamic state, push constants, and the Render Pass/subpass state</li><li><strong>Synchronization:</strong> These commands are used for synchronization: pipeline barriers, set events, wait events, and Render Pass/subpass dependencies</li></ul><p><img src="https://i.loli.net/2021/11/12/4jHl6KiBogy3N5x.png" alt="4jHl6KiBogy3N5x"></p><h2 id="Command-Buffer-and-Queues"><a href="#Command-Buffer-and-Queues" class="headerlink" title="Command Buffer and Queues"></a>Command Buffer and Queues</h2><p>CB被提交到 hardware queue后会被异步处理掉。 队列提交可以通过batching CBs来一次完成。Vulkan有一种deferred command model：它可以让CB里对<strong>draw calls的收集</strong>和<strong>提交</strong>分别作为两个不同的operations来单独处理。这种做法方便了App可以在大部分场景下针对submission 做出适当的优化， 而这恰恰是OpenGL很难做到的。</p><p>Vulkan 提供对硬件queue的逻辑view。每一个逻辑view都关联着一个hardware queue。 一个单一的hardware queue可以用多个逻辑queues。</p><h3 id="The-Order-of-Execution"><a href="#The-Order-of-Execution" class="headerlink" title="The Order of Execution"></a>The Order of Execution</h3><p>CBs 可以被提交一个single queue或者多个queues上：</p><ul><li><strong>Single queue submission:</strong> Multiple command buffers submitted to a single queue may be executed or overlapped. In single queue submission, a command buffer must obey the order of the execution of operations as per the command order and the API order specification. This book only covers the submission commands used for vkQueueSubmit; it does not cover sparse memory binding command buffers (through vkQueueBindSparse).</li><li><strong>Multiple queue submission:</strong> The command buffers submitted to multiple queues may be executed in any order unless explicit ordering constraints are applied through the synchronization mechanism via semaphores and fences.</li></ul><h2 id="Recording-Command-Buffers"><a href="#Recording-Command-Buffers" class="headerlink" title="Recording Command Buffers"></a><strong>Recording Command Buffers</strong></h2><p>一个CB是通过vkBeginCommandBuffer()和 vkEndCommandBuffer()这两个 APIs 来记录的。这两者之间的scope就是具体的Vulkan commands 被记录的范围。下图显示了一个Render Pass Instance在这两个API之间被记录的过程：</p><p><img src="https://i.loli.net/2021/11/12/mLADIpkoybuqYzM.png" alt="6hjLts5QIilXu8M"></p><h2 id="Queue-Submission"><a href="#Queue-Submission" class="headerlink" title="Queue Submission"></a><strong>Queue Submission</strong></h2><p>当一个CB完成记录后，它就可以被提交到一个queue上了。vkQueueSubmit() API 用来把一个CB或者在多个CB提交到正确的queue上。</p><h2 id="Queue-Waiting"><a href="#Queue-Waiting" class="headerlink" title="Queue Waiting"></a>Queue Waiting</h2><p>当CBs被提交到queue后，App要等待所提交的工作被完成，才可以接受一下个batch。等待queue的API 是 vkQueueWaitIdle() API。</p><h1 id="Managing-Memory-in-Vulkan"><a href="#Managing-Memory-in-Vulkan" class="headerlink" title="Managing Memory in Vulkan"></a>Managing Memory in Vulkan</h1><p>Vulkan 将内存分成两种：<strong>host memory</strong> 和 <strong>device memory</strong>。host memory被device memory 慢，但是可用的地方比较多。device memory 对GPU可见，所以更快。</p><h2 id="Host-Memory"><a href="#Host-Memory" class="headerlink" title="Host Memory"></a><strong>Host Memory</strong></h2><p>书中段落开头一段话很重要，摘要如下：</p><p><em>“Vulkan makes use of host memory to store API internal data structures in the implementation. Vulkan provides allocators, which allow an application to control memory allocation on behalf of host memory. If the application does not use allocators, then the Vulkan implementation uses a default allocation scheme to reserve a memory slot for its data structures.” （p137， 《Learn Vulkan》）</em></p><p>这段话可以总结为以下信息：</p><ul><li>host memory 是用来存储API internal data strucutures</li><li>App通过Allocator来分配和创建host 的memory</li><li>如果APP不通过allocator，那么Vulkan使用默认alllocation scheme来为data structures保留内存的slot。</li></ul><p>至于内存的分配管理则是用callback来完成的：</p><p><em>“Host memory is managed by the VkAllocationCallbacks control structure, which is passed to Vulkan APIs for custom management of host memory.”</em></p><h2 id="Device-Memory"><a href="#Device-Memory" class="headerlink" title="Device Memory"></a><strong>Device Memory</strong></h2><p>书中段头解释的很清楚： </p><p><em>“Device memory is GPU memory that is visible to the physical device. The physical device can read its memory regions directly. Device memory is very close to the physical device, and thus provides faster performance than host memory. Image objects, buffers objects, and uniform buffer objects are all allocated on device memory.”</em> P139，《Learn Vulkan》</p><p>App 有责任通过调用 <em>vkGetPhysicalDeviceMemoryProperties()</em>API 来查询物理设备上可用的memory heaps 和 meomory properities，并更好的分配这些资源。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>书中在这一章节介绍了CB和meomory allocation， 并给出了API的调用细节，导读里我没有针对具体的代码细节展开，代码可以自己看，很容易理解。Vulkan所分配的资源可以分为两种：<strong>buffers</strong> 和 <strong>images</strong>。我们会在导读3介绍images resources；然后在导读4里介绍 buffer resource，Render Pass，Framebuffer 和 shaders。所以导读4也将是最重要的一章！</p><p>引用： 《Learning Vulkan》</p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan 导读1: 下一代图形API</title>
      <link href="/2021/01/11/59e9/"/>
      <url>/2021/01/11/59e9/</url>
      
        <content type="html"><![CDATA[<p>写在之前：此篇为Danny针对《Learning Vulkan》一书的导读。导读的目的主要是将一些重要的概念重点归纳和解释，并对不清楚的概念提出疑问，作为后续工作和学习中的<strong>待澄清点</strong>。</p><p>Danny认为，一本好的书，是可以加深技术理解，自画自圆，其义自见的；一本不好的书，要靠读者去猜，搜索很多其他补助资料才能澄清。优秀的书是可以从全局观开始，聚焦到细节。一本不好的书，说的都是正确的废话。 最近读了两本关于Vulkan的书，一本是电子版的《Learning Vulkan》。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640.jpg" alt="图片"></p><p>一本是花了$175购买的纸质的《Computer Graphics and the Vulkan API》</p><p>两本书都是对下一代图形API的细节展开，Danny希望通过一种导读的形式来将这两本书的一些重要概念融合一下。写这篇文章的内容不是说大家看导读就不用去读书了，而是希望辅助大家阅读图书。如今的时代都是<strong>速食知识消费，time is money。 大家都没有时间，</strong>但是这种<strong>速食</strong>知识消费很容易让大家<strong>知其然而不知其所以然</strong>。</p><p>导读的梳理其实比较耗时间。技术读物不像读小说那样可以进行速读，阅读过程要注意的环节是避免眼球回跳。但是，很多内容还是需要理解和自我提问，甚至对于解释模糊不清的内容还要查阅第三方资料。所以花一个礼拜读完一本技术书，两天后可能只记得几幅图片了。 技术内容的阅读还是要记录笔记和操作代码尝试同步进行，毕竟别人嚼过的饭菜自己吃着肯定没有味道。 </p><p>小的时候电视节目不多，网络也不发达，那个时候是真的可以安心看看几本书；长大了之后，我们的耐心呢？那我们回到正文吧。</p><p><strong>名词解释</strong></p><p><strong>Physical device and device</strong>：A physical device represents a unique device,whereas a device refers to a logical representation of the physical device in anapplication.</p><p><strong>Memory type</strong>：两种内存类型，host 和 device。</p><p><strong>Command</strong>： 某个行为的指令。具体包括三种，action，set state，sync。</p><p><img src="https://i.loli.net/2021/11/12/5endD7JGHTRU3x6.png" alt="5endD7JGHTRU3x6"></p><h1 id="Vulkan的工作机制"><a href="#Vulkan的工作机制" class="headerlink" title="Vulkan的工作机制"></a>Vulkan的工作机制</h1><ul><li>Vulkan 让应用程序<strong>显式地</strong>管理内存。</li><li>Command buffers 被提交到queues上，然后由queues把这些command buffer jobs提交给物理设备处理。</li></ul><p><img src="https://i.loli.net/2021/11/12/ZksXYdjCo1hWliT.png" alt="ZksXYdjCo1hWliT"></p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/image-20210111141408581.png" alt="image-20210111141408581"></p><h1 id="Vulkan’s-Queues"><a href="#Vulkan’s-Queues" class="headerlink" title="Vulkan’s Queues"></a>Vulkan’s Queues</h1><ul><li><strong>Queues</strong>是把command buffers 喂给GPU设备的<strong>媒介</strong>。</li><li><strong>Command Buffers</strong> 记录一个或多个commands并把它们提交给指定的queue上。</li><li>设备一般会有多个queues，所以把command buffer提交到queue的工作要由app来负责。</li><li>Command buffers 可以被提交到一个 或 多个Queue上。</li></ul><h2 id="Single-Queue："><a href="#Single-Queue：" class="headerlink" title="Single Queue："></a><strong>Single Queue：</strong></h2><ul><li>维护了command buffer的submission和execution的顺序，和playback。 （playback是什么，这里先带着问号，之后去找解释。）</li><li>Command Buffers 是按照顺序执行的。</li></ul><h2 id="多个Queues的时候"><a href="#多个Queues的时候" class="headerlink" title="多个Queues的时候"></a><strong>多个Queues的时候</strong></h2><ul><li>允许command buffer在两个甚至多个queues上平行执行</li><li>除非需要显式的定义，command buffers 的提交和执行顺序 不能得到保证。 应用程序必须对同步机制负责。否则，执行的顺序可能完全失控。</li></ul><h1 id="Vulkan-的同步机制"><a href="#Vulkan-的同步机制" class="headerlink" title="Vulkan 的同步机制"></a>Vulkan 的同步机制</h1><p><strong>Semaphore</strong>： 用来同步多个queues或者 a coarse-grained command buffer submission in a single queue</p><p><strong>Events</strong>： 用来控制fine-grained sychronization 并且用在single queue上，使同步工作既可以在single command buffer上完成 也可以在a sequence of command buffers on a single queue上完成。</p><p><strong>Fences</strong>： 允许 同步可以在host 和设备两者之间完成。</p><p><strong>Pipeline Barriers</strong>：a pipeline barrier 是一个被插入的instruction，它用来保证一个command buffer里的被插入的这个instructuction的前边的commands必须比它后边的commands先执行。</p><h1 id="Vulkan-Objects"><a href="#Vulkan-Objects" class="headerlink" title="Vulkan Objects"></a>Vulkan Objects</h1><p>从应用层角度出发：所有的entities，包括devices，queues，command buffers， framebuffers， pipelines等都叫做Vulkan Objects。</p><p>从API 层来看，这些Vulkan Objects被认为是handles。这些handles分成两种：</p><p><strong>Dispatchable handles</strong>：这种handle是一个指针，指向一个不可以直接被access或是一个不可以被更改其内部fields的entity。这些fields的只能通过API的方式来access。 每一个dispatchable handle都有一个相关的dispatchable type。handle是可以作为parameter 被传入API的command里。这些handle包括如下：</p><p><img src="https://i.loli.net/2021/11/12/zCdRGpANj4HoUxg.png" alt="obNZ7clekvLaxH2"></p><p><strong>Non-dispatchable handles：</strong>64-bit integer 类型的handles。这种类型的handle并不是指针，相反，它可能会存有它所表示的object的信息。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640-20210111140810447.jpg" alt="图片"></p><h1 id="Objects的生命周期-and-command-syntax"><a href="#Objects的生命周期-and-command-syntax" class="headerlink" title="Objects的生命周期 and command syntax"></a>Objects的生命周期 and command syntax</h1><p>Vulkan的对象是由app来显式地create和destory的。Vulkan提供了create和destroy两种command来创建和删除object。</p><p>这些command 的 syntax如下：</p><ul><li>Create syntax: Objects are created using the vkCreate* command; this accepts a Vk*CreateInfo structure as a parameter input</li><li>Destroy syntax: The objects produced using the Create command are destroyed using vkDestroy*</li></ul><p>从现有object pool 或者 heap 上创建的Objects 是通过 Allocate command 创建，释放是通过Free。</p><ul><li><p><strong>Allocate syntax:</strong> Objects that are created as part of an object pool use vkAllocate* along with Vk*AllocateInfo as an argument input.</p></li><li><p><strong>Freeing syntax</strong>: Objects are released back to the pool or memory using the vkFree* command.</p></li></ul><p>通常来说，Vulkan的command可以简单的区分为两种，一种是Get型，另一种是record型。</p><p><img src="https://i.loli.net/2021/11/12/5i6ScpUmuZ8rzQW.png" alt="9HnYXdgolhRmLib"></p><h1 id="Vulkan-应用跟周边的关系"><a href="#Vulkan-应用跟周边的关系" class="headerlink" title="Vulkan 应用跟周边的关系"></a>Vulkan 应用跟周边的关系</h1><p><img src="https://i.loli.net/2021/11/12/j1VprakqLRQJcoy.png" alt="image-20211111120007589"></p><p>对于上述各个组件，请参考Learning Vulkan英文解释如下：</p><p><strong><em>Driver</em></strong></p><p><em>A Vulkan-capable system comprises a minimum of one CPU and GPU. IHV’s vendor supplies the driver of a given Vulkan specification implementation for their dedicated GPU architecture. The driver acts as an interface between the application and the device itself. It provides high-level facilities to the application so it can communicate with the device. For example, it advertises the number of devices available on the system, their queues and queue capabilities, available heaps and their related properties, and so on.</em></p><p><strong><em>Application</em></strong></p><p><em>An application refers to a user-written program that is intended to make use of Vulkan APIs to perform graphics or compute jobs. The application starts with the initialization of the hardware and software; it detects the driver and loads all the Vulkan APIs. The presentation layer is initialized with Vulkan’s Window System Integration (WSI) APIs; WSI will be helpful in rendering the drawing image on the display surface. The application creates resources and binds them to the shader stage using descriptors. The descriptor set layout helps bind the created resources to the underlying pipeline object that is created (of the graphics or compute type). Finally, command buffers are recorded and submitted to the queue for processing.</em></p><p><strong><em>WSI</em></strong></p><p><em>Windows System Integration is a set of extensions from Khronos for the unification of the presentation layer across different platforms, such as Linux, Windows, and Android.</em></p><p><strong><em>SPIR-V</em></strong></p><p><em>SPIR-V provides a precompiled binary format for specifying shaders to Vulkan. Compilers are available for various shader source languages, including variants of GLSL and HLSL, which produce SPIR-V.</em></p><p><strong><em>LunarG SDK</em></strong></p><p><em>The Vulkan SDK from LunarG comprises a variety of tools and resources to aid Vulkan application development. These tools and resources include the Vulkan loader, validation layers, trace and replay tools, SPIR-V tools, Vulkan runtime installer, documentation, samples, and demos…You can read more about it at <a href="http://lunarg.com/vulkan-sdk">http://lunarg.com/vulkan-sdk</a>.</em></p><h1 id="Vulkan开发流程"><a href="#Vulkan开发流程" class="headerlink" title="Vulkan开发流程"></a>Vulkan开发流程</h1><p><img src="https://i.loli.net/2021/11/12/PXVc6AdFCYTekR7.png" alt="PXVc6AdFCYTekR7"></p><h2 id="1-硬件初始化"><a href="#1-硬件初始化" class="headerlink" title="1. 硬件初始化"></a>1. 硬件初始化</h2><p>Application通过Loader来激活Vulkan 的drivers。Loader包含以下组件：</p><p><img src="https://i.loli.net/2021/11/12/koEtw53xHyRKpVA.png" alt="koEtw53xHyRKpVA"></p><p><strong>名词解释</strong>：<em>Loader。是一组代码。因为Vulkan是跨平台的，所以在应用程序启动的时候来，loader是用来定位应用程序所处系统的Vulkan的driver。</em></p><p>Loader有三个主要的职责：</p><p><strong>Locating drivers， Platform-independent， 和 Injectale layers</strong></p><p>当loader完成了drivers的定位和其API 的linking后，App就要负责完成以下操作：</p><p>创建Vulkan Instance</p><p>查询可用的GPU物理设备所能提供的queues</p><p>查询extensions，并把extensions存储为function pointers， 例如WSI 或者 speicial feature APIs</p><p>使能一个injectable layer来做error checking，debugging 或者 validation</p><h2 id="2-窗口展现"><a href="#2-窗口展现" class="headerlink" title="2. 窗口展现"></a>2. 窗口展现</h2><p>当完成了loader定位driver这一环节，我们就可以用Vulkan API来draw东西了。这里，我们需要一个image来执行drawing task，并把image放的presetation window去显示出来。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/640-20210111140811196.jpg" alt="图片"></p><p>跟OpenGL不同的是，Vulkan的context 和 device没有包括window system，Vulkan是通过Windows System Integration（WSI）来管理的 window的，而GL的context和device是在创建windows system framebuffer时就一起创建好了。</p><p>WSI 包括了一组跨平台的窗口管理拓展。可以支撑Windows，Linux，Android等不同的操作系统。并且它是一套consistent API标准，可以简单地用来创建surfaces，并把sufaces显示出来。</p><p>WSI提供了swapchain的机制。这个机制允许使用多个images，这就使得当窗口系统在显示一个image的时候，App可以准备下一个image。下图解释了double-buffering swap image的过程。这个过程使用了两个images。在<strong>WSI</strong>的协助下，这个两个images在App和Display两者间被交换使用。</p><p><img src="https://i.loli.net/2021/11/12/FZ8aoWYCur1N4IL.png" alt="FZ8aoWYCur1N4IL"></p><p>WSI 是Display和应用中间的<strong>interface</strong>。它能够保证Display和Application在使用两个images的过程中是互不干扰的。当App在<strong>第一个Image</strong>上工作的时候，<strong>WSI</strong>把<strong>第二个Image</strong> 交给Display来渲染其内容到屏幕上。当App完成了对<strong>第一个image</strong>的绘图，App就把<strong>第一个image</strong>提交给<strong>WSI</strong>，然后获取<strong>第二个image</strong>来继续一下个draw的工作。</p><p>这里可以理解为image相当于OpenGL里的FrameBuffer, 即内存中的一块区域，它存储了GPU通过它的pipeline流程后最终显示在屏幕上的结果。image的内容，即将要在显示在屏幕上的内容。</p><p>所以此刻，我们将完成下面的操作：</p><ol><li>Create a native window (like the CreateWindow method in the Windows OS)</li><li>Create a WSI surface attached to the window</li><li>Create the swapchain to present to the surface</li><li>Request the drawing images from the created swapchain</li></ol><h2 id="3-资源配置"><a href="#3-资源配置" class="headerlink" title="3. 资源配置"></a>3. 资源配置</h2><p>配置资源意味着存储数据到内存的指定区域。这些数据可能是任何类型的。例如，vertex attributes，包括position，color，image type/name.</p><p>不同于OpenGL那种隐性的管理内存的方式（这里说到隐性的意思是OpenGL本身自己来管理内存，不需要过多的要求用户来管理内存），Vulkan提供了full low-level access and control of memory。Vulkan会广告出物理设备上各式各样的可用的内存，来让App对其做显式的管理。</p><p>Memory Heap 按照其performance可以分为两类：</p><p>Host Local：CPU使用的内存，但是对于GPU读取来说是slower typer of memory</p><p>Device Local：直接attached到GPU物理设备的内存，对于GPU来说是high bandwidth，faster</p><p>按照，内存的配置，又可以分成三种:</p><table><thead><tr><th></th><th>Device Local</th><th>Device Local and host visible</th><th>Host Local and host visible</th></tr></thead><tbody><tr><td>Visible to device</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Visible to host</td><td>No</td><td>Yes</td><td>Yes</td></tr></tbody></table><p>Vulkan 是让App来显式的管理内存资源的。以下是内存管理的process：</p><ol><li><p>Resource Objects：App 来allocate内存资源，这些内存资源包括images或者buffer ojbects</p></li><li><p>Allocation and suballocaiton： 这一段节选书中原文的解释，是内存管理和工作机制的最重要一段内容。</p><p><em>“<strong>When resource objects are created, only logical addresses are associated with them; there is no physical backing available. The application **allocates</strong> physical memory and <strong>binds</strong> these logical addresses to it. As allocation is an expensive process, <strong>suballocation</strong> is an efficient way to manage the memory; <strong>it allocates a big chunk of physical memory at once and puts different resource objects into it.</strong> Suballocation is the responsibility of an application. The following diagram shows the suballocated object from the big allocated piece of physical memory:”</em></p><p><img src="https://i.loli.net/2021/11/12/8loaO6FBzRKvTfs.png" alt="lrTz4DdhAuRWYCO"></p></li><li><p>Sparse memory： 对于超大的image objects，Vulkan自持Sparse memory。Danny对sparse memory的理解就是原来本可以一整块的memory中的对象，但是由于此对象太大，已经超出了内存本身的capacity，Vulkan就把这个超大image object 拆解成tiles，然后只load那些App逻辑处理时需要的tiles。 </p></li><li><p>Staging Buffers：object buffer 和 image buffer 的数据填充是在staging 这个环节完成的。在这个环节里，两个不同的内存区域被用来做物理分配。 对于一个资源的理想的内存放置区域可能是一块host不可见的内存，那么在这种情况下，App就需要先在host-visible的staging buffer这个阶段把resource的数据或者字段填充好，然后再把这个resource转到理想的device local的的内存区域里。</p></li><li><p>Asynchronous Transfer： 数据的传输是通过DMA、Transfer queues的异步commands 来完成的。</p><p>此处书中提到关于OpenGL针对内存的管理，原文值得阅读：</p><p><em>“In contrast, OpenGL resource management does not offer granular control over the memory.</em> <strong><em>There is no conception of host and device memory;\</em></strong> <em>the driver secretly does all of the allocation in the background. Also, these allocation and suballocation processes are not fully transparent and might change from one driver to another. This lack of consistency and hidden memory management cause unpredictable behavior. Vulkan, on the other hand, allocates the object right there in the chosen memory, making it highly predictable.”</em></p></li></ol><p>所以，资源配置有以下5步：</p><ol><li>创建a resource object</li><li>查询合适的内存instance and create内存对象，例如buffer 和 images</li><li>Get 内存allocation的requirements</li><li>Allocate space 并把数据存储进去</li><li>绑定resource object到内存</li></ol><p><strong>思考</strong>：这5步书中没有解释清楚，感觉是第4步先把数据写入内存，再绑定对象到内存中。这种做法非常像OpenGL的VBO 和VAO的概念。即先把绘图模型的数据写入VBO 的buffer里，然后再通过绑定context 当前的VAO来描述VBO里的数据的属性。 建议这块内容在后期Vulkan 的 resource object 创建时看看具体的操作对比OpenGL是怎么进行的。</p><h2 id="4-管线配置"><a href="#4-管线配置" class="headerlink" title="4. 管线配置"></a>4. 管线配置</h2><p>一条pipeline其实就是一组events。这些events会按照application的logic依次发生。这些events包括：供应shaders，把shaders绑定到resource上，并管理其pipeline的state。</p><p><img src="https://i.loli.net/2021/11/12/KE2Yn1zUuo38Rhy.png" alt="KE2Yn1zUuo38Rhy"></p><p>既然管线分成上述三部分，那么就需要对这三部分进行配置。</p><h3 id="Descriptor-sets-and-descriptor-pools"><a href="#Descriptor-sets-and-descriptor-pools" class="headerlink" title="Descriptor sets and descriptor pools"></a>Descriptor sets and descriptor pools</h3><p><strong>名词解释</strong></p><p>A descriptor set 就是resources 和 shaders 之间的interface。 它是一个简单的结构体，可以把shader绑定到resource 上，例如 images或者buffers。它跟shader将要用的一块resouce memory相关联或者bind。 以下是跟descriptor sets相关的一些特点：</p><ul><li><strong>Frequent change:</strong> By nature, a descriptor set changes frequently; generally, it contains attributes such as material, texture, and so on.</li><li><strong>Descriptor pool:</strong> Considering the nature of descriptor sets, they are allocated from a descriptor pool without introducing global synchronization.</li><li><strong>Multithread scalability:</strong> his allows multiple threads to update the descriptor set simultaneously</li></ul><p>所以a descrptor set的fields会经常被改变；他们是由descriptor 池allocate 出来的；一个descriptor set结构体可以同时被多个threads更新。</p><p>注意：更新或者修改一个descriptor set结构体是<strong>Vulkan中性能最关键</strong>的路径。所以，descriptor的结构设计是实现最大性能的一个重要部分。Vulkan 支持三种不同的程度的针对多个descriptor set结构体的logical partitioning。这三种分别是：在scene（low frequency updates），model（medium frequence udpates），和 draw level（high frequency update）。这种工作机制保证了，high frequency的descriptor 更改不会影响到 low frequency descriptor 的 resources。</p><h3 id="Shaders-with-SPIR-V"><a href="#Shaders-with-SPIR-V" class="headerlink" title="Shaders with SPIR-V"></a>Shaders with SPIR-V</h3><p>在Vulkan，唯一能够制定shaders或者compute kernels是通过SPIR-V。SPIR-V有以下特点：</p><ul><li><strong>Multiple inputs:</strong> SPIR-V producing compilers exist for various source languages, including GLSL and HLSL. These can be used to convert a human-readable shader into a SPIR-V intermediate representation.</li><li><strong>Offline compilation</strong>: Shaders/kernels are compiled offline and injected upfront.</li><li><strong>glslangValidator:</strong> LunarG SDK provides the glslangValidator compiler, which can be used to create SPIR-V shaders from equivalent GLSL shaders.</li><li><strong>Multiple entry points</strong>: The shader object provides multiple entry points. This is very beneficial for reducing the shipment size (and the loaded size) of the SPIR-V shaders. Variants of a shader can be packaged into a single module.</li></ul><h3 id="Pipeline-management"><a href="#Pipeline-management" class="headerlink" title="Pipeline management"></a>Pipeline management</h3><p>一个物理设备包括一系类的硬件配置可以用来决定哪些被提交的几何数据将被如何interpreted和drawn。这些设置被总称为pipeline states。他们包括 rasterize state， blend state， 和 depth stencil state； 也包括了所提交的几何体的，和shader用来渲染的图元的topology type（point、line、triangle）。Pipeline里有两种states：dynamic和static。这些pipeline states被用来创建pipeline objects，恰恰这些pipeline objects又是性能的关键。所以我们不想反复的创建这些objects；我们需要创建它们一次，然后复用它们。</p><p>Vulkan允许通过pipeline objects配合<strong>Pipepline Cache Object（PCO）</strong>和Pipeline layout一起来控制管线的states。</p><p><strong>名词解释:</strong></p><p><strong>*Pipeline objects</strong>: Pipeline creation is expensive. It includes shader recompilation, resource binding, Render Pass, framebuffer management, and other related operations. Pipeline objects could be numbered in hundreds and thousands; therefore, each different state combination is stored as a separate pipeline object.*</p><p><strong>*PCO:</strong> The creation of pipelines is expensive; therefore once created, a pipeline can be cached. When a new pipeline is requested, the driver can look for a closer match and create the new pipeline using the base pipeline.*</p><p><strong>*Pipeline layout:</strong> Pipeline layouts describe the descriptor sets that will be used with the pipeline, indicating what kind of resource is attached to each binding slot in the shader. Different pipeline objects can use the same pipeline layout.*</p><p>在pipeline的管理阶段，会发生以下的操作：</p><ul><li><p>Application 把shader 编译成了SPIV-V的格式 并且在pipeline shader state里指定了其细节。</p></li><li><p>descriptor 帮我们把这些资源连接到shader。App 从descriptor pool那里分配了descriptor set，并把incoming 或 outgoing resources 连到shader里所的binding slots上。</p></li><li><p>App 创建pipeline objects，这些object包含了 static and dynamic state configuration to control the hardwre settings. The pipeline should be created from a pipeline cache pool for better performance.</p></li></ul><h2 id="5-指令记录"><a href="#5-指令记录" class="headerlink" title="5. 指令记录"></a>5. 指令记录</h2><p>Recording commands 就是形成command buffer 的过程。Command buffers 是从command pool memory 里创建出来的。 在App给定的开始和结束的范围内，command buffer 就会通过被提供comamnds来被记录下来。 下图表示了一个command buffer记录的过程：</p><p><img src="https://i.loli.net/2021/11/12/EJkg7jxAKXpz2Fv.png" alt="EJkg7jxAKXpz2Fv"></p><p>具体的Drawing包含以下的部分：</p><p><strong>Scope</strong>: The scope defines the start and end of the command buffer recording.</p><p><strong>Render Pass</strong>: This defines the execution process of a job that might affect the</p><p>framebuffer cache. It may comprise attachments, subpasses, and dependencies between those subpasses. The attachment refers to images on which the drawing is performed. In a subpass, an attachment-like image can be subpassed for multisampling resolve. Render Pass also controls how the framebuffer will be treated at the beginning of the pass: it will either retain the last information on it or clear it with the given color. Similarly, at the end of the Render Pass, the results are going to be either discarded or stored.</p><p><strong>Pipeline</strong>: This contains the states’ (static/dynamic) information represented by a pipeline object.</p><p><strong>Descriptor</strong>: This binds the resource information to the pipeline.</p><p><strong>Bind resource</strong>: This specifies the vertex buffer, image, or other geometry-related information.</p><p><strong>Viewport</strong>: This determines the portion of the drawing surface on which the rendering of the primitives will be performed.</p><p><strong>Scissor</strong>: This defines a rectangular space region beyond which nothing will bedrawn.</p><p><strong>Drawing</strong>: The draw command specifies geometry buffer attributes, such as the start index, total count, and so on.</p><p>每一个Command Buffer的创建都是非常昂贵的。如果同样的工作将用在多个frames上，那么command buffer是可以被复用多次的。CB 可以不需要被record而直接提交。而且，多个command buffers可以被同时，被多个threads制造出来。</p><p><img src="https://i.loli.net/2021/11/12/iLnopaShV2TQfCM.png" alt="IzjZd1QHmfrGyhL"></p><p>每一个thread 调用一个单独的command buffer pool来分配一个或多个CBs。</p><h2 id="6-指令提交"><a href="#6-指令提交" class="headerlink" title="6. 指令提交"></a>6. 指令提交</h2><p>当完成了command buffers 的创建， 他们就可以被提交到queue上进行下一步处理。Vulkan 提供了不同的queues，例如：graphics， DMA/transfer or compute queues.  Queue 的选择决定于其queue的天然属性。例如，跟graphics相关的任务必须提交到graphics queue上；compute operations相关的应该提交compute queue。 被提交的jobs 会被异步地执行。Comamnds buffers 可以被推送到多个各自的compatible queues 来进行parallel execution。App要对所有的command buffers 之间的同步 或 queues之间的同步负责，甚至是对host 和 devcie 两者之间的同步也要负责。</p><p>Commands 的提交执行了如下的工作：</p><ul><li>Acquiring the images from the swapchain on which the next frame will be drawn</li><li>Deploying any synchronization mechanism, such as semaphore and fence required</li><li>Gathering the command buffer and submitting it to the required device queue for processing</li><li>Requesting the presentation of the completed painted images on the output device</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>导读1主要Vulkan的一些关键名字，和大颗粒度的工作模式。这个模式包括了6个步骤，并以此介绍了每个步骤里发生了什么，都用到了那些元素。最后读完本篇，闭眼思考以下几个问题，看看你是不是能回答上来？</p><ul><li>本文在Vulkan里提到的pipeline 跟 GLES 提到的图形学里的pipeline有区别吗？</li><li>Command buffer 跟 job descriptor 有什么区别？</li></ul><p>引用： 《Learning Vulkan》</p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 的函数模板和类模板</title>
      <link href="/2020/06/29/c305/"/>
      <url>/2020/06/29/c305/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>C++提供函数模板（function template）。所谓的函数模板，实际上是建立一个通用函数，其函数的类型和形参类型不具体制定，有一个虚拟的那类型来代表。这个通用函数就成为函数模板。凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在末班中定义一次即可。在调用函数时，系统会根据形参的类型来取代模板的虚拟类型，从而实现了不同函数的功能。</p><ol><li><p>C++ 提供两种模板机制： 函数模板，类模板来进行泛型编程</p></li><li><p>类属 – 类型参数化，又称参数模板</p><p>使程序（算法）可以从逻辑功能上抽象，把被处理的对象（数据）类型作为参数传递。</p></li></ol><p>总结：</p><ul><li>模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为<strong>类属</strong>。</li><li>模板用于表达逻辑的结构相同，但具体数据元素类型不同的数据对象的通用行为。</li><li>让算法和数据类型分离</li></ul><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="为什么要有函数模板"><a href="#为什么要有函数模板" class="headerlink" title="为什么要有函数模板"></a>为什么要有函数模板</h2><p>当函数业务逻辑相同但参数不同时，我们就需要用到函数模板。</p><p>函数模板做函数参数的本质是类型参数化，好处就是可以编写与类型无关的代码；</p><p>注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p><p>定义函数模板的语法格式如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 形参名,<span class="keyword">typename</span> 形参名...&gt;</span><br><span class="line">返回值类型 函数名（参数列表）</span><br><span class="line">&#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>语法格式如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> 函数返回值类型 函数名&lt;实例化的类型&gt;(参数列表);</span><br></pre></td></tr></table></figure><p>注意这是声明语句，要以分号结束，&lt;&gt;中是显式实例的数据类型，即要实例化出一个什么类型的函数，例如，显示实例化为int，则在调用时，不是int类型的数据会转换为int类型进行计算。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++：在堆上创建对象，还是在栈上?</title>
      <link href="/2020/06/29/584/"/>
      <url>/2020/06/29/584/</url>
      
        <content type="html"><![CDATA[<p>本文参考自：<a href="https://www.devbean.net/2014/02/cpp-create-object-on-heap-or-stack/">https://www.devbean.net/2014/02/cpp-create-object-on-heap-or-stack/</a>  觉得对初学者有些帮助。</p><p>关于究竟是在堆上还是在栈上创建对象，可能很多初学者感到迷惑。我想可以把这部分内容拿出来详细介绍一下。现在，假设你已经清楚什么是堆，什么是栈。</p><p>如果需要在堆上创建对象，要么使用<code>new</code>运算符，要么使用<code>malloc</code>系列函数。这点没有异议。</p><p>真正有异议的是下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br></pre></td></tr></table></figure><p>此时，<code>obj</code>是在栈上分配的吗？</p><p>要回答这个问题，我们首先要理解这个语句是什么意思。这个语句就是代表着，在栈上创建对象吗？</p><p>其实，这行语句的含义是，使对象<code>obj</code>具有“自动存储（<strong>automatic storage</strong>）”的性质。所谓“<strong>自动存储</strong>”，意思是这个对象的存储位置取决于其声明所在的上下文。</p><ul><li>如果这个语句出现在函数内部，那么它就在栈上创建对象。</li><li>如果这个语句不是在函数内部，而是作为一个类的成员变量，则取决于这个类的对象是如何分配的。</li></ul><p>考虑下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Class *pClass = <span class="keyword">new</span> Class;</span><br></pre></td></tr></table></figure><p>指针<code>pClass</code>所指向的对象在堆上分配空间。因为<code>Object obj;</code>语句的含义是“自动存储”，所以，<code>pClass-&gt;obj</code>也是在堆上创建的。</p><p>理解了这一点，再来看下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object *pObj;</span><br><span class="line">pObj = <span class="keyword">new</span> Object;</span><br></pre></td></tr></table></figure><p><code>Object *pObj;</code>代表，指针<code>pObj</code>是自动存储的，仅此而已，没有任何其它含义。而下面一行语句则指出，这个指针所指向的对象是在堆上面分配的。如果这两行语句出现在一个函数内部，意味着当函数结束时，<code>pObj</code>会被销毁，但是它指向的对象不会。因此，为了继续使用这个对象，通常我们会在函数最后添加一个<code>return</code>语句，或者使用一个传出参数。否则的话，这个在堆上创建的对象就没有指针指向它，也就是说，这个对象造成了内存泄露。</p><p>并不是说指针指向的对象都是在堆上创建的。下面的代码则使用指针指向一个在栈上创建的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">Object *pObj = &amp;obj;</span><br></pre></td></tr></table></figure><p>至此，我们解释了函数内部的变量和成员变量。还有两类变量：全局变量和<code>static</code>变量。它们即不在堆上创建，也不在栈上创建。它们有自己的内存空间，是除堆和栈以外的数据区。也就是说，当<code>Object obj</code>即不在函数内部，又不是类的成员变量时，这个对象会在全局数据段创建，同理适用于<code>static</code>变量。对于指针<code>Object *pObj;</code>，如果这个语句出现在函数内部或类的成员变量，正如我们前面所说的，这个指针是自动存储的。但是，如果这个语句是在类的外部，它就是在全局数据段创建的。虽然它指向的对象可能在堆上创建，也可能在栈上创建。</p><p>堆和栈的区别在于两点：</p><ol><li>生命周期</li><li>性能</li></ol><p>第一点才是我们需要着重考虑的。由于栈的特性，如果你需要一个具有比其所在的上下文更长的生命周期的变量，只能在堆上创建它。所以，我们的推荐是：只要能在栈上创建对象，就在栈上创建；否则的话，如果你不得不需要更长的生命周期，只能选择堆上创建。这是由于在栈上的对象不需要我们手动管理内存。有经验的开发人员都会对内存管理感到头疼，我们就是要避免这种情况的发生。总的来说，我们更多推荐选择在栈上创建对象。</p><p>但是，有些情况，即便你在栈上创建了对象，它还是会占用堆的空间。考虑如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> func</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象<code>v</code>是在栈上创建的。但是，STL 的<code>vector</code>类其实是在堆上面存储数据的（这点可以查看源代码）。因此，只有对象<code>v</code>本身是在栈上的，它所管理的数据（这些数据大多数时候都会远大于其本身的大小）还是保存在堆上。</p><p>关于第二点性能，有影响，不过一般可以忽略不计。确切的说，一般情况下你不需要考虑性能问题，除非它真的是一个问题。</p><p>首先，在堆上创建对象需要追踪内存的可用区域。这个算法是由操作系统提供，通常不会是常量时间的。当内存出现大量碎片，或者几乎用到 100% 内存时，这个过程会变得更久。与此相比，栈分配是常量时间的。其次，栈的大小是固定的，并且远小于堆的大小。所以，如果你需要分配很大的对象，或者很多很多小对象，一般而言，堆是更好的选择。如果你分配的对象大小超出栈的大小，通常会抛出一个异常。尽管很罕见，但是有时候也的确会发生。有关性能方面的问题，更多出现在嵌入式开发中：频繁地分配、释放内存可能造成碎片问题。</p><p>现代操作系统中，堆和栈都可以映射到虚拟内存中。在 32 位 Linux，我们可以把一个 2G 的数据放入堆中，而在 Mac OS 中，栈可能会限制为 65M。</p><p>总的来说，关于究竟在堆上，还是在栈上创建对象，首要考虑你所需要的生命周期。当性能真正成为瓶颈的时候，才去考虑性能的问题。堆和栈是提供给开发者的两个不同的工具，不存在一个放之四海而皆准的规则告诉你，一个对象必须放在堆中还是在栈中。选择权在开发者手中，决定权在开发者的经验中。</p><p>最后我们来补充个练习：</p><p>我们创建了一个Class Circle，这个Circle class 的头文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INHERITANCE_CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INHERITANCE_CIRCLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//class properties decleartion</span></span><br><span class="line">    <span class="keyword">double</span> _r;</span><br><span class="line">    <span class="keyword">double</span> _area;</span><br><span class="line">    <span class="comment">//class function decleration</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setArea</span><span class="params">(<span class="keyword">double</span> area)</span></span>;</span><br><span class="line"></span><br><span class="line">    Circle();</span><br><span class="line"></span><br><span class="line">    ~Circle();</span><br><span class="line"></span><br><span class="line">    Circle(<span class="keyword">double</span> r);</span><br><span class="line"></span><br><span class="line">    Circle(<span class="keyword">double</span> r, <span class="keyword">double</span> area);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//INHERITANCE_CIRCLE_H</span></span></span><br></pre></td></tr></table></figure><p>Then’s let’s check the memory address to check we the pointer locates and where the real object locates</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Circle.h&quot;</span></span></span><br><span class="line"><span class="comment">// an object initialized on the dataspace</span></span><br><span class="line"><span class="function">Circle <span class="title">CircleOnDataSpace</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, memory!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// an object initialized on the stack</span></span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;<span class="comment">//circle locates on statck</span></span><br><span class="line">    Circle *ptrOnStack = &amp;CircleOnDataSpace; <span class="comment">// ptrOnStack is pointer and locates on stack</span></span><br><span class="line">    Circle *ptr = &amp;circle;<span class="comment">//pt locates on stack</span></span><br><span class="line">    <span class="comment">// an object initialized on the heap</span></span><br><span class="line">    Circle * circle_ptr = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>); <span class="comment">//new Circle creates an object locates on heap, but circle_ptr locates on stack</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CircleOnDataSpace&#x27;s address   = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)&amp;CircleOnDataSpace &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptrOnStack&#x27;s address          = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)&amp;ptrOnStack &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle&#x27;s address              = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle 1st member&#x27;s address   = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)&amp;(circle._r) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr address                   = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)&amp;ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;circle_ptr&#x27;s address          = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)&amp;ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle&#x27;s address              = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)circle_ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle&#x27;s 1st member;s address = &quot;</span> &lt;&lt; (<span class="keyword">long</span>)&amp;(circle_ptr-&gt;_r) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The result is printed out as following:</p><p>CircleOnDataSpace’s address     = 4344025352                //dataspace<br>ptrOnStack’s address                   = 140732871710<strong><em>304</em></strong>     //stack<br>Circle’s address                              = 140732871710<strong><em>312</em></strong>     //stack<br>Circle 1st member’s address       = 140732871710<strong><em>312</em></strong>     //stack<br>ptr address                                     = 140732871710<strong><em>296</em></strong>     //stack<br>circle_ptr’s address                       = 140732871710<strong><em>296</em></strong>     //stack<br>Circle’s address                              = 140471724682<strong><em>144</em></strong>     //heap<br>Circle’s 1st member;s address    = 140471724682<strong><em>144</em></strong>      //heap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>struct vs class in C++</title>
      <link href="/2020/06/29/52b1/"/>
      <url>/2020/06/29/52b1/</url>
      
        <content type="html"><![CDATA[<h1 id="基本区别"><a href="#基本区别" class="headerlink" title="基本区别"></a>基本区别</h1><p>struct 由c语言引入。在c语言中，是定义结构化数据的标准选择。其主观上的定义可参考：<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#vs">https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#vs</a></p><p>c++ 同时支持struct 和 class. 原因之一是c++ 是 c 的超集，涵盖c 已支持的语言要素，将更好的支持向下兼容(原来能够工作的c 源程序移植到c++，可以支付极少甚至0代价)。首先我们来看结构体在C和C++中的区别。</p><h2 id="C语言中的结构体"><a href="#C语言中的结构体" class="headerlink" title="C语言中的结构体"></a>C语言中的结构体</h2><h3 id="C语言中的结构体不能为空，否则会报错"><a href="#C语言中的结构体不能为空，否则会报错" class="headerlink" title="C语言中的结构体不能为空，否则会报错"></a>C语言中的结构体不能为空，否则会报错</h3><p>要求一个结构或联合至少有一个成员</p><h3 id="C语言中的结构体只涉及到数据结构，而不涉及到算法"><a href="#C语言中的结构体只涉及到数据结构，而不涉及到算法" class="headerlink" title="C语言中的结构体只涉及到数据结构，而不涉及到算法."></a>C语言中的结构体只涉及到数据结构，而不涉及到算法.</h3><p>也就是说在C中数据结构和算法是分离的。换句话说就是C语言中的结构体只能定义成员变量，但是不能定义成员函数。然而在C++中既可以定义成员变量又可以定义成员函数， C++中的结构体和类体现了数据结构和算法的结合。<br> 不过虽然C语言的结构体中不能定义成员函数，但是却可以定义函数指针，不过函数指针本质上不是函数而是指针，所以总的来说C语言中的结构体只是一个复杂数据类型 ，只能定义成员变量，不能定义成员函数，不能用于面向对象编程。来看一个函数指针的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FuncAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  <span class="comment">//求和</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">CTest1</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span>(*Add)(<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">//函数指针  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTest1</span> <span class="title">test</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> AddResult = <span class="number">0</span>;  </span><br><span class="line">    test.Add = My_FuncAdd;  </span><br><span class="line">    AddResult = test.Add(<span class="number">8</span>, <span class="number">6</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, AddResult);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-语言中的结构体"><a href="#C-语言中的结构体" class="headerlink" title="C++语言中的结构体"></a>C++语言中的结构体</h2><h3 id="第一种语法表示"><a href="#第一种语法表示" class="headerlink" title="第一种语法表示"></a>第一种语法表示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">   数据类型 member1；</span><br><span class="line">   数据类型 member2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式在声明结构体变量时为：struct 结构体名称 结构体变量名。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sNo;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu.sNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种语法表示"><a href="#第二种语法表示" class="headerlink" title="第二种语法表示"></a>第二种语法表示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">   数据类型 member1；</span><br><span class="line">   数据类型 member2;</span><br><span class="line">&#125;结构体名称别名;</span><br></pre></td></tr></table></figure><p>这种方式在声明结构体变量时有两种方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种：<span class="class"><span class="keyword">struct</span> 结构体名称 构体变量名</span></span><br><span class="line"><span class="class">第二种：结构体名称别名 结构体变量名</span></span><br></pre></td></tr></table></figure><p>原因：这里使用了typedef关键字，此关键字的作用就是声明数据类型的别名，方便用户编程，所以这里用了之后，结构体名称别名就相当于<code>struct 结构体名称</code>。在声明结构体变量时，就无需写<code>struct</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sNo;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;Stu;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span>  <span class="comment">//方式一</span></span><br><span class="line">    Stu stu1;            <span class="comment">//方式二</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu1.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stu1.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu1.sNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">   数据类型 member1；</span><br><span class="line">   数据类型 member2;</span><br><span class="line">&#125;结构体变量名;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">   数据类型 member1；</span><br><span class="line">   数据类型 member2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 结构体变量名；</span></span><br></pre></td></tr></table></figure><p>这种方式既定义了结构体名称，同时声明了一个结构体变量名。在其它地方也可以通过struct 结构体来再次声明其它变量，而第四种方法则不可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sNo;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;stu;      <span class="comment">//此处stu 是变量名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu.sNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四种方式"><a href="#第四种方式" class="headerlink" title="第四种方式"></a>第四种方式</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   数据类型 member1；</span><br><span class="line">   数据类型 member2<span class="comment">;</span></span><br><span class="line">&#125;结构体变量名<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此方式是匿名结构体，在定义时同时声明2个结构体变量，但不能在其它地方声明，因为我们无法得知该结构体的标识符，所以就无法通过标识符来声明变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sNo;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;stu，stu1;     <span class="comment">//匿名结构体，同时定义了2个结构体变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stu1.sNo);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stu1.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu1.sNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上C++的四种方式，是同样适用在C中，是对C++对C的结构体的包容。</p><h2 id="struct-和-class的区别"><a href="#struct-和-class的区别" class="headerlink" title="struct 和 class的区别"></a>struct 和 class的区别</h2><p>struct 和 class 实际在C++ 中没有什么区别。</p><p>struct 仍然可以继承自另一个struct (很少看到有人这么干)。</p><p>未见任何文档有描述说struct 比 class 更快。个人感觉既然struct 和 class 在实现上可以互换，也就是说要支持相同的语言级基础设施和复杂度，那么就不应该存在用哪个更快的问题。</p><table><thead><tr><th>Struct</th><th>Class</th></tr></thead><tbody><tr><td>字段类型是public, 默认的继承方式也是public</td><td>默认字段类型是private, 默认继承方式也是private。</td></tr><tr><td>结构体是值类型，它可以包含数据和方法</td><td>类是引用类型</td></tr><tr><td>结构体是值类型，不要求堆分配</td><td></td></tr><tr><td>结构体存储自身的数据在结构体中</td><td>类存储一个动态对象的引用</td></tr><tr><td>结构体通常用于较小的数据结构</td><td>通常较大</td></tr><tr><td>结构体会影响性能</td><td></td></tr><tr><td>一个结构体构造函数直接返回结构体值本身(存储在栈的临时位置)，该值在必要时被拷贝</td><td></td></tr><tr><td></td><td>对类而言，多个变量可以使用同一个对象的引用</td></tr><tr><td>不适用</td><td>对类而言，对一个变量的操作可能会影响到相同引用的其它变量</td></tr><tr><td>C语言中的结构体不能为空，否则会报错, 但是C++可以</td><td></td></tr></tbody></table><p>由于struct 和 class 的可替换性，那什么时候用struct，又什么时候用class呢？</p><p><strong>答案： 当你需要值语义的时候用 struct，当你需要引用语义的时候就用 class。</strong></p><h1 id="值类型-VS-引用类型"><a href="#值类型-VS-引用类型" class="headerlink" title="值类型 VS 引用类型"></a>值类型 VS 引用类型</h1><p>这些问题的核心就是数据和数据的存储位置。我们用局部变量、参数、属性和全局变量来存储数据。存储数据有两种最基本的方式。</p><p>值类型的变量直接存储数据，而引用类型的变量持有的是数据的引用，数据存储在数据堆中。</p><p>值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/ovvknE.png" alt="ovvknE"></p><p>引用类型（reference type）：class统称为引用类型。</p><p>值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。</p><h1 id="C-中结构体的继承关系"><a href="#C-中结构体的继承关系" class="headerlink" title="C++ 中结构体的继承关系"></a>C++ 中结构体的继承关系</h1><p>对于成员访问权限以及继承方式，struct中是public。而class中默认的是private，<strong>class还可以用于表示模板类型，struct则不行</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">living_habit</span>&#123;</span> <span class="comment">//生活习惯结构体</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">animal</span> :</span><span class="keyword">public</span> living_habit &#123;<span class="comment">//动物继承生活习惯结构体</span></span><br><span class="line">...</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bird</span> :</span><span class="keyword">public</span> animal&#123; <span class="comment">//鸟继承动物</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外namespace std{} : 称namespace(命名空间)，在声明一个命名空间时，花括号内不仅可以包括变量，而且还可以包括以下类型：</p><ul><li>变量(可以带有初始化)；</li><li>常量；</li><li>数(可以是定义或声明)；</li><li>结构体；</li><li>类；</li><li>模板；</li></ul><h1 id="C-类的定义和实现"><a href="#C-类的定义和实现" class="headerlink" title="C++类的定义和实现"></a>C++类的定义和实现</h1><h2 id="定义-默认的是private"><a href="#定义-默认的是private" class="headerlink" title="定义(默认的是private):"></a>定义(默认的是private):</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="comment">//公共的行为或属性  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">        <span class="comment">//公共的行为或属性  </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>两种方式:一种类内 实现(setPoint),另外一种是在类内对成员函数进行声明 ,类外实现(setPoint2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">   &#123;</span>  </span><br><span class="line">       <span class="keyword">public</span>:  </span><br><span class="line">           <span class="function"><span class="keyword">void</span> <span class="title">setPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//类内 实现setPoint函数  </span></span></span><br><span class="line"><span class="function">           </span>&#123;  </span><br><span class="line">               xPos = x;  </span><br><span class="line">               yPos = y;  </span><br><span class="line">           &#125;  </span><br><span class="line">     </span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">setPoint2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">//在类内对成员函数进行声明  ,类外实现</span></span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">void</span> <span class="title">printPoint</span><span class="params">()</span>       <span class="comment">//实现printPoint函数  </span></span></span><br><span class="line"><span class="function">           </span>&#123;  </span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; xPos &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; yPos &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">           &#125;  </span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span>:  </span><br><span class="line">           <span class="keyword">int</span> xPos;  </span><br><span class="line">           <span class="keyword">int</span> yPos;  </span><br><span class="line">   &#125;;  </span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Point2::setPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//通过作用域操作符 &#x27;::&#x27; 实现setPoint函数  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">      xPos = x;  </span><br><span class="line">      yPos = y;  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">       Point M;        <span class="comment">//用定义好的类创建一个对象 点M  </span></span><br><span class="line">       M.setPoint(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">//设置 M点 的x,y值  </span></span><br><span class="line">      <span class="comment">//M.setPoint2(10, 20); //设置 M点 的x,y值  </span></span><br><span class="line"></span><br><span class="line">       M.printPoint();     <span class="comment">//输出 M点 的信息  </span></span><br><span class="line">     </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>概念</strong>：class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到。<br> <strong>类型</strong>：struct是值类型，class是引用类型，因此它们具有所有值类型和引用类型之间的差异。<br> <strong>效率</strong>：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑。<br> <strong>关系</strong>：struct<strong>不仅能</strong>继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Type in C</title>
      <link href="/2020/06/22/5fe2/"/>
      <url>/2020/06/22/5fe2/</url>
      
        <content type="html"><![CDATA[<h1 id="Data-Type-Encapulation"><a href="#Data-Type-Encapulation" class="headerlink" title="Data Type Encapulation"></a>Data Type Encapulation</h1><p><code>void</code> means “no type”. <code>void *</code> means “a pointer with no type”. <code>void *</code> can point to any type of address.</p><ul><li><p>Usage 1: <code>void</code> is to encapulate the data type</p><ul><li><code>int initHardEnv(void ** handle)</code>. A typical example is memory opertation functions such as <code>memcpy</code> and <code>memset</code><ul><li><code>void * memcpy(void * dest, const void * src, size_t len);</code></li><li><code>void * memset(void * buffer, int c, size_t num);</code></li></ul></li></ul></li><li><p>Usage 2: <code>void</code> is to describe the return value and parameters. It only means “empty” or “nothing”. </p><ul><li><p>If a function has no return value, it shall declare the return value as <code>void</code>; </p></li><li><p>if a function has no parameter, it shall declare the parameter to be <code>void</code>.</p><p>Example: <code>void function(void)&#123; ... &#125;</code></p></li></ul></li><li><p>meaning of <code>void</code> pointer</p><ul><li><p>In C, only the same type of pointers can be mutally assigned to each other.</p></li><li><p><code>void *</code> pointer used as left operand will accept an a pointer assignment of any types</p></li><li><p><code>void *</code> pointer used as right operand doing the pointer assignment has to be exclusively casted  to the specific type on intention</p><p>Examples:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p1 = null;</span><br><span class="line"><span class="keyword">char</span> * p2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>C does not support <code>void</code> type variable</p></li></ul><h1 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h1><p>Pointer is also a data type. It has <strong>8 principles</strong>.</p><h2 id="1-Pointer-is-a-Data-Type"><a href="#1-Pointer-is-a-Data-Type" class="headerlink" title="1. Pointer is a Data Type"></a>1. Pointer is a Data Type</h2><ul><li>Pointer is a variable. It occupies memory space to store a memory address.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="keyword">int</span> * p1 = <span class="number">100</span>;  <span class="comment">// to tell the compiler to allocate 8 bytes of memory space</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>*p</code> can manupate the memory space. <ul><li>When declearing the pointer, we use <code>*</code>  to claim the varialble it modifies  is a pointer.</li><li>When use the pointer, we use <code>*</code> to update or access the value that the pointer points to in the memory space.</li><li>The left operand of <code>*p</code> means assignment, i.e. assign a value to a memory slot.</li><li>The right operand of *p means to retrieve the value from the memory slot.</li></ul></li><li>The <strong>pointer variable</strong> is different from the memory slot the it points to.<ul><li>Making <code>p=0X1111</code> will only change the pointer variable’s value. It won’t change the value that <code>p</code> points to.</li><li>Making <code>*p=&#39;a&#39;;</code> will only change the value it points to, but not change the value of the pointer variable.</li><li><strong>If a pointer points to memory value stored in the global constant memory space, the value of that memory can’t not be changed.</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert code here...</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> * p1 = &amp;x;  <span class="comment">// to tell the compiler to allocate 8 bytes of memory space</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the value of p1: %d\n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * p2 = <span class="number">3</span>; <span class="comment">// this assignment is misleading and not recommended, because you are assigning an int value to pointer variable.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the value of p1: %d\n&quot;</span>, p2);</span><br></pre></td></tr></table></figure><p>The output the above is as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the value of p1: -272632532</span><br><span class="line">the value of p1: 3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns-Single Responsibility Principle</title>
      <link href="/2020/06/21/ab5f/"/>
      <url>/2020/06/21/ab5f/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li>Design patters are common architecture approaches.  (是架构的设计的具体应用方法论)</li><li>Students in Software Engineering Major are usually requirde to take the design patterns in their 3rd year program.</li><li>Popularized by the Gang of Fours book, 1994 – Smalltalk &amp; C++</li><li>Translated to many OOP languages: C#, Jav</li></ul><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/gbkQcf.png" alt="gbkQcf"></p><h1 id="Course-Structure"><a href="#Course-Structure" class="headerlink" title="Course Structure"></a>Course Structure</h1><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/XDVYku.png" alt="XDVYku"></p><h2 id="Creational-创建型"><a href="#Creational-创建型" class="headerlink" title="Creational (创建型)"></a>Creational (创建型)</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/YUfWuB.png" alt="YUfWuB"></p><h2 id="Structual-（结构型）"><a href="#Structual-（结构型）" class="headerlink" title="Structual （结构型）"></a>Structual （结构型）</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/atFs0y.png" alt="atFs0y"></p><h2 id="Behavioral-（行为型）"><a href="#Behavioral-（行为型）" class="headerlink" title="Behavioral （行为型）"></a>Behavioral （行为型）</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/eE5Zkn.png" alt="eE5Zkn"></p><h1 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h1><ul><li>Software Coach in 2012 Software Engineering Lab</li></ul><h1 id="The-SOLID-Design-Principles"><a href="#The-SOLID-Design-Principles" class="headerlink" title="The SOLID Design Principles"></a>The SOLID Design Principles</h1><p><strong>SOLID is an acronym which stands for the following design principles (and their abbreviations):</strong></p><p><em>• Single Responsibility Principle (SRP)</em></p><p><em>• Open-Closed Principle (OCP)</em></p><p><em>• Liskov Substitution Principle (LSP)</em></p><p><em>• Interface Segregation Principle (ISP)</em></p><p><em>• Dependency Inversion Principle (DIP)</em></p><ul><li>Was introduced by Robert C. Martin</li><li>I will reference from these books</li></ul><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/CrjDKq.png" alt="CrjDKq"></p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/NViQJZ.png" alt="NViQJZ"></p><h2 id="Single-Responsibility-Principle-单一功能原则"><a href="#Single-Responsibility-Principle-单一功能原则" class="headerlink" title="Single Responsibility Principle (单一功能原则)"></a>Single Responsibility Principle (单一功能原则)</h2><p>The <strong>single-responsibility principle</strong> (<strong>SRP</strong>) is a computer-programming principle that states that every <a href="https://en.wikipedia.org/wiki/Modular_programming">module</a> or <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)">class</a><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle#cite_note-cleancode-1">[1]</a> should have responsibility over a single part of the <a href="https://en.wikipedia.org/wiki/Software_feature">functionality</a> provided by the <a href="https://en.wikipedia.org/wiki/Software">software</a>, and that responsibility should be entirely <a href="https://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)">encapsulated</a> by the class, module or function.</p><p>在<a href="https://zh.wikipedia.org/wiki/面向对象编程">面向对象编程</a>领域中，<strong>单一功能原则</strong>（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Supposed we created a notebook which provides a function to add a new note to the notebook and persist all the entries to a file.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoteBook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; entries;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    NoteBook(<span class="keyword">const</span> <span class="built_in">string</span> &amp;title) : title(title) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a note the notebook</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_note</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; note)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        entries.push_back(lexical_cast&lt;<span class="built_in">string</span>&gt;(count) + <span class="string">&quot;: &quot;</span> + title);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//what if you want to let the Notebook to save the entries to a file</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Open a file output steam</span></span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="comment">//write all the note entries to the file</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; entry:entries)&#123;</span><br><span class="line">            ofs &lt;&lt; entry &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Single Responsibility Principle Example&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    NoteBook notebook&#123;<span class="string">&quot;Study Diligently&quot;</span>&#125;;</span><br><span class="line">    notebook.add_note(<span class="string">&quot;We need to understand the principles.&quot;</span>);</span><br><span class="line">    notebook.add_note(<span class="string">&quot;We need to do lots of hands-on work!&quot;</span>);</span><br><span class="line">    <span class="comment">//Single Responsibility Principle is broken</span></span><br><span class="line">    notebook.save(<span class="string">&quot;notebook.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, the <strong>save</strong> function above raises a problem. Sooner in the future, the the system starts to add more media types such as <strong>Journal</strong> and <strong>BookMark</strong>, which has its own <strong>Save</strong> and Load <strong>function</strong>.</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/EECb2t.png" alt="EECb2t"></p><p>Later the product manager decides to save the records into the the database instead of a file system.</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/SHEI1E.png" alt="SHEI1E"></p><p>This migration causes tremendous amount changes of the code because engineers have to go to each sub module, NoteBook, Journal and BookMark to change the <strong>Save</strong> and <strong>Load</strong> function.  To avoid this problem, we essentially use the <strong>seperation of concerns</strong>.(<strong>忧虑分离</strong>)</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/qkzDyf.png" alt="qkzDyf"></p><p>In this example, to resovle this concern, we separate the pesistence functiionality to a third class, call <strong>PersistenceConnector</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersistenceConnector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> NoteBook&amp; noteBook, <span class="keyword">const</span> <span class="built_in">string</span>&amp; filename)</span></span>&#123;</span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="comment">//write all the note entries to the file</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; entry:noteBook.entries)&#123;</span><br><span class="line">            ofs &lt;&lt; entry &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>This is precisely what is meant by <strong>Single Responsibility</strong>: each class has only one responsibility, and therefore has only one reason to</p><p>change. On the other hand, if you wanted to change the persistence mechanic, this would be changed in <strong>PersistenceConnector</strong>.</p><p>Instead of using the <strong>save</strong> function from the <strong>NoteBook</strong> class, we can use the  <strong>PersistenceConnector</strong> to handle hte responsiblity of the persistence. Now, we have the final version of the code with considering the <strong>Single Responsibility Principle</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoteBook</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    NoteBook(<span class="keyword">const</span> <span class="built_in">string</span> &amp;title) : title(title) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a note the notebook</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_note</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        entries.push_back(lexical_cast&lt;<span class="built_in">string</span>&gt;(count) + <span class="string">&quot;: &quot;</span> + note);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//what if you want to let the Notebook to save the entries to a file</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Open a file output steam</span></span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="comment">//write all the note entries to the file</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry:entries) &#123;</span><br><span class="line">            ofs &lt;&lt; entry &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersistenceConnector</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">const</span> NoteBook &amp;noteBook, <span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)</span> </span>&#123;</span><br><span class="line">        <span class="function">ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="comment">//write all the note entries to the file</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry:noteBook.entries) &#123;</span><br><span class="line">            ofs &lt;&lt; entry &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Single Responsibility Principle Example&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    NoteBook notebook&#123;<span class="string">&quot;Study Diligently&quot;</span>&#125;;</span><br><span class="line">    notebook.add_note(<span class="string">&quot;We need to understand the principles.&quot;</span>);</span><br><span class="line">    notebook.add_note(<span class="string">&quot;We need to do lots of hands-on work!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Single Responsibility Principle is broken</span></span><br><span class="line">    <span class="comment">//notebook.save(&quot;notebook.txt&quot;);</span></span><br><span class="line">    <span class="comment">//Instead, we use the PersistenceConnector to handle the persistence.</span></span><br><span class="line">    PersistenceConnector pc;</span><br><span class="line">    pc.save(notebook, <span class="string">&quot;notebook.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>An extreme example of an antipattern that violates the SRP is called a <strong>God Object</strong>. A God Object is a huge class that tries to handle as many concerns as possible, becoming a monolithic monstrosity that is very difficult to work with.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式架构师 重温</title>
      <link href="/2020/06/21/276b/"/>
      <url>/2020/06/21/276b/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><ul><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1G1WUM2CrcWgBzqGdm6yI9diJkeKK0VHv?usp=sharing">C.Primer.Plus (6th,2013.12）Stephen.Prata</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1G1WUM2CrcWgBzqGdm6yI9diJkeKK0VHv?usp=sharing">Primer c++ 第5版</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/13zMrxQ65eBJPEhSxLB3kqGoyLX2dQJwp?usp=sharing">精品C语言 （视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1DfKXd80155dlNEu-btKcBp4dV0-2_kKg?usp=sharing">C语言进阶 （视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1XDY55MEK5HTBjkoGUv3kviwqEi1jwlVC?usp=sharing">C++深入浅出 （视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/13zMrxQ65eBJPEhSxLB3kqGoyLX2dQJwp?usp=sharing">精品汇编课程（视频）</a></li></ul><h1 id="中极篇"><a href="#中极篇" class="headerlink" title="中极篇"></a>中极篇</h1><ul><li><input disabled="" type="checkbox"> Design Patterns in Modern C++： <a href="https://drive.google.com/file/d/1DPp956Entl-S5d4WxvupG5rk5fSRWRwM/view?usp=sharing">Book</a>， <a href="https://drive.google.com/drive/folders/186OtxMC7cAlh_U7i50Nh_o2zXcLndEb9?usp=sharing">视频</a>，<a href="https://github.com/Apress/design-patterns-in-modern-cpp">Code</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1jQnXlUjyoPTe18FpJvcTmzTCDn_GdDXB?usp=sharing">c++系统工程师</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/file/d/1BYehUwOBD1wSxLjHVO35o9FVObVeX2Ib/view?usp=sharing">C++性能优化指南</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/file/d/1UhzXFe-UU7mW2Jcz3EtDeRbyygzNmXSJ/view?usp=sharing">编写高质量代码：改善C++程序的150个建议</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1OpB5dcgvAgIen1xJPnKBqXSj9I-_Cinu?usp=sharing">Linux.Kernel.Fundamentals （视频）</a></li></ul><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><ul><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1A4DFq5jK_iAIuUrr59-NcaCVPO67zIez?usp=sharing">Linux Kernel Development (3rd Edition)</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/file/d/1wsvPulN7v3YtpHe4GytI1NAjj9puGjRU/view?usp=sharing">深入Linux内核架构</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1-HoKu1TecFPOhmQf41XrlrnmKtQtesb-?usp=sharing">Domain-Driven Design - Tackling Complexity in the Heart of Software-Eric Evans 2003 （领域驱动设计：软件核心复杂性应对之道）</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/18YH5qU4V-HzSD5MCzY19t78knLzzTajg?usp=sharing">Implementing Domain-Driven Design-2013（实现领域驱动设计 （美）弗农著）</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/file/d/1pcBkQVEEWWpCU7S1Wx7_NO4iKMEQzjUi/view?usp=sharing">架构整洁之道</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/drive/folders/1YKHzU51TLiH_wnuKVrUNVrpCQv723VMX?usp=sharing">重构_改善既有代码的设计</a></li><li><input disabled="" type="checkbox"> <a href="https://drive.google.com/file/d/1q5rV0QwRNhldtp53Uldvrsh1-qnI6mOi/view?usp=sharing">代码大全</a></li></ul><h1 id="专家篇"><a href="#专家篇" class="headerlink" title="专家篇"></a>专家篇</h1><ul><li><input disabled="" type="checkbox"> linux内核探秘</li></ul><h1 id="选读"><a href="#选读" class="headerlink" title="选读"></a>选读</h1><ul><li><a href="https://drive.google.com/file/d/1hy4oA8ywfnJ1sqd4gT5gDiURDT3WQbOe/view?usp=sharing">Understanding the LINUX Kernel -2001</a></li><li>基于Linux的C++  (NAS 918 Video)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU Mali</title>
      <link href="/2020/06/10/8d33/"/>
      <url>/2020/06/10/8d33/</url>
      
        <content type="html"><![CDATA[<h2 id="GPU-进化"><a href="#GPU-进化" class="headerlink" title="GPU 进化"></a>GPU 进化</h2><p>GPU 方面，最新发布 Mali-G77 GPU 采用了最新的 Valhall 架构，此时距离上一代 Bifronst 架构的发布已经有三年时间，之前的G71一直到G76用的都是BIFROST架构。</p><p><img src="https://www.eet-china.com/d/file/news/2019-05-28/f3b725a6d65a86f428db09393f57a57c.jpg" alt="20190528-arm-cortex-a77-1.jpg"></p><p>新架构带来了全新的ISA和计算核心设计，解决了Bifrost体系结构的主要缺点，性能提升 40%、效能提升 30%，性能密度提升 30%、机器学习性能提升 60%；按照官方的说法，Mail-G77 着力于在移动游戏方面的提升，同时也非常注重 AR 和 VR 方面的应用。</p><p>据称新Mali-G77 GPU的架构，可以让2019年末和2020年的手机GPU性能在工艺不变的情况下提升1.4倍。值得一提的是，Mail-G77 GPU 还可与新的 Mali-D77 显示处理器协同工作。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/xeUxz1.png" alt="xeUxz1"></p><p>从分类来看，<strong>A77和A76同样基于ArmV8.2，也是属于华为获得永久授权的Armv8系列范围内</strong>，按道理说华为拥有自主研发和修改的权力。</p><p>从授权时间来看，SoC产品开发都有一定的流程，首先是原理方案研究，比如选定哪些技术，决定后才会进入产品设计，这时候就要签技术、架构IP授权。因此SoC厂商拿到新设计架构资料的时间一般会远远早于发布会，会提前一到两年，绝不会出现产品都快设计好了还没授权的情况。<strong>按时间点算，华为海思在此前应该已经获得了A77和G77的授权</strong>。</p><p>其实Arm的公版架构一直以来都被诟病，相比高通苹果的自研架构来说性能不尽如人意，这点在前几代的华为麒麟处理器和三星猎户座处理器上就能看出来。特别是公版Mali-GPU，比高通Adreno差得不止一点点。好在后来华为利用软件优化，勉强把麒麟980处理器的GPU游戏性能提升到与骁龙845 Adreno接近的水平。</p><p>据传按照麒麟“发布一代，流片下一代，预研下下一代”的开发节奏，下一代麒麟990处理器已经流片，若也是采用A77和G77新架构，再加上华为自己的优化，搞不好就能胜过高通855的GPU。</p><p>业内有传闻，<a href="https://www.eet-china.com/news/201806201004.html">华为从2014年开始就筹划自研GPU，</a>去年的GPU Turbo技术就震惊业界——原来自研GPU还可以这样玩？其实GPU自研的难度无论从流片还是兼容性上，都远大于CPU。三星目前还在埋头苦干，苹果也是在挖了imagination很多工程师后才搞定。所以我们需要多给国内厂商一些时间，即便是华为，除了自研全网通基带外，SoC的其他核心架构也要依靠授权，不可能实现跳跃式发展。</p><p><img src="https://pic2.zhimg.com/80/v2-5473d8708cc9c59f347c24f4441bfdb9_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 图形技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果失去华为，中国会怎样?</title>
      <link href="/2020/05/28/bda3/"/>
      <url>/2020/05/28/bda3/</url>
      
        <content type="html"><![CDATA[<h2 id="如果失去华为，中国会怎么样-关系到中国国运-组图"><a href="#如果失去华为，中国会怎么样-关系到中国国运-组图" class="headerlink" title="如果失去华为，中国会怎么样?关系到中国国运(组图)"></a>如果失去华为，中国会怎么样?关系到中国国运(组图)</h2><p>新闻来源: 肖磊看市 于2020-05-28 7:30:51 大字阅读 <strong>提示:</strong>新闻观点不代表本网立场</p><p>关于美国以倾国之力来猎杀华为这件事，我看到很多的讨论和分析，但总体来说偏悲观，大部分知识阶层认为中国跟美国在芯片领域的差距太大，美国这种近乎无耻的“无限追溯”，基本上就是“杀不死华为誓不罢休”的节奏，而同时认为中国可用的反制措施有限，从而得出一个结论，美国的强大超乎想象，不要再吹中国厉害了等等。</p><p>当然，乐观派也有很多，把美国对华为的猎杀，看成是一种倒逼的激励机制，一时间也激发了诸多科技工作者、消费者和创业者的情绪，这是一种比较好的现象。</p><p>但我要分析的角度，并不简单的是表明某种立场，因为华为的问题，不是一个简单的企业问题，美国已经将华为的问题，上升到了政治和国家安全的角度，这背后一定是有战略性考量的，中国一定要以同等的支持，来帮助华为脱困，这关系到能否保住中国改革开放成果的问题，也可以说关系到中国国运的问题（别着急反驳，听我慢慢说）。</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>作为全球化的坚定支持者，我个人的消费观念是，谁率先占领我的视野和体验，我就会一直用谁家的东西，直到哪天被某种体验给恶心到了，才会去换掉。华为做手机其实算比较晚的，直到现在我个人依然没有买过华为的手机，也跟华为没有任何利益关系，不存在对华为这家公司有特殊的感情，所以我的分析是基于整个全球发展历史和政治、经济，以及中美问题，而非一家公司或一个产业。</p><p>那华为到底代表着什么呢？</p><p>我给大家举一个例子，比如中国顶级理工科学府清华大学（也是综合性大学），2019年主要就业去向，在大公司里面，华为排名第一，招聘了189人。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/zeGyEr.png" alt="zeGyEr"></p><p>请注意，这个数字接近于第二名至第四名的总和，那第二名至第四名都是什么企业或组织呢，分别是大名鼎鼎的腾讯、阿里巴巴、国家电网、中国建筑集团。而腾讯和阿里巴巴，在清华大学的招聘人数加起来，也只有华为招聘人数的一半。</p><p>如果你再去看看2018年给华为输送人才的大学，你就会发现，全中国最牛的23所理工科类大学，也可以说未来最顶级的中国理工科人才，仅2018年，就有4621名被华为收入麾下。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/q0lV6y.png" alt="q0lV6y"></p><p>华为所代表的，已经不是单纯的一家企业，而是中国人才、科技，以及教育等等综合实力的一个承载、发挥和蓄能池，一旦华为在国际市场失败，意味着中国企业吸引国内顶尖理工科人才的能力将损失惨重，甚至面临灭顶之灾。</p><p>也可以这么说，中国出台那么多吸引高科技人才的行政政策，其实远远比上建立一家像华为一样的科技公司有效。当然，各自有各自的作用，只是如果没有足够优秀的企业，对科技人才的吸引肯定是不可持续的。</p><p>很多人可能会说，华为倒了，还有其他企业呢，请注意，这些科技类人才，不是简单的选择华为的高薪，很多是基于华为的国际化市场和研发体系需求，这种需求给一个人的眼界和发展空间提供了不一样的机会。</p><p>腾讯和阿里巴巴，以及国家电网等等，是无法替代华为的软硬件多领域需求和国际化的。腾讯海外收入占比还不到10%，阿里巴巴海外收入占比也就20%左右，而华为海外收入占比一度接近70%，这几年国内市场起来后国内收入占比有所提高，但国际收入占比依然超过40%。更重要的是，腾讯和阿里加起来的收入，还没有华为高，大部分需求也是服务型人才（最近两年才开始投研发）。</p><p>什么意思呢，意思是说，如果你是一个想走向国际化的科技类顶级人才，中国企业里面，华为可以说是最综合的一个选择，也是承载能力最大的理工科人才池子。而华为一旦失去吸纳这部分人才的能力，那么这些人才至少会有很大一部分，将加盟美国，以及更多其他国家的企业。</p><p>同样的，美国不只是在封杀华为，还在启动对中国理工科输美留学生的限制。因此，美国所实施的，是对中国科技人才从教育、需求、留存到承载体系的全面遏制和封杀。</p><p>大家应该还记得中兴通讯吧，被美国打压之后（2018年4月16日，美国商务部宣布立即重启对中兴通讯的制裁禁令，中兴通讯将被禁止以任何形式从美国进口商品），结果就是，2018年第二季度遭遇了58％的损失，当时中兴通讯的工厂已经停产，随后的第三季度下降了14％，第四季度下降了17％。</p><p>在这样的背景下，中兴吸引科技人才的能力以及对科研的投入立马遭到削减，这种损失不仅仅是企业层面的，还是国家层面，是一种战略性损失。</p><p>如果中兴事件不足以引起重视，此时美国对华为的猎杀，必须要重视了，如果这还不足以引起各个方面的及时应对，那中国失去的就不是一个华为，而是整个建立起来的高科技人才市场化产业链条的崩溃（我并非危言耸听），以及难以挽回的中国企业国际声誉损失，因为这意味着华为无法给全球170多个国家提供稳定的产品和技术服务保障，你让人家怎么看中国企业？</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/qlGxpJ.png" alt="qlGxpJ"></p><p>对于封杀华为，更大的战略威胁是什么呢，当然是遏制和降低中国在科技领域的全球化，永远把中国锁死在中低端加工领域，无法在国际市场获得更大利润，从而进入中等收入陷阱，彻底清除中国对美国各类霸权的战略挑战。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>很多人可能又要问了，一个华为的问题，能上升到国运和“中等收入陷阱”等层面？那好，我们先来看看关于人均GDP1万美元的问题（中等收入阶段）。</p><p>全球来看，目前人均GDP比中国高的只有约11亿人，而全球人口的数量是76亿。</p><p>这是什么意思呢，中国的加入，让全世界人均GDP超过1万美元的人口，增加了130%。</p><p>其实全球人均超过1万美元的国家有很多，总计超过70个，很多国家人均GDP非常高，但主要的原因是人口少，比如卢森堡（人口60万）、冰岛（人口35万）、卡塔尔（人口264万）等，对于中国来说，这些国家的人均GDP并没有参考价值。</p><p>而人口超过5000万的国家里面，人均GDP超过1万美元的国家，只有8个，这里面，除了俄罗斯和韩国，其他都是G7成员，包括美国、德国、英国、法国、意大利和日本。</p><p>人口超过1亿的国家里面，人均GDP超过中国的国家，只有美国、日本、俄罗斯，另外两个墨西哥和巴西跟中国差不多，但去年已经被中国超越。另外，在接近1亿人口的国家里面，土耳其的GDP略低于中国。</p><p>请注意，这会我就要说到关键点了，大家仔细去看，除了韩国之外，其他比中国人均GDP高的人口大国，基本都是百年强国，早在一百年前就开始欺负我们了，即八国联军（除了已经消失的奥匈帝国）。</p><p>这意味着什么呢？意味着一百多年来，除了韩国，整个地球上其他所有想挑战这几个国家人均GDP水平的大型新兴经济体，都失败了。这难道是偶然？难道真的是制度问题？难道是无法抗拒的命运？</p><p>那我们就要问了，中国能成功吗？为什么唯独韩国成功了呢？</p><p>其实在大型新兴经济体里面，有至少三个国家努力尝试赶上众“列强”，他们分别是巴西、墨西哥和土耳其。但经过多轮博弈，这三个国家基本上都被“掐死”在摇篮里了，因为他们都掉入了中等收入陷阱，也就是被锁死在人均GDP1万美元左右这个区间里了。</p><p>那根本原因是什么呢？</p><p>我们分别来看一个指标，比如巴西，拥有8家世界500强企业，但其中两家是石油/天然气公司，一家是肉类加工出口企业，一家是矿业巨头，另外四家都是银行。</p><p>再比如墨西哥，进入世界500强的企业只有4家，一家是石油企业，一家是电信公司，一家是饮料食品企业，一家是风电设备公司。</p><p>不知道大家有没有看出来，巴西进入世界500强的公司，实际上都是资源行业和银行业，这些都是技术含量并不高的垄断行业，还有一家肉类加工出口企业，也主要是因为农业养殖自然条件较好。</p><p>而墨西哥，作为紧挨着美国的国家，为美国做了那么多年代工的国家，在全球500强企业里面，竟然只有一家算得上有一定技术含量的企业，就是那家风电设备公司，大家不觉得奇怪吗？</p><p>相比来说，土耳其的产业相对来说更丰富一些，比如Beko及Vestel都是欧洲知名的家用电子产品与电器制造商，土耳其的建筑承包行业也相当发达，目前也是中国在全球市场的竞争对手之一，另外船舶制造业也很有竞争力，军工方面有F16生产线等。</p><p>但土耳其的问题在于，产业规模不够，进入世界500强的企业只有一家Beko的母公司考奇集团（KOC）。</p><p>那我们再来看看韩国，是如何超越中等收入陷阱，把5000万人口带向发达经济体的。请看下图。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/ZpkBAf.png" alt="ZpkBAf"></p><p> 大家估计一下子就能看明白，韩国有16家企业进入了世界500强，在这些企业里面，我没找到一家纯粹的垄断性能源企业，也没有一家是纯粹的银行，而大部分是科技企业，以及重工业、汽车等制造业，还有三星等高科技企业，这些企业基本上都是靠真正的拼杀闯出来的（背后也离不开国家的支持）。 所以，我想说的是，如果中国想真正跨越中等收入陷阱，不做“八国联军”的垫脚石，被踩死在巴西、墨西哥，或者土耳其这个水平上，那就必须要有真正的，拼杀出来的科技类世界500强企业。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>那我们再回过头来看看中国入围世界500强的企业。</p><p>从去年的数据看，中国（含港台）有129家企业入围世界500强，历史上首次超过美国的121家，位列全球第一。</p><p>但请注意，如果去掉港台企业及银行、保险、电力、电信、煤炭、石化、房地产企业后，就只剩下47家，而在这47家里面，如果除去大型国有企业，以及军工相关企业，真正的靠自身技术和营销等方式打拼出来的市场化企业，只有华为、正威国际、阿里巴巴、联想、吉利、腾讯、魏桥集团、雪松控股、美的、苏宁、青山控股、格力、海尔、小米等14家企业，比韩国少两家。</p><p>然后大家再仔细看看，这14家里面排在第一的是谁，是华为，而且这里面有最多技术的是谁，也是华为。你可能会说，阿里巴巴和腾讯也有很多技术，而且是平台级企业，问题是我已经说过了，阿里巴巴和腾讯国际业务占比远远低于华为，其实也可以看作仅仅是一家内地公司。</p><p>不信你去看，天猫和微信，再加上京东、苏宁，可能都挑战不了亚马逊和WhatsAPP等的地位，因为除了最近一阵子兴起的抖音海外版（Tik Tok），中国这些互联网公司的各类软件，在欧洲等市场，从未进入过下载量的前十，何谈国际影响力？</p><p>也就是说，如果用国际化来衡量的话，中国互联网科技领域，被美国横扫十次都绰绰有余。</p><p>如果再接着分析，魏桥集团、雪松控股、青山控股等，都还是非常传统的产业，而美的、格力、海尔、吉利等本身也是相对传统的产品企业。这就好比很早之前IBM就把个人电脑业务卖给联想一样，就算这类终端产品市场全给中国企业做了，对美国都没有啥威胁，因为操作系统掌握在美国手上。</p><p>那就只剩下三家，一个是正威国际，另外两个是华为和小米。而正威国际是做有色金属的，这个对美国来说也没啥需要特别关注的。所以就只剩下华为和小米，那这两家就不用我做什么对比了，小米虽然国际化也做得不错，但跟华为比起来，还差很多。更重要的是，华为不仅是国际市场占有率高，而且有非常强的技术，并拥有发展成为规模级平台的能力。</p><p>所以，华为必将成为美国围剿的对象，因为干掉华为，相当于阻断了唯一一家中国真正具有全球活跃性竞争力的世界500强高科技企业。</p><p>那么也就意味着，一旦猎杀华为，预示着中国最有可能挑战美国全球科技以及平台布局的中国500强企业，被扼杀了。而华为之后，中国再想创造一个类似的国际化技术平台级企业，恐怕难度就很大了。</p><p>当然，华为死了，地球照样转，问题是，中国想要想靠大型国有企业（基建、能源、银行军工等），以及传统制造业，还有国内市场，来完成中等收入陷阱的跳跃，这种难度是非常大的，其实前车之鉴就是土耳其。</p><p>如果没有华为等公司，中国未来很有可能就会变成一个大号的土耳其，看上去产业较为丰富，比土耳其规模大很多，但更多的支撑因素是国内需求，而非国际竞争力。我虽然也经常强调国内需求的重要性，但国内需求是基本盘，而非真正的中国经济增值来源。</p><p>因此我非常担心，连华为一旦夭折，那中国陷入中等收入陷阱，进入类似土耳其模式的可能性是非常大的，因为这是一个标志性事件，类似于1997年亚洲金融风暴等标志性事件。</p><p>中国之所以比土耳其有更多的世界500强企业，最重要的原因是中国国内规模足够大，但这会被中国更大规模的人口给对冲掉，也就是说，我们跟土耳其的产业非常类似，但我们的人口是土耳其的20倍，所以尽管我们有更多的世界500强，但对人均GDP的支撑非常有限。</p><p>那为什么没有国际化的高科技平台级别的企业，就会陷入“中等收入陷阱”呢？原因也很简单，因为只有国际化的平台公司和技术公司，才可以获得超额利润，才可以带动国内的整个产业链和人均收入的快速抬升。</p><p>如果没有国际市场，单纯国内市场的消耗，实际上是一个内循环，对人均GDP的拉升，其实同时也形成了对等的消耗，这就类似于，中国银行业或基建军工等也赚了很多钱，贡献了很多GDP，但主要体现出来的，是债务的增加，是就业的维持，并不能大幅提升人均回报，不信的话你去看看这些企业的薪资增长、招聘规模等等，都是远远落后于华为等国际化公司的。更深层一点的讨论，实际上就是计划经济和市场经济之间的区别了。</p><p>你再去看看美国，仅仅四大科技企业，苹果、谷歌、亚马逊和微软，其年收入就达到5.5万亿人民币，这四个公司里面，收入最低的微软，都比中国最强的华为高出接近1千亿元。更重要的是，美国这些企业的利润大部分来自全球，而非美国本土。</p><p>如果保不住华为，让华为的国际化止步，那么未来中国各行各业想要再挑战美国无理打压，恐怕难度就更大了，因为华为是一家完全靠自身技术和业务拼杀下来的国际市场地位，是有巨大用户粘性的，这种背景的公司，都扛不住，那还有哪家公司扛得住？</p><p>这对中国企业家的精神和自信都是重大的打击，未来更多的企业家将会更加惧怕美国，只能寻求寄生在美国平台下赚点小钱而已。</p><p>所以，华为的问题，不是简单的一个企业的问题，是足以代表中国能否突破“中等收入陷阱”，能否成为世界一流经济体的问题。一旦失败，中国就存在被遏制在巴西、墨西哥和土耳其这个阶段，成为永远的二流国家的风险。</p><p>大家现在不要觉得这个问题好像没那么严重，其实如果你再回溯几十年，看看土耳其、巴西、阿根廷、墨西哥、马来西亚等等，哪个不是勃勃生机、豪情万丈，现在还不是得接受二流国家、中等收入陷阱的现实。</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>好，那接下来我们再说说，华为到底为什么领衔全球5G，美国又是如何打击企图跨越“中等收入陷阱”国家的，中国应该以什么样的方式破局。 首先我们要搞清楚一个问题，美国为什么在5G领域落后。</p><p>如果要深入的讨论，实际上5G的问题，并不是一个简单的通讯技术的问题，而是一个政治问题。</p><p>我看了很多技术分析，包括频谱的问题，意思是说，美国最早发布了5G高频段（毫米波）频率规划（2016年），但问题是，高频段有非常明显的商用弱点，那就是需要建设更多的基站，是中国中频段的3至4倍，才能达到中频段同等的覆盖能力。</p><p>而美国在实施基站建设方面，其难度又是巨大的，要完成这样的大规模基建，不仅仅是钱的问题，光纤资源、城市管道系统等等对美国都是挑战，而且要跟各州、各地、各企业民众协调，很多人预计要完成这种规模的基站建设，十年恐怕都不够。</p><p>那美国为什么不用中频段呢，原因有两个，一个是中频段有很大一部分被美国国防部控制，但问题是，美国也提出了CBRS计划，即“公民宽带无线电服务”，作为一种辅助技术，可以让美国无线运营商与海军共用3.5GHz频段，极大缓解无线频谱短缺的现状，可是该计划响应者非常少。</p><p>另一个是，美国一直想主导全球5G发展节奏，所以美国的详细规划是，先从高频，再到中频，然后到低频。那这个跟中国直接从中频起步又有什么关系呢，问题很简单，我举个例子，这就好比，美国和中国的房地产，美国主要是郊区独栋为主，而中国是城市高层为主。现在美国要求全球都应该效仿美国，在开发房地产方面，应该先发展郊区独栋，而不能先发展城市高层，这样对美国的建筑商和后期的物业公司等就非常有利，美国也就能主导蛋糕分配了。</p><p>但问题是，全球各国面临的土地和城市发展情况，跟中国更相似，而不是跟美国，所以在城市发展高层建筑的模式就迅速被推广开了，美国则还停留在不紧不慢的制定独栋别墅建设标准的阶段。</p><p>按理说，各发展各的也可以啊，问题在于，全球大部分国家已经都默认中频为5G主流商用频段，而且发展迅速，美国对5G发展的主导权已经丧失。</p><p>那美国有没有可能会夺回对5G的主导权呢？</p><p>有一种可能，那就是让全世界的5G发展，跟美国同步，也就是等美国从高频段，慢慢发展到中频段（可能得10年的时间），然后就同步了。所以现在很多人认为，美国对华为的封杀，也是为了延缓其他国家5G的商用步伐。</p><p>我当然不同意这种看法，因为这不是美国真正的目的。</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>中国近十多年的发展，是比较快的，快到什么程度呢，全球几乎没有几个人能预测到。</p><p>可能我这么说你还是会觉得怪怪的（又在吹了），那我给你举个简单的例子，比如2005年，中国领导人提出的目标是，到2020年，也就是到现在，中国人均GDP要突破3000美元。</p><p>那当时中国的人均GDP是多少呢？只有1700美元。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/tAyDiy.png" alt="tAyDiy"></p><p> 也就是说，在过去15年里，中国的发展计划是，将人均GDP推升76%，结果呢，中国人均GDP涨了接近6倍，因为去年中国人均GDP已经突破了1万美元。</p><p>与此同时，中国也成长起来了一批国际化的公司，比如最典型的就是华为，所以华为的发展，其实跟中国经济的发展一样，是所有对手始料未及的。</p><p>当下美国封杀华为，其实跟遏制中国经济崛起是同一个目的之下的不同执行层面，逻辑上是一致的。只不过中国由于体量有点大，影响力也都起来了，所以美国要想把中国打入“中等收入陷阱”需要作出的努力可能会更大，因此现在大家看到的就是，由于用力过猛，美国的动作有点“变形”，而在遏制其他相对体量较小的挑战者方面，恐怕一次金融危机就足够了，甚至没人能看出来。</p><p>大家再想想，中国这种速度的发展，如果连我们自己都没有想到，一直看不起我们的竞争对手会想到吗？当然，可能有那么一两个疯狂的预言家会想到（比如很多人动不动就引用所谓拿破仑说的“中国是一头沉睡的雄狮,一旦醒来就会震惊世界”这类言论），但这并不会成为对手关注我们的依据。</p><p>所以，过去十多年里，美国在对待中国的问题上，其实还处在战略观察阶段，美国知道中国未来肯定会成为一个强国，但会不会成为美国霸权的挑战者，还不好说，中国崛起的时间也可能会比较长，美国对中国进入中等收入阶段的预估是2030年（晚了十年），而且也需要诸多的条件来助力，中国现在还难以满足这些条件（比如好的“制度”等），这样的话，美国有足够的时间去中东搞事情的。 然而，转眼间，中国的人均GDP已经达到了1万美元，成为全球第二大经济体。更重要的是，中国经济的发展，并不是在美国所期望的制度下完成的。</p><p>当然，光拿出人均GDP数据，对于很多人来说，可能并不觉得有什么政治意义。那我要告诉你的是，当上个世纪80年代初，日本人均GDP达到1万美元的时候，美国发起了对日本企业的疯狂打压，包括对丰田汽车等的各种绞杀。同时美国出现了反日情绪。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/9Elmg2.png" alt="9Elmg2"></p><p>到了1985年（日本人均GDP是11500美元，跟今天的中国基本一样），美国直接强制日本签署“广场协议”，要求日元升值，来打压日本的出口，刺激日本对美国的投资，结果日元在而后的六年里，对美元升值了超过4倍，日本人到处买美元，然后疯狂的去美国炒楼炒股，把此前多年赚来的钱都投向了美国，一时间美国人感叹，日本要买下整个美国了。</p><p>结果就是，在高潮之后，美国迎来了新一轮的发展期，而日本很快陷入了“失去的二十年”。当然，关于这一点，有很多争论，到底日本有没有失去二十年，失去二十年的原因是什么，众说纷纭，但有一点是肯定的，看一下日本房地产和股市的走势，就知道失去的二十年并不是危言耸听。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/yWcSoD.png" alt="yWcSoD"></p><h2 id="日本失去的二十年"><a href="#日本失去的二十年" class="headerlink" title="日本失去的二十年"></a>日本失去的二十年</h2><p>到了上个世纪九十年代末，亚洲的韩国、马来西亚、泰国等国家，陆续奔向人均GDP1万美元的时代。比如到了1997年，韩国人均GDP1.5万美元，马来西亚人均GDP1.2万美元，泰国人均GDP也超过了7000美元。于是，1997年亚洲金融风暴来了。</p><p>那1997年亚洲金融风暴的后果是什么呢，美元迅速从亚洲市场逃离，高速发展的东南亚经济突然陷入崩溃边缘，直到现在，泰国和马来西亚的人均GDP，还处在跟1997年一样的水平上，失去了不止二十年。</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>那美国具体得到了什么呢？</p><p>大家可以去看看美国股市的走势，从跟日本签署《广场协议》，到1997年亚洲金融危机，美国股市一直在上涨，尤其是在1997年亚洲金融危机之后，美股由于涌入的资金巨大，诸多高科技企业获得了前所未有的估值，研发投入大幅增长，以至于搞出了纳斯达克世纪泡沫，酝酿出来了谷歌、微软、亚马逊等等巨型公司，至今称霸全球。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/iazUDR.png" alt="iazUDR"></p><p>大危机与美国股市走势</p><p>很多人可能不太理解，为什么1985开始的日元升值，和1997年东南亚开启的本币贬值，都使得美元涌入美国呢？原因很简单，在货币这个问题上，其实大家担心的不是升值或贬值，而是波动。</p><p>只要一个国家的货币，出现巨大的波动，无论是升值还是贬值，都会给民众带来不安全感，出现“处置”冲动。这就好比一个人，有时候对你特别好，有时候威胁要杀了你，你的最好选择是，远离他。</p><p>如果你去看美国股市走势，在1985年没有签署《广场协议》之前，道琼斯工业指数长期徘徊在1200点左右，协议签署后由于日本市场资金的涌入，该指数迅速上涨，以至于涨得太快了，发生了1987年的股灾，但很快恢复。再加上1997年亚洲金融风暴导致的韩国等东南亚资金的涌入，道琼斯指数从1985年的1200点，涨到了2000年的接近12000点，涨了10倍。</p><p>2000年之后的美国股市，基本没有什么大的起色，2000年到2007年，道琼斯工业指数仅仅从接近12000点，涨到了14000点，七年里只涨了不到20%。</p><p>最近十年，美股也出现了历史上最长的牛市，但大家不知道的是，这一轮美股的上涨，另一个重要的原因是，2010年欧债危机爆发，欧洲资金向美国涌入，再加上2014年至2016年，中国尝试放开外汇管制，人民币迅速贬值，中国外汇储备两年流失超过1万亿美元，把美国股市推向了新高潮。道琼斯指数从2010年的不到1万点，涨到了今年年初的接近3万点。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/BQ1y3y.png" alt="BQ1y3y"></p><p>欧元和人民币两次大贬值后美股走势 很多人可能又要反驳了，这种逻辑分析属于阴谋论，美国股市的上涨，并不是因为其他国家的危机，而是美国有全球最好的企业。</p><p>这一点我也是承认的，但问题的关键点不在这里，问题的关键点在于，为什么只有美国可以缔造出那么多全球企业呢？当风险来临时，美元反而不跌反涨呢？难道欧洲国家的制度，也都不如美国？</p><p>我的观点是，自二战后，欧洲传统强国被削弱，亚洲更惨，人类逐步进入了新的起点，可以说世界被再一次推平了，成了一张白纸，而这个时候唯一的获胜者，是美国。世界开始任由美国“设计”，而美国所执行的是平台战略，只要参与到这个平台里面，就成了美国的一颗棋子，未来只能任其调拨，来配合美国的本土利益。</p><p>在平台战略方面，我不用多说了，美国的军事系统、美元系统、互联网系统，其实都是平台型的，一旦加入这些平台，再想离开，成本巨大，美国就有能力控制所有加入这个平台的国家和企业，以及民众。</p><p>比如一旦加入美国的军事系统，那么你就必须基于美国的卫星定位、情报、指挥等系统来发挥军事战略，基本上你自己就失去了独立做战和离开美国保护的能力。</p><p>而一旦加入美元系统，你就必须要承受美元的“自由流动”，也就是说，当美国本土需要美元的时候，美国有一百种办法让美元回流，而当美国要输出美元的时候，也会有一百种办法让美元流向全世界，但这种流动对很多国家造成的剧烈波动，只能被动承受。</p><p>至于互联网系统，那威力就更大了，这种平台战略，看上去兴起的时间较短，但整个系统，是美国为了打造军事情报共享平台，才发明出来了阿帕网，这就是整个现在互联网的前身，所以说，现在的互联网系统平台，对于美国来说，只不过是军事和美元等系统的一种延续罢了。</p><p>比如微软操作系统、苹果系统、谷歌安卓、GMS系统等。其实这次美国封杀华为，对华为现实威胁最大的，还不是芯片，因为芯片问题，有很多巧妙的解决办法，但如果不让华为使用谷歌的GMS系统（没有这个系统很多软件没法下载），那么意味着华为的手机在国际市场可以说就卖不动了，这就好比说，在中国，你买的手机不能装微信和支付宝，那你还会买这个手机吗？</p><p>所以，美国实际上并不担心一个国家一款产品的领先，就像阿里巴巴，是不会担心格力空调或茅台酒在各自的行业技术或品牌上领先的。美国担心的是挑战自己所搭建的平台。</p><p>华为对美国真正的威胁正在这里，华为是一家随时都可以打造平台的公司。比如在无法使用GMS系统之后，华为就用上了自己研发的HMS系统，但正是因为没有使用GMS系统，华为手机在欧洲的销量下降了超过30%。如果换做其他厂商，可能直接就死掉了。 </p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p> 那美国这种平台战略，就没有漏洞和缺点吗？</p><p>其实对于美国来说，其平台战略，有其无与伦比的优势，但也有战略性的弱点。如果打造平台的国家/公司，开始采取不公平的手段，那么平台的信誉也就会出现战略性滑坡。</p><p>举个例子，还是阿里巴巴，如果阿里巴巴在卖空调这个问题上，对格力特别支持，但对其他空调品牌采取打压措施，那意味着平台已经介入到了产品领域，这个时候其他产品只能自建平台渠道，而放弃原有平台，因为没有其他选择。</p><p>如果美国为了政治需求，把美国的各类平台，用来打压具体的产品方，比如禁止谷歌、微软等企业，向中国的企业提供系统支持等，这看上去很致命，但从战略上来说，这就失去了平台的本身的战略定位。当裁判随时会变成运动员的时候，你还会参加这样的比赛吗？</p><p>很多人可能又要说了，那美国就是要这样打击你呢，你如果不妥协让步，还能怎么办呢？中国人难道还能不用微软、苹果ios、谷歌安卓GMS等系统？</p><p>我可以告诉大家，美国如果禁止中国使用这些系统，反而可能是中国的机会。</p><p>道理很简单，因为很多事情，必须要在极端的情况下才能完成。就像美国要打阿富汗，如果不发生911恐怖袭击，美国人是不会支持美国政府打阿富汗的。</p><p>同样的道理，如果美国不能彻底禁止中国企业对微软、苹果、谷歌等公司系统的使用，那么中国永远都无法拥有搭建自己系统的机会，因为市场没有人支持。</p><p>另外，中国是唯一可以撑起新平台系统的国家，因为中国有足够的内部市场规模。也可以这么说，在搭建互联网系统这方面，美国唯一的对手是中国。比如在卫星导航领域，欧洲需要联合起来（伽利略系统）才能对抗美国，俄罗斯有一定的实力（格洛纳斯系统），但也仅仅是卫星导航等国防领域。如果是互联网系统领域，欧洲和俄罗斯一个缺乏统一的管理，另一个缺乏人口规模，所以在大型制造业领域，欧盟和俄罗斯尚可称得上美国对手，到互联网领域，基本就歇菜了，就只剩下中国了。</p><p>诺基亚手机以前收购开发了塞班操作系统，很快就被苹果和谷歌的操作系统打败，也包括诺基亚的手机业务也基本上算失败了，其实最根本的原因是，诺基亚这家企业，没有“基本盘”，一旦国际市场竞争失败，就彻底失败了。而华为等企业，还有中国内部市场这个基本盘支撑。</p><p>比如诺基亚是芬兰的企业，而芬兰总人口只有550万人，所以诺基亚必须得依靠国际市场，一旦国际市场被打败，其实就相当于彻底失败了，因为国内需求支撑不了诺基亚手机和塞班系统。诺基亚现在只剩下通讯硬件业务了，其市值跟顶峰时期相比，缩水了95%。</p><p>而中国不同，中国的国内用户基数超过10亿，华为这样强大的国际化企业，依然有数亿的用户来自中国。在这种背景下，华为仅仅依靠中国市场，都可以很好的活下去，这对于华为来说，就有了足够的时间打造和培育自己的系统，比如完善HMS系统生态，逐步让国际市场接受。</p><p>很多人可能又要说了，国际主流依然是谷歌的GMS系统，HMS想替代谈何容易，这一点我不否认，但我会告诉你另一个重大机会。</p><p>你知道红军长征是如何在蒋介石几十万大军眼皮底下活下来的吗？其中一个原因是，四川、贵州、云南等各军阀与蒋介石之间，本身就存在着巨大的底层矛盾。</p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>大家可以去欧洲市场看看，欧洲市场现在销售额前五的手机，三星排第一，华为排第二，苹果只是第三。而自从华为手机销量下降以来，小米和OPPO在欧洲的销量大增。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Bklx9e.png" alt="Bklx9e"></p><p>我跟大家说这个，并不是说华为丢失的份额，被小米等中国手机厂商给补回来了那么简单。大家有没有想过，为什么欧洲人其实也很愿意选择苹果之外的手机呢？</p><p>这其实不是简单的性价比的问题，而是欧洲目前面临的情况跟中国类似。大家知道英国和美国正在举行自由贸易谈判，两国的重大分歧在于，英国要向美国互联网巨头征收数字税的问题。</p><p>其实法国和德国也是一样的，美国的互联网科技公司，用平台和系统，一样绑架了整个欧洲的互联网科技领域。从电脑、手机的操作系统，到聊天、社交等等软件工具，全部被美国的科技巨头垄断，欧洲非常希望有第二种选择，这样就可以留有一定的后路，但美国似乎不会允许平台级别的第二种选择出现在欧洲。</p><p>可能大家还不知道，在美国不厌其烦的骚扰下，也就是美国天天给法国、德国、英国等灌输华为5G会影响国家安全等背景下，欧洲这几个大国里面，还没有一个领导人反对华为参与5G建设的。</p><p>所以在5G和手机软硬件等领域，欧洲精英人群表面上跟随美国的舆论步伐，对美国提出的问题很重视，但在行动方面，非常清楚选择芬兰、韩国、中国等企业的战略意义。</p><p>假设华为的HMS系统生态真的能慢慢发展起来，欧洲人肯定是可以选择的，但现在的问题是，国际市场的各类必要性软件（APP），也都是美国公司提供的，比如WhatsApp、Messenger、推特、脸书、Youtube、Netflix等等。</p><p>这个时候华为是很无助的，如果微信、新浪微博、优酷等等，能够在欧洲占有一席之地，其实华为要推HMS系统就没那么难了。</p><p>所以华为现在是孤军奋战。也就是说，华为的HMS要获得些许成功，还需要将全球数百万家APP运维企业纳入生态。这是一个极其漫长的过程。</p><p>其实美国不仅在封杀华为，还在企图鼓动各市场封杀中国的APP，包括抖音海外版TikTok，理由如出一辙，认为TikTok是国家威胁。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/a99CAx.png" alt="a99CAx"></p><p>据Sensor Tower发布的报告称，TikTok全球下载量超过 7 亿，是 2019 年下载量第二大的应用。这意味着TikTok击败了Facebook((下载量不到 7 亿))和Facebook Messenger (下载量略超过 7 亿)。 但我们再来看看欧洲，TikTok已经在德国取得成功，德国网红、明星、足球俱乐部等等都建立了TikTok账号和各类跟TikTok的合作。法国数十家媒体在TikTok建了账号，有法国女孩在TikTok的粉丝超过2000万。上周，字节跳动宣布将在英国伦敦设立TikTok欧洲业务中心。</p><p>那为什么欧洲在对待中国高科技和互联企业方面，跟美国有如此之大的反差呢？</p><p>大家还记得任正非有一次在接受采访时，被拍到在办公桌上有本《美国陷阱》吗？里面就是讲美国是如何肢解掉法国电信巨头阿尔斯通公司的。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/M0Zz8h.png" alt="M0Zz8h"></p><p>​                                                                                                任正非办公桌</p><p>德国也非常清楚，美国是如何对待德国的汽车企业，以及德意志银行的。欧洲各国也都非常清楚，当年为什么要几个欧洲国家联合起来成立空客，来应对美国对欧洲飞机企业的打击的。</p><p>所以，欧洲也非常清楚美国目前打压中国企业的真正战略意图，所以，按照我的推测，只要中国等国家能够提供新的可用系统和平台，以及各类产品，可以满足欧洲要求的话，欧洲其实从潜意识里，是愿意有多个选择存在的，并支持美国以外的系统平台或产品的。</p><p>因为欧洲跟美国一下一轮的重点博弈，就是科技巨头的数字税问题。欧洲也不会允许美国科技巨头大量的赚欧洲的钱，最后还给欧洲搞社交媒体攻势，动不动就来个“黄背心”运动。这种压力欧洲精英也越来越感到难受，只是欧洲暂时还没有第二种选择，跟美国叫板缺乏筹码。 因此，只要中国这次能够帮助华为突围，全球市场对中国企业的信心就会更足，中国各类产品在欧洲的占有率只会上升。相反，如果华为无法突围，我可以很有把握的说，欧洲立马就会对美国进行妥协，很有可能会调转枪头跟随美国的步伐来遏制中国的企业，因为如果当欧洲看不到中国可以提供稳定的产品和第二套可选择的系统，欧洲其实也就只能依靠美国的平台了，大树底下好乘凉。</p><p>说到这里，大家应该可以感受到，我为什么要说，保住华为，就是为了保住改革开放成果的原因。这里面能否守住经济利益，其实也是能否兑现政治利益的问题。</p><h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><p>最后再说一下芯片的问题。</p><p>说实话，我从来不担心芯片的问题，因为芯片是一个纯技术的问题，而不是像微软、谷歌、苹果这种直接面对数亿终端的平台或系统渗透的问题。</p><p>中国的优势就是集中力量突破重要领域和环节，只是我们此前的集中力量，用在了国防等领域，时间上出现了错位，毕竟整体资源是有限的，发展阶段是不一样的，而且芯片市场本身一直就非常市场化，全球各个国家嵌入很深，如果没有发生极端的倒逼，资源难以长期聚集来搞非优势产业。</p><p>你看中国的国防科技，如果不是各种严格的封锁，以及各种赤裸裸的军事威胁，比如核打击威胁、现实战争、炸大使馆、撞机等等，中国也是能买就买的，关键是人家不卖给你，你没有就可能面临亡国风险，所以才有了核技术、导弹技术、卫星技术、歼20、055大驱等等。</p><p>芯片的问题是，美国一直叫喊，但一直卖给你，而且当你买得稍微慢一点的时候，就赶紧威胁要制裁你什么的，然后中国企业就赶紧利用窗口期囤货，不计成本的使劲买一把，美国芯片相关企业就又可以弄一个很好的季度财报，然后股价再推一波。</p><p>现在很多人说，中国跟美国的芯片行业差距至少10年，面对美国的卡脖子，中国一点办法都没有。</p><p>那我的问题是，如果中国一点办法都没有，只能认输的话，美国为什么不一次性直接卡死华为呢？难道美国不想让华为消失？请注意，美国是拿着国家安全理由来打击华为的，那还不一下子整死，留着威胁美国安全？还记得前一阵美国是如何猎杀伊朗军事人物苏莱曼尼的吗？如果有可能将对手置之死地，美国绝不会选择放生的。</p><p>这次的“无限溯源”，也没一下子全禁止啊，美国还顾虑什么呢？很简单，美国在芯片领域要一下子干死华为，必须要出台非常无理的封杀条件，比如只要是使用了美国技术或产品，从而加工出来的芯片，都不允许出售给华为。但那是不是说，我芯片加工厂，用的一个螺丝刀，厂房里吹的空调，员工上班来开的汽车，都不能有美国的技术呢？这么追溯下去，那中国还有四大发明呢。</p><p>美国知道自己这种“无限溯源”的招数很搞笑，所以出台了一个，只要是各代工厂和核心设备，其使用的美国技术不能高于10%，如果比10%高，就得征得美国的同意才能跟华为合作。</p><p>说到这里，其实我想问一句，如果美国把封杀华为的要求升高到了，只要占美国技术10%就得禁用（此前的制裁要求是25%，结果发现加工企业很快就把对美国技术的依赖给降低了），那是不是也说明，其他90%的技术都可以跟美国无关？这其实令我很惊讶的。</p><p>而我了解到的是，很多领域美国技术占比之所以超过10%，不是因为没有替代，而是惯性选择。按照此前传出的台积电经过内部审核， 7 纳米制程的美国技术占9%，一些技术依然可以使用比如日本韩国等其他替代来进一步降低对美国技术的依赖。其实现在就只剩下一个光刻机的问题，这就是纯政治的问题了，因为最好的光刻机是荷兰的，使用了美国的部分技术。</p><p>那什么是政治问题呢？</p><p>在这个高度嵌入和全球化的时代，美国也没有只能杀死对方，而自己不受损的工具。如果双方走向极端，中国很大的可能也是被迫去美国产品化，高通、思科、苹果、波音等企业将会遭遇中国严厉的制裁或调查。这就要看谁的损失更大，谁更难以承受了。</p><p>一个国家的崛起，尤其是想摆脱“中等收入陷阱”，绝对不是一帆风顺的，也绝对不是只有掌声和鲜花的，这就好比，当病毒来临，隔离抗疫就是唯一的选择，很多人也都失业了，但你还是得必须挺过去，因为挺不过去，命可能都没了。同样的道理，当美国对华为的封杀来临时，战胜这种流氓行为，就是唯一的选择，要做好付出代价的准备。</p><p>很多人可能会说，那后果还不是老百姓承担吗？请注意，如果我们没有做好全民付出代价的反击决心，任由美国狙击华为，现在看跟自己无关，但未来你就会发现，你的工作机会同样在减少，你所购买的东西还会不断的涨价，你的生活品质不升反降，国际社会开始嘲笑你，就像现在“调侃”俄罗斯、巴西、墨西哥、土耳其等掉入中等收入陷阱的国家一样。</p><p>举个例子就是，当年日本占我东北，华北觉得没事，南方的蒋介石觉得可以忍受（不抵抗），很多人还不怀好意的议论一下东北同胞，但接下来就是华北、就是上海、南京。此时顶不住美国对华为的进攻，跟当年丢失东北道理一致。只不过这次丢失的，可能是改革开放以来获得的综合成果。</p><p>那如果顶住了呢？</p><p>我再跟大家举个例子，比如除了光刻机，芯片加工领域另一个核心设备叫刻蚀机，这个设备此前也遭遇美国的封锁。但自从中国的16nm刻蚀机量产运行，美国立马就解除了对中国刻蚀机的封锁，目前中国5nm刻蚀机已经获得批量订单。</p><p>也就是说，如果顶住了，就是战役的转折点，就是胜利，就是世界的尊重（包括美国），就是更大的生存空间，就是突然间冒出来更多的盟友。难道没有比这更值得争取吗？</p><h1 id="10"><a href="#10" class="headerlink" title="10"></a>10</h1><p>按照美国各类顶级智库最近发出的报告来看，未来全球将演变为两套科技标准和不同的操作系统，这是必然趋势。</p><p>中国国内企业应该早做准备，这种危机，也意味着前所未有的机会。发达国家的人口不过9亿，中国所能提供的物美价廉的产品，可以覆盖中国乃至发展中国家至少三十亿的人口，这就是中国重新打造系统，农村包围城市的基础。</p><p>未来中国制造的手机等，完全可以搭载自己的操作和应用系统，以非常低廉的价格销售到发展中国家（希望中国的各互联网企业和各团队通力合作）。美国当年就是利用自身运营商系统，利用合约机的低价模式（美国98%的手机销售是合约机），也就是每月固定缴纳少量话费，就可以拿走手机，来完成了对美国系统的支撑和全球扩张的。</p><p>那为什么只有中国制造可以席卷更多发展中国家市场呢？道理也很简单，发达国家没有足够的制造业规模来降低成本。</p><p>我再跟大家举个例子就明白了，比如平衡车这个技术是荷兰人发明的，但荷兰人造出来一台要卖6万美元，结果没人买，公司倒闭后就把技术转给了美国人，而美国人造出来是3万美元，依然没有人买，最后干不下去了，把技术转给了中国的小米，结果小米把价格降到了一千多人民币（现在年销量数十万台，全球第一）。</p><p>如果中国不利用这种硬件价格优势，赶紧在发展中国家培植自己的软件系统，那留给中国的时间窗口就不多了。迫切的现实是，全球依然有三分之一的人没有手机（约25亿人），就算有手机的地方，用价格更低的硬件来换取用户对新的系统的支持，也是可以做到的。</p><p>如果你硬要说低价策略没有用，那是因为你所了解的世界，依然停留在被9亿发达人口洗脑的世界。我举一个我们身边的例子，比如以农村包围城市低价策略起步的拼多多，现在市值几乎跟京东相当。而跟京东的刘强东相比，你甚至可能都不知道拼多多的创始人是谁，你不觉得这很颠覆吗？</p><p>正是因为我们被发达国家洗脑时间太长了，近两百年来工业革命等的冲击太大了，所以对人类几千年的历史纵深失去了敬畏，失去了运用，所以你看，两百年来，发达国家依然还是那么几个，他们对待世界的态度几乎都没变过（比如美国现在对华为），以至于当我们可能掉入中等收入陷阱，当我们被发达经济体打压的时候，还反过来还要卑贱的告诉自己，发达国家之所以发达，是有原因的，我们之所以落后挨打，也是有原因的，就差说出“认命”二字了。</p><p>需要继续强调的是，我最担心的不是芯片问题，而是系统问题。就好比现在华为更苦恼的，也并非单纯的芯片问题，由于无法替代谷歌GMS系统，从而导致海外手机销量大幅下滑，这才是华为最致命的，因为这是面对数亿人的终端，这种渗透不是简单的砸钱就能换来的。</p><p>关于芯片领域，中国目前在芯片制造总计七个环节，全部23个细分方向，都实现了零的突破，其中至少有十个领域全球市场占有率接近或超过10%。</p><p>在芯片领域，反而我更担心美国（别笑），一旦这些领域都被中国攻克（中国诺一定会攻克），芯片市场可能又要进入“白菜价”了。到时候遭遇困境的，可能就不是中国企业了，美国又得失业一部分工人、流失一部分人才，然后又说是中国抢走了他们的工作。但到了那个时候，美国还有什么技术可以封锁中国呢？</p><p>最后，作为个人对华为的支持，我的下一部手机将会换成华为（我现在用的是苹果7Plus，已经用了好几年了），无论其搭载什么样的技术，就算体验倒退三年，我都接受。不管未来华为会变成什么样的企业，会犯什么样的错误，但这跟当下支持华为突围并不冲突。</p><p>前不久，英国前首相布莱尔（典型西方价值观捍卫者）罕见的对中国做了一下评论，一方面布莱尔承认全球已经离不开中国，承认中国已经拥有很大的实力，但同时布莱尔指出，现在全球担心的是，中国会如何使用这种力量。</p><p>那中国是如何回应的呢？</p><p>而后的中央政治局常委会，明确指出，中国要发挥新型举国体制优势，加强科技创新和技术攻关，强化关键环节、关键领域、关键产品保障能力。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Voimdq.png" alt="Voimdq"></p><p>我想，中国新型的举国体制，也就是对自身力量的运用，不仅要体现在抗击疫情，以及攻克关键领域技术难题上，还要用在保卫改革开放三十年的发展成果上。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object-Relational Impedance Mismatch</title>
      <link href="/2020/05/25/3cd2/"/>
      <url>/2020/05/25/3cd2/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.agiledata.org/essays/objectOrientation101.html">Object-oriented technology</a> supports the building of applications out of objects that have both data and behavior. <a href="http://www.agiledata.org/essays/relationalDatabases.html">Relational technologies</a> support the storage of data in tables and manipulation of that data via data manipulation language (DML) internally within the database via stored procedures and externally via SQL calls. Some relational databases go further and now support objects internally as well, a trend that will only grow stronger over time. It is clear that object technologies and relational technologies are in common use in most organizations, that both are here to stay for quite awhile, and that both are being used together to build complex software-based systems. It is also clear that the fit between the two technologies isn’t perfect, that there is an “impedance mismatch” between the two.</p><p>In the early 1990s the differences between the two approaches was labeled the “object-relational impedance mismatch”, or simply “impedance mismatch” for short, labels that are still in common use today. <strong>中文：“对象与关系的抗阻的不一致性”。全称为“面向对象编程与关系型数据库间的不一致”。</strong>Much of the conversation about the impedance mismatch focus on the <a href="http://www.agiledata.org/essays/impedanceMismatch.html#TechnologicalImpedanceMismatch">technical differences</a> between object and relational technologies, and rightfully so because although there are <a href="http://www.agiledata.org/essays/impedanceMismatch.html#DeceptiveSimilarities">deceptive similarities there are also subtle yet important differences</a>. Luckily, there are <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Strategies">strategies for overcoming the O/R impedance mismatch</a>.</p><h2 id="1-The-O-R-Impedance-Mismatch"><a href="#1-The-O-R-Impedance-Mismatch" class="headerlink" title="1. The O/R Impedance Mismatch"></a>1. The O/R Impedance Mismatch</h2><p>Why does this impedance mismatch exist? The object-oriented paradigm is based on proven software engineering principles. The <a href="http://www.agiledata.org/essays/relationalTheory.html">relational paradigm</a>, however, is based on proven mathematical principles. Because the underlying paradigms are different the two technologies do not work together seamlessly. The impedance mismatch becomes apparent when you look at the preferred approach to access: With the object paradigm you traverse objects via their relationships whereas with the relational paradigm you join the data rows of tables. This fundamental difference results in a non-ideal combination of object and relational technologies, although when have you ever used two different things together without a few hitches?</p><p>To succeed using objects and relational databases together you need to understand both paradigms, and their differences, and then make intelligent tradeoffs based on that knowledge. <a href="http://www.agiledata.org/essays/relationalDatabases.html">Relational Databases 101</a> overviews relational databases and <a href="http://www.agiledata.org/essays/dataModeling101.html">Data Modeling 101</a> describes the basics of data modeling, providing you with sufficient background to understand the relational paradigm. Similarly <a href="http://www.agiledata.org/essays/objectOrientation101.html">Object-Orientation 101</a> overviews object-orientation and the UML, explaining the basics of the object-oriented paradigm. Until you understand both paradigms, and gain real-world experience working in both technologies, it will be very difficult to see past the deceptive similarities between the two.</p><h2 id="2-Deceptive-Similarities-Subtle-Differences"><a href="#2-Deceptive-Similarities-Subtle-Differences" class="headerlink" title="2. Deceptive Similarities, Subtle Differences"></a>2. Deceptive Similarities, Subtle Differences</h2><p>The easiest similarity/difference to observe is the different types in object languages and in relational databases. On the subtle side, Java has a string and an int whereas Oracle has a varchar and a smallint. Although values are stored and manipulated differently, it’s fairly straightforward to convert back and forth and DB access libraries such as JDBC handle them automatically. However, on the not-so-subtle side Java has collections whereas Oracle has tables, clearly not the same concepts. Oracle has blobs whereas Java has objects, once again clearly not the same concepts.</p><p><a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure1PDM">Figure 1</a> depicts a physical data model (PDM) using <a href="http://www.agiledata.org/essays/umlDataModelingProfile.html">UML data modeling notation</a>. <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure2ClassModel">Figure 2</a> depicts a <a href="http://www.modelingstyle.info/classDiagram.html">UML class diagram</a>. On the surface they look like very similar diagrams, and on the surface they in fact are. It’s how you arrive at the two diagrams that can be very different.</p><p><strong>Figure 1. A physical data model (UML notation).</strong></p><p><img src="http://www.agiledata.org/images/impedanceMismatchPDM.gif" alt="img"></p><p>Let’s consider the deceptive similarities between the two diagrams. Both diagrams depict structure, the PDM shows four database tables and the relationships between them whereas the UML class diagram shows four classes and their corresponding relationships. Both diagrams depict data, the PDM shows the columns within the tables and the class model the attributes of the classes. Both diagrams also depict behavior, the <em>Customer</em> table of <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure1PDM">Figure 1</a> includes a delete trigger and the <em>Customer</em> class of <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure2ClassModel">Figure 2</a> includes two operations. The two diagrams also use similar notations, something that I did on purpose, although the UML data modeling notation is little different than other industry notations.</p><p><strong>Figure 2. A UML class model.</strong></p><p><img src="http://www.agiledata.org/images/impedanceMismatchClassDiagram.gif" alt="img"></p><p>Differences in your modeling approaches will result in subtle differences between your object schema and your data schema:</p><ul><li>By considering both data and behavior in the class diagram the modeler created a different structure than in the data model that only considered data</li><li><a href="http://www.agiledata.org/essays/dataNormalization.html">Data normalization</a> in <a href="http://www.agiledata.org/essays/dataModeling101.html">data modeling</a> versus <a href="http://www.agiledata.org/essays/classNormalization.html">class normalization</a> in <a href="http://www.agiledata.org/essays/objectOrientation101.html">class modeling</a></li><li>The application of data analysis patterns (<a href="http://www.amazon.com/exec/obidos/ASIN/0932633293/ambysoftinc">Hay 1996</a>) versus object-oriented analysis patterns (<a href="http://www.amazon.com/exec/obidos/ASIN/0201895420/ambysoftinc">Fowler 1997</a>; <a href="http://www.ambysoft.com/buildingObjectApplications.html">Ambler 1997</a>) and design patterns (<a href="http://www.amazon.com/exec/obidos/ASIN/0201633612/ambysoftinc">Gamma et. al. 1995</a>)</li></ul><p>There are differences in the types of relationships that each model supports, with class diagrams being slightly more robust than physical data models for relational databases. This is because of the inherent nature of the technologies. For example, you see that there is a many-to-many relationship between <em>Customer</em> and <em>Address</em> in <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure2ClassModel">Figure 2</a>, a relationship that was resolved in <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure1PDM">Figure 1</a> via the <em>CustomerAddress</em> associative table. Object technology natively supports this type of relationship but relational databases do not, which is why the associative table was introduced.</p><p><a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure3FullyAttributedClassModel">Figure 3</a> also reveals a schism within the object community. It is common practice to not show <a href="http://www.agiledata.org/essays/keys.html">keys</a> on class diagrams (<a href="http://www.ambysoft.com/books/elementsUMLStyle.html">Ambler 2003/2005</a>), for example there isn’t any shown on <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure2ClassModel">Figure 2</a>. However, the reality is that when you are using a relational database to store your objects then each object must maintain enough information to be able to successfully write itself, and the relationships it is involved with, back out to the database. This is something that I call “<a href="http://www.agiledata.org/essays/mappingObjects.html#ShadowData">shadow information</a>”, which you can see has been added in <a href="http://www.agiledata.org/essays/impedanceMismatch.html#Figure3FullyAttributedClassModel">Figure 3</a> in the form of attributes with implementation visibility (no visibility symbol is shown). For example the <em>Address</em> class now includes the attribute <em>addressID</em> which corresponds to <em>AddressID</em> in the <em>Address</em> table (the attributes customers, state, and <em>zipCode</em> are required to maintain the relationships to the <em>Customer</em>, <em>State</em>, and <em>ZipCode</em> classes respectively).</p><p><strong>Figure 3. A fully attributed UML class model.</strong></p><p><img src="http://www.agiledata.org/images/impedanceMismatchFullyAttributed.gif" alt="img"></p><table><thead><tr><th><strong><a href="http://www.ambysoft.com/books/agileDatabaseTechniques.html"><img src="http://images.amazon.com/images/P/0471202835.01.MZZZZZZZ.jpg" alt="Agile Database Techniques"></a></strong></th><th>The schism is that the object community has a tendency to underestimate the importance of object persistence. Symptoms of this problem include:The lack of an official data model in the UML (see <a href="http://www.agiledata.org/essays/umlDataModelingProfile.html">The Unofficial UML Data Modeling Profile</a>)The practice of not modeling keys on class diagramsThe misguided belief that you can model the persistent aspects of your system by applying a few stereotypes to a UML class diagramMany popular OOA&amp;D books spend little or no time discussing object persistence issues</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>Yet in reality object developers discover that they need to spend significant portions of their time making their object persistent, perhaps because they’ve run into performance problems after <a href="http://www.agiledata.org/essays/mappingObjects.html">improper mappings </a>or perhaps because they’ve discovered that they didn’t take <a href="http://www.agiledata.org/essays/legacyDatabases.html">legacy data constraints</a> into account in their design. My experience is that persistence is a significant blind spot for many object developers, one that promotes the <a href="http://www.agiledata.org/essays/culturalImpedanceMismatch.html">cultural impedance mismatch</a>.</p><h2 id="3-Strategies-for-Overcoming-the-Object-Relational-Impedance-Mismatch"><a href="#3-Strategies-for-Overcoming-the-Object-Relational-Impedance-Mismatch" class="headerlink" title="3. Strategies for Overcoming the Object-Relational Impedance Mismatch"></a>3. Strategies for Overcoming the Object-Relational Impedance Mismatch</h2><p>Object and relational technologies are real, you are very likely working with both, and they are here to stay. Unfortunately the two technologies differ, these differences being referred to as “the object-relational impedance mismatch”. In this article you learned that there are two aspects to the impedance mismatch: technical and cultural.</p><p>The technical mismatch can be overcome by ensuring that project team members, including both application developers and Agile DBAs, understand the basics of both technologies. Furthermore, you should actively try to reduce the coupling that your database schema is involved with by encapsulating access to your database(s) as best you can, by designing your database well, and by keeping the design clean through <a href="http://www.agiledata.org/essays/databaseRefactoring.html">database refactoring</a>.</p><h2 id="4-The-Cultural-Impedance-Mismatch"><a href="#4-The-Cultural-Impedance-Mismatch" class="headerlink" title="4. The Cultural Impedance Mismatch"></a>4. The Cultural Impedance Mismatch</h2><p>Unfortunately there has been less attention spent on the cultural differences between the object-oriented community and the data community. These differences are often revealed when object professionals and data professionals argue with each other regarding the approach that should be taken by a project team. For a detailed discussion, see <a href="http://www.agiledata.org/essays/culturalImpedanceMismatch.html">The Cultural Impedance Mismatch Between Data Professionals and Application Developers</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Architecture </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setup Android Work Environment</title>
      <link href="/2020/05/25/417d/"/>
      <url>/2020/05/25/417d/</url>
      
        <content type="html"><![CDATA[<h2 id="设置-Mac-OS-编译环境"><a href="#设置-Mac-OS-编译环境" class="headerlink" title="设置 Mac OS 编译环境"></a>设置 Mac OS 编译环境</h2><p>在默认安装过程中，macOS 会在一个保留大小写但不区分大小写的文件系统中运行。Git 不支持这种类型的文件系统，而且此类文件系统会导致某些 Git 命令（如 <code>git status</code>）的行为出现异常。因此，我们建议您始终在区分大小写的文件系统中处理 AOSP 源代码文件。使用下文中介绍的磁盘映像可以非常轻松地做到这一点。</p><p>有了适当的文件系统，在新型 macOS 环境中编译 <code>master</code> 分支就会变得非常简单。要编译较早版本的分支，则需要一些额外的工具和 SDK。</p><h3 id="创建区分大小写的磁盘映像"><a href="#创建区分大小写的磁盘映像" class="headerlink" title="创建区分大小写的磁盘映像"></a>创建区分大小写的磁盘映像</h3><p>您可以使用磁盘映像在现有的 macOS 环境中创建区分大小写的文件系统。要创建磁盘映像，请启动磁盘工具，然后选择 <strong>New Image</strong>。完成编译至少需要 25GB 空间；更大的空间能够更好地满足未来的增长需求。使用稀疏映像有助于节省空间，同时可以根据需要进行扩展。请选择 <strong>Case sensitive, Journaled</strong> 卷格式。</p><p>您也可以通过 shell 使用以下命令创建文件系统：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdiutil create -<span class="keyword">type</span> <span class="type">SPARSE </span>-fs <span class="symbol">&#x27;Case</span>-sensitive Journaled HFS+&#x27; -size <span class="number">40</span>g ~/android.dmg</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这将创建一个 <code>.dmg</code>（也可能是 <code>.dmg.sparseimage</code>）文件，该文件在装载后可用作具有 Android 开发所需格式的驱动程序。</p><p>如果您以后需要更大的卷，可以使用以下命令来调整稀疏映像的大小：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdiutil resize -<span class="built_in">size</span> &lt;<span class="keyword">new</span>-<span class="built_in">size</span>-you-want&gt;g ~/android.dmg.sparseimage</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>对于存储在主目录下的名为 <code>android.dmg</code> 的磁盘映像，您可以向 <code>~/.bash_profile</code> 中添加帮助程序函数：</p><ul><li>要在执行</li></ul>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mountAndroid</span></span><br></pre></td></tr></table></figure><p>  时装载映像，请运行以下命令：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount the android file image</span></span><br><span class="line">    mountAndroid() &#123; hdiutil attach ~<span class="regexp">/android.dmg -mountpoint /</span>Volumes/android; &#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意</strong>：如果系统创建的是 <code>.dmg.sparseimage</code> 文件，请将 <code>~/android.dmg</code> 替换为 <code>~/android.dmg.sparseimage</code>。</p><ul><li>要在执行</li></ul>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">umountAndroid</span></span><br></pre></td></tr></table></figure><p>  时卸载映像，请运行以下命令：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unmount the android file image</span></span><br><span class="line">    umountAndroid() &#123; hdiutil detach <span class="regexp">/Volumes/</span>android; &#125;</span><br></pre></td></tr></table></figure><p>装载 <code>android</code> 卷后，您将在其中开展所有工作。您可以像对待外接式驱动盘一样将其弹出（卸载）。</p><ol><li><h3 id="安装-Xcode-和其他软件包"><a href="#安装-Xcode-和其他软件包" class="headerlink" title="安装 Xcode 和其他软件包"></a>安装 Xcode 和其他软件包</h3><ol><li><p>使用以下命令安装 Xcode 命令行工具：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> <span class="comment">--install</span></span><br></pre></td></tr></table></figure><p>对于旧版 macOS（10.8 或更低版本），您必须从</p></li></ol></li></ol><pre><code>Apple 开发者网站安装 Xcode。如果您尚未注册成为 Apple 开发者，则必须创建一个 Apple ID 才能下载。</code></pre><ol start="2"><li><p>安装 <a href="http://www.macports.org/install.php">MacPorts</a> 或 <a href="https://brew.sh/">Homebrew</a> 以进行软件包管理。</p></li><li><p>确保关联的目录位于</p></li></ol><pre><code><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure>文件的路径中：1. MacPorts -   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>local/bin</span><br></pre></td></tr></table></figure>   必须显示在   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin</span><br></pre></td></tr></table></figure>    之前：   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=/opt/local/bin:$PATH</span><br></pre></td></tr></table></figure>2. Homebrew - /usr/local/bin：   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure>3. 如果使用 MacPorts，请发出：   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">POSIXLY_CORRECT</span>=1 sudo<span class="built_in"> port </span>install git gnupg</span><br></pre></td></tr></table></figure>4. 如果使用 Homebrew，请发出：   <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>git gnupg2</span><br></pre></td></tr></table></figure>### 设置文件描述符数量上限在 macOS 中，可同时打开的文件描述符的默认数量上限太低，在高度并行的编译流程中，可能会超出此上限。要提高此上限，请将下列行添加到 `~/.bash_profile` 中：`    # set the number of open files to be 1024    ulimit -S -n 1024`</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 编译环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 中美爆发芯片战争</title>
      <link href="/2020/05/23/e277/"/>
      <url>/2020/05/23/e277/</url>
      
        <content type="html"><![CDATA[<blockquote><p>编者按：</p><p>180年前发生的那场鸦片战争，英国不道德地利用其军事优势来解决当时的贸易争端，打开了大清的国门。在鸦片战争近两百年后，西方文明现在又不得不准备与中国打一场「芯片战争」。最有讽刺意义的就是，「芯片战争」要解决的实质问题，和鸦片战争要解决的其实是同一个问题，那就是按照什么原则来发展不同文明之间的交往与合作。</p></blockquote><h1 id="分水岭"><a href="#分水岭" class="headerlink" title="分水岭"></a>分水岭</h1><p>2020年5月16日，美国商务部工业与安全局(BIS)突然宣布，将全面限制华为购买采用美国软件和技术生产的半导体，包括美国以外被列入管制清单的生产设备，在为华为和海思生产代工前，都要获得美国允许。</p><p>这意味着，由台积电为华为供货的芯片产业链，或将遭到全面封杀。中芯国际，将成为华为芯片最后的依靠。</p><p>虽然台积电做了否认，但美国的制裁，从放出消息开始显然已经箭在弦上。</p><p>此前的5月5日晚，中芯国际宣布将回归A股科创板上市，芯片股板块早已掀起一阵涨停潮。</p><p>但这家企业本身，却命运多舛。</p><p>2009年，中芯国际创始人张汝京因台积电起诉而下课，从而经历了一段没有技术主干的探索期。那时，中芯国际虽号称中国芯片巨头，但与国内同行的技术差距并不大。</p><p>2017年，神秘人物梁孟松加入中芯国际，企业迎来了加速发展期。一年后，中芯国际的芯片制程提升到14nm工艺，产品良率提升到95%。</p><p>至此，中芯国际奠定了国内芯片“一哥”的地位。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/ra4PtP.png" alt="ra4PtP"></p><p>梁孟松和中芯国际创始人张汝京，都出自台积电。此前，梁孟松曾在三星电子担任研发部总经理，并在2011-2015年将三星的芯片制程工艺，提升到和台积电的同一水平。结果，台积电依然挥舞起诉大棒，将梁孟松逼走。于是两年后，梁孟松加入中芯国际。而为了应对今天的困境，中国芯片产业发展一直在走生态路线，基本兼顾了全产业链的大部分环节。</p><p>2017年IC Insights报告显示，全球前十大IC设计企业中，华为海思已名列第7位。一边企业在推动，一边国家也在布局。2014年9月，国家集成电路产业投资基金(简称“大基金”)成立，重点投资集成电路芯片制造业，兼顾芯片设计、封装测试、设备和材料等产业，涵盖了IC产业上、下游。公开资料显示，大基金在制造、设计、封测、设备材料等产业链各环节投资比重，分别为63%、20%、10%、7%。正是大基金出现后，国内芯片公司掀起集体上市潮，且上市之路都一路绿灯。这基本坐实了中国在芯片领域全方位、全生态布局的基本思路。</p><p>现实证明，未雨绸缪非常有必要。2018年4月16日，“中兴事件”的爆发，中国科技保卫战正式打响。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/EYO6gr.png" alt="EYO6gr"></p><p>▲中兴事件爆发后，77岁的创始人侯为贵赶赴美国斡旋(从左到右：董事长殷一民、创始人侯为贵、总裁赵先明）</p><p>面对美国的“长臂管辖”，当时就有业内人士预言：这只是中美贸易冲突的第一步，意在给中国高科技企业一个集体下马威。果不其然，2019年，华为成为美国打压的第二个重点目标。而且，这次打压华为的力度之强，远超中兴，并延绵至今。在贸易战、科技战的背景下，高科技产业链的断裂似乎近在眼前。于是从2019年8月开始，中国半导体行业迎来一波牛市。</p><p>截止2020年5月，闻泰科技、兆易创新、澜起科技、三安光电、中微公司、韦尔股份、汇顶科技等公司，市值纷纷突破千亿。它们在各自的领域，以领头羊的身份引领着中国芯片产业崛起。像汇顶科技的光学指纹模块，已经在国产手机中得到广泛使用，是距离我们最近的国产芯片之一。而基于中国在5G、AI、物联网等“新基建”的全面带动，中国的芯片市场将迎来一轮爆发，并推动中国芯片生态的整体进步。</p><h1 id="芯绞痛"><a href="#芯绞痛" class="headerlink" title="芯绞痛"></a>芯绞痛</h1><p>从2013年备战至今，中国芯片产业技术薄弱，依然是一个不争的事实。芯片设计上，华为依然需要ARM等公司在芯片架构上的授权;芯片生产上，中芯国际仍然绕不开荷兰ASML的光刻机。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/968ZXe.png" alt="968ZXe"></p><p>　　                        ▲荷兰ASML被曝禁止招收中国籍员工</p><p>而且，由芯片造就的生态环境，也垄断而封闭。只要是PC和手机的业内玩家，就必须选择Windows或安卓的阵营，因为无法在芯片架构上绕开英特尔的X86和ARM的独家授权。</p><p>一位业内人士曾形容：</p><p>“就像只有知道1+1=2，才能推算出1+2=3一样，在X86和ARM的生态中，除非颠覆Windows和安卓两大世界级操作系统，否则任何人都无法在这两套生态内，打破对英特尔和ARM的垄断。”</p><p>而在芯片设计环节，EDA等设计软件也存在严重垄断。全球做EDA的厂商有六七十家，Synopsys、Cadence及Mentor三家公司，垄断了国内95%、全球65%的市场份额。EDA对于芯片，就像考场上考生必须用的2B铅笔。离开这支笔，考生再优秀，也只能望题兴叹。</p><p>对于芯片设计标准的垄断，一位专业人士曾经以汽车行业举例：</p><p>国内芯片公司造芯片，就好像汽车零件厂商造出一个世界领先的零件，却无人采购。不是零件不能用，而是汽车制造时，零件参数都是照抄国外的。企业也不知道零件参数为什么设置成这样，一旦换了新零件，害怕出现难以预料的问题。这正是大部分中国芯片企业的困境。因为未知领域太多，所以从芯片设计到芯片应用，能够形成一定自主权的，也只有华为海思、汇顶科技等寥寥几家。芯片设计公司寄人篱下，芯片制造公司也并不好过。芯片行业，向来赢家通吃。通常是，老大吃好、老二吃饱，老三、老四可能生死难料。</p><p>基于此，老大、老二还会持续投入，更新技术。几轮沉淀下来，英特尔与AMD、高通与联发科的盈利差距，都是3倍起跳。至于第三、第四，若非华为倾力扶持海思、苹果绑定A系芯片，高通和联发科之外的名字可能根本不存在。</p><p>在芯片制造领域，这一规律同样适用。比如，手机SOC，大部分来自台积电;内存和储存芯片，大部分来自三星;手机相机的CMOS芯片，主要来自索尼和三星。造成这种局面的原因，可以在iPhone 6s的A9芯片上找到一些原因。2015年，苹果将A9芯片交给三星和台积电两家企业一起生产，其中三星使用14nm工艺，台积电使用16nm工艺。台积电的16nm工艺制程看似落后，但芯片实际投入市场后，不但性能不输，在功耗和发热控制上比三星的14nm更为优秀。鉴于芯片表现上的巨大差异，苹果公司一度因A9芯片混用的舆论倍感压力。经过这次翻车，台积电成功拿下此后大部分A系芯片订单。</p><p>大厂之间，尚且赢家通吃，小厂的生存窘境可想而知。</p><p>集邦咨询数据显示，中国1380家芯片设计企业中，80%以上企业年营收少于1亿。虽然这类企业的整体营收增速达到13.4%，但因为中国晶圆厂的代工产能无法满足芯片设计高涨的需求，导致缺口一直在扩大。</p><p>我们需要认知的事实是：在IC Insights 5月报告中，虽然海思冲进了全球前10，但也只是第10;芯片代工上，因为受制于光刻机，只能在14nm做文章，而台积电和三星已向5nm进发。所以，我们仍有太多短板需要补足。芯片的战争，从中国寻求自立的开始，就注定是一场持久战。此外，稀有材料和人才保障也是中国芯片生态茁壮成长的重要土壤。而这些，都是我们尚未深入涉足的领域。</p><p>唯一庆幸是，我们已经在路上。</p><h1 id="大良机"><a href="#大良机" class="headerlink" title="大良机"></a>大良机</h1><p>既然芯片攻坚这么难，中国还有机会吗?</p><p>当然有!</p><p>但芯片投资，百亿刚起步、千亿不算富，民间投资根本扛不住。这让国产芯片发展，陷入了一旦落后就一直落后的怪圈。但这一切，随着2014年大基金的成立彻底改变，芯片成为事关国家安全的命脉产业，投资从亏不亏钱的经济考量，变成了国家信息安全的战略博弈。太平洋研究院数据显示：2014年以后，中国在半导体领域的资本支出直线上升，并在2018年成功追平日本、欧洲的相关公司。</p><p>由此，海思、中芯、汇顶等一众巨头开始崛起。如今，它们都是国家半导体产业的中流砥柱。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/HbXZp5.png" alt="HbXZp5"></p><p>而伴随5G、AI、物联网等领域的蓬勃兴起，中国市场的大江大海，显然能容纳更多的芯片巨头的成长。其中的标志性事件，就是2018年，制造业巨头格力和互联网巨头阿里，分别创立“零边界”和“平头哥”。2019年9月25日，杭州云溪大会上，阿里推出含光800 AI芯片。除了性能上号称全球最强之外，其“自研架构”格外引人瞩目。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/9n95ty.png" alt="9n95ty"></p><p>对此，阿里CTO张建锋表示：“在全球芯片领域，阿里巴巴是一个新人，玄铁和含光800是平头哥的万里长征第一步，我们还有很长的路要走。”  国家推动、巨头引领，中国芯片人才开始向头部企业聚集。某种程度上，也只有大公司开得起百万、千万的薪酬，吸引全球行业精英，并为经费高昂的芯片研发提供基础保障。</p><p>数据更能说明大公司的影响力。欧盟一份报告显示：2018年，全球研发投入最多的2500家公司，约占全球上百万企业整体研发经费的90%。</p><p>所以，中国芯片的生态战争，首先需要大公司为人才培养担负起责任，增强造血能力，从而实现生态层面的崛起。事实上，芯片的人才战争一直暗潮涌动。</p><p>比如，韩国半导体人才“出走”中国，已成现象级趋势。有报道显示，中国给三星电子部长级技术人员的年薪，高达294万人民币，是韩国薪水的3-4倍。有了人才的引入，加之大公司对新生人才的培育，中国正在逐渐打通生态体系的隔阂。只是，生态化自足，涉及到人才、硬件、原材料、光刻机和芯片架构等方方面面，注定了这是一条极其难走的道路。</p><p>而在现有技术条件下，中国的冲刺存在两大利好：</p><p>一是芯片制程方面的“摩尔定律”正在失效，让中国不再是永无止境的追赶，而存在弯道超车的可能。</p><p>二是在芯片设计领域，AI是一条全新赛道，全球尚未形成架构标准，这让AI芯片的生态系统拥有从底层重构的可能。</p><p>这一切，都是5G的战争前奏。</p><h1 id="沉寂中爆发"><a href="#沉寂中爆发" class="headerlink" title="沉寂中爆发"></a>沉寂中爆发</h1><p>2003年，上海交大微电子学院院长、教授陈进，通过把摩托罗拉芯片Logo磨掉的方法，伪造出“自研”的“汉芯”芯片。为了这块假芯片，国家虚耗了上亿资金。自研受挫后，中国企业一度展开各种技术并购，结果在美国政府阻挠下大都失败。自研受挫，并购受阻，中国信息产业一直严重依赖芯片进口。</p><p>1999年，中国大陆芯片销售总额为86亿美元，仅占全球市场的5.9%;但经过信息互联网产业的爆发式发展，2018年，中国进口芯片4175.7亿件，金额达2.184万亿，超过石油1.59万亿的进口总额，成为中国最大宗的进口商品。</p><p>2010年，是中国国产手机的集体爆发之年。那一年，华为、小米、Ov、魅族都悉数登场，摩拳擦掌等待着4G时代的手机红利。</p><p>但高通这样的芯片巨头，才是时代红利的终极收割者。通过芯片，高通横征暴敛，从所有手机厂商手里攫取整机价格4%的“高通税”，高过手机厂商3%的净利润率。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf2z6becelj30o20fndwz.jpg" alt="image-20200523120534256"></p><p>​                        　　▲“我们有钱请律师!”是高通前CEO保罗·雅各布的名言</p><p>由于掌控他人命脉，高通对此毫不避讳：你不喜欢没关系，“我们有钱请律师”。2017年，苹果、三星、华为奋起反击，起诉高通。但折腾两三年，苹果选择和解，还付了45亿美元专利费;华为、三星也只能和解了事。</p><p>然而，芯片的本质上无非是高级沙子。眼见不计其数的中国制造和稀土等战略资源，被小小的芯片用白菜价换出去，中国成立大基金背后的自强与不甘，亦可想而知。</p><p>如今，5G风口已至。如果中国的芯片产业再错失机遇，芯片仍会是制约中国5G建设的最大掣肘。在这场旷日持久的大国博弈中，华为海思终成产业先锋。在经历多次迭代后，2019年9月，华为推出了可与高通、苹果比肩的麒麟990 5G芯片。从磨掉摩托罗拉Logo的伪造“汉芯”，到2019年苹果全球发布会上，苹果CEO库克将A13与麒麟980对标，中国的芯片征程走过了太多坎坷。</p><p>然而，华为过于亮眼的成绩，引发了美国以各种名义实施的全方位打压。多少习惯了“拿来主义”、鼓吹技术无国界的人才如梦初醒：原来只有缴够芯片“智商税”，才能平平稳稳做“全球化生意”。从这一刻起，芯片竞争已经演变为残酷的世界级战争。也正因如此，华为、中芯国际的一举一动，都被市场密切注视。</p><p>14nm的制程远远算不上优秀，甚至只能为中低端手机的SoC代工，但2020年4月荣耀Play4T搭载着中芯国际代工的麒麟710A处理器开售时，第一款纯国产芯片的商业化量产，让无数中国半导体人为之泪目。基于对中国芯的认可，2020年第一季度CINNO Research产业报告显示：华为海思以43.9%的市场份额首次超过高通，正式成为国内出货量最大的手机处理器品牌。</p><p><em>每个中国普通消费者，也都在用自己的方式，默默为优秀的中国企业投票。</em></p><p>有从业者观察表示：无数地方都梦想成为“中国硅谷”，甚至拿出几十亿补贴建厂。但芯片的生态战争，注定有人去拓荒，有人打基础。它比一场真实战争的复杂程度有过之而无不及，背后的动员、谋划、粮草安排都需要更顶层的设计与部署。</p><p>这是一场备受关注的世界大战，也是改变世界产业格局的博弈大战。它既是资本战、市场战，又是人才战，也是持久战，现在的情形看，还是一场几乎你死我活的恶战。它的成败，不仅将关系到一众高科技企业的命运，也将在科技驱动经济的时代关乎国运，关乎你我的未来。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
            <tag> 华为 </tag>
            
            <tag> 麒麟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Understanding the Android Compilation Process</title>
      <link href="/2020/05/18/156f/"/>
      <url>/2020/05/18/156f/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/06xuWt.png" alt="06xuWt"></p><h1 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h1><p>The main objective of this blog post is to give you a clear idea about the Android compilation process which describes the stages through which your android application goes through when you build it.</p><h1 id="Step-1-What-you-should-know-before-starting-Android-Development"><a href="#Step-1-What-you-should-know-before-starting-Android-Development" class="headerlink" title="Step 1 What you should know before starting Android Development?"></a>Step 1 What you should know before starting Android Development?</h1><p><strong>Are you new to Android?</strong></p><p><em>Don’t worry! “I have got your back!!!” ;)</em></p><p><em>Any Android application has several building blocks. I will give you overview of</em></p><p><em>The Android’s component Architecture</em></p><p><em>The Android Runtime Environments - DALVIK AND ART.</em></p><p><em>Android Compilation Process</em></p><p><em>Fasten your seat belt! We are about to get started.</em></p><h2 id="1-1-The-Android’s-Component-Architecture"><a href="#1-1-The-Android’s-Component-Architecture" class="headerlink" title="1.1 The Android’s Component Architecture"></a>1.1 The Android’s Component Architecture</h2><p>Every <strong>Android application</strong> is made up of <strong>Components</strong>. Components are implemented as Java Classes.</p><p>For example, an <a href="https://developer.android.com/guide/components/fundamentals.html">Activity</a> in Android represents a screen or a portion of a screen of the user’s device. It is an instance of a Java class named <strong>Android.app.Activity</strong></p><p><img src="http://www.theappguruz.com/app/uploads/2017/04/the-main-activity-or-user-screen.png" alt="The Main Activity or user screen"></p><p>Another example is the <strong>UI element Button</strong>. A button in an Android application is an instance of a Java class named <strong>Android.widget.Button</strong></p><p><img src="http://www.theappguruz.com/app/uploads/2017/04/the-button-component.png" alt="The Button Component"></p><p><em>These are just two examples I have mentioned, but there are thousands of Java classes and interfaces in the Android SDK. I do not want you to worry about ALL THOSE at this moment. ;).</em></p><p><em>You can also create your own Java classes representing your app’s components.</em></p><h2 id="1-2-The-Android-Compilers-DALVIK-vs-ART"><a href="#1-2-The-Android-Compilers-DALVIK-vs-ART" class="headerlink" title="1.2 The Android Compilers (DALVIK vs ART)"></a>1.2 The Android Compilers (DALVIK vs ART)</h2><p><strong>How do your devices (Mobile Phone, Tablet, Android TV and many more) understand the Java code that you have written?</strong></p><p>Your source code is <strong>compiled by</strong> Standard Java Compiler which uses the <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT- ‘Just-In-Time’</a> <strong>compilation model</strong>.</p><p>Once the code is compiled, it becomes <strong>bytecode</strong> <em>(with ‘.class’ extension)</em>. This code goes for a second round of compilation (Again to Bytecode - But this time it is minimized).</p><p>The bytecode gets <strong>executed by target-specific-JVM</strong> (<a href="http://www.javatpoint.com/internal-details-of-jvm">Java Virtual Machine</a>) which is a runtime environment for Java.</p><p><strong>But for Android, we have two different virtual machines:</strong></p><ol><li>DALVIK</li><li>ART</li></ol><h3 id="1-2-1-DALVIK"><a href="#1-2-1-DALVIK" class="headerlink" title="1.2.1 DALVIK"></a>1.2.1 DALVIK</h3><p>Prior to <a href="https://en.wikipedia.org/wiki/Android_Runtime">ART</a> <em>(that was introduced with the release of Android 4.4 - that is, ‘Kitkat’)</em> the <strong>runtime environment for Android apps</strong> was <a href="https://en.wikipedia.org/wiki/Dalvik_(software)">DALVIK</a>.</p><p><strong>So why did Google moved from DALVIK to ART?</strong></p><p><strong>There was one major disadvantage of DALVIK - It was SLOW!</strong>.</p><p>It was FRUSTRATING for users to use their apps on their devices as the apps stuttered while running.</p><p>Dalvik uses JIT compilation model. JIT compiler compiles the app when they are opened by users (The app start up procedure). So it made opening of apps slower and which in turn hampered the user experience.</p><h3 id="1-2-2-ART"><a href="#1-2-2-ART" class="headerlink" title="1.2.2 ART"></a>1.2.2 ART</h3><p>ART uses the <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">ahead-of-time</a> compilation model which compiles the apps to machine code upon installation</p><p>Apps run a bit FASTER! under ART, so the startup time of apps gets reduced.</p><p>It also has improved garbage collection so that the user sees fewer pauses and stutters in a low memory environment.</p><p><strong>ART has its own limitations:</strong></p><ol><li><strong>Installation time issue:</strong> The installation process is slow with ART as apps to machine code conversion takes time.</li><li><strong>Size issue:</strong> Compiling the code upon installation means that the app has to ‘live’ on your device. So, for a relatively smaller Java code the machine or the bytecode will be comparatively large.</li></ol><p><a href="https://www.quora.com/Why-is-ART-better-than-Dalvik">Here</a> is a quora thread discussing ART vs DALVIK</p><p><img src="http://www.theappguruz.com/app/uploads/2017/04/android-kitkat-introduces-art.png" alt="Introduces Android Kitkat Art"></p><h1 id="Step-2-The-Android-Compilation-Process"><a href="#Step-2-The-Android-Compilation-Process" class="headerlink" title="Step 2 The Android Compilation Process"></a>Step 2 The Android Compilation Process</h1><p><img src="http://www.theappguruz.com/app/uploads/2017/04/the-android-compilation-process.png" alt="The Android Compilation Process"></p><p>When you compile a Java code into an Android app, it goes through a number of stages</p><h2 id="2-1-From-source-code-to-bytecode"><a href="#2-1-From-source-code-to-bytecode" class="headerlink" title="2.1 From source code to bytecode"></a>2.1 From source code to bytecode</h2><p>You will need <strong>JDK</strong> (<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Java Developer Kit</a>) <strong>to compile the Java code</strong> of your application.</p><p>Your code and precompiled classes from runtime and custom libraries are compiled first by ‘Javac’ (JIT Compiler/ Standard Java Compiler).</p><p>The Javac outputs a set of Java bytecode files. So far this looks like any Java compiler process but the next compilation step makes the compilation process unique to Android.</p><h2 id="2-2-The-obfuscator-ProGuard-Tool"><a href="#2-2-The-obfuscator-ProGuard-Tool" class="headerlink" title="2.2 The obfuscator! (ProGuard Tool)"></a>2.2 The obfuscator! (ProGuard Tool)</h2><p>This step is optional, you can omit this step if you want to.</p><p>The ProGuard Tool takes the Java bytecode files (output as a step number 1) and sends them through a tool named <a href="https://en.wikipedia.org/wiki/ProGuard_(software)">ProGuard</a>. It will <strong>minimize</strong> and obfuscate (meaning - To make obscure, unclear or unintelligible) <strong>your code</strong>.</p><p>It is disabled by default in new Android projects but when ProGuard is turned on,it will analyze your code and remove implementations of methods, for example, that aren’t called.</p><p>This can dramatically shrink your distributable app package. It also obfuscates your code by changing method names and so on making it harder to decompile packaged Java code by a third person or organization.</p><p>Regardless of the use of ProGuard you once again end up with .class files (minimized bytecode).</p><h2 id="2-3-From-minimized-bytecode-to-dex-code"><a href="#2-3-From-minimized-bytecode-to-dex-code" class="headerlink" title="2.3 From minimized bytecode to dex code"></a>2.3 From minimized bytecode to dex code</h2><p>The next step is to take the output files from step number 2 and to turn those files into <strong>dex bytecode - Dalvik EXecutable(.DEX)</strong>.</p><p>The DEX bytecode is a format that is optimized for Android and which can be executed by the older DALVIK runtime or the newer ART runtime.</p><h2 id="2-4-Execution-of-Machine-Code"><a href="#2-4-Execution-of-Machine-Code" class="headerlink" title="2.4 Execution of Machine Code"></a>2.4 Execution of Machine Code</h2><p>The device’s runtime read these dex files (output of step number 3) and recompile some of the files to machine code for the fastest possible execution.</p><p>On DALVIK this step happens as the app runs using Just-In-Time or JIT architecture.</p><p>On the newer ART, the recompilation (or translation to machine code) happens when the app is first installed, meaning that the app can run faster when the user runs it on his/her device.</p><p>And that’s how your Java code turns into something that runs on Android. It starts with Java and after a couple of steps, it is transformed into something which the Android runtime can read and execute.</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Compilation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解华为正在开发的操作系统</title>
      <link href="/2020/05/17/bbe/"/>
      <url>/2020/05/17/bbe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转文学城</p></blockquote><p>读者按： 最近开始研究华为的系统，读了很多文章和代码，计划庖丁解牛的研究华为面临的问题。只有清晰的了解问题后，才可以对症下药。这篇文章有点意思，记录一下以做参考。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/QayQoK.png" alt="QayQoK"></p><p>华为消费者业务总裁余承东在朋友圈说最快今年秋天，最晚明年春天，华为自己的操作系统（OS）将可能面市。华为的OS打通了手机、电脑、平板、电视、汽车、智能穿戴，统一成一个操作系统。且华为OS还兼容全部的安卓应用和所有的Web应用，相关安卓应用在华为OS上重新编译后，运行性能提升将超过60%。</p><p>据传这个操作系统叫鸿蒙。鸿蒙本意是中国神话中的在天地开辟之前，一团混沌的元气世界。很奇怪，为什么华为的OS叫鸿蒙。等待开辟？还是一团混沌？</p><p>余承东别号余大嘴，朋友圈的话算不上正式发布，双重不靠谱。</p><p>这位老总一定是把操作系统混同于华为宣传的方舟编译器了。以前华为宣布方舟编译器的终极目标，是推出一个跨平台、跨系统、跨设备多种语言的软件开发平台。操作系统包括的东东比一个编译平台多得多。工作量也大得多。能够跨系统写应用软件不等于一统江湖的跨设备的操作系统。</p><p>根据华为公开的信息，鸿蒙是一个基于安卓的，集成了华为对安卓系统的既往优化的操作系统，包括EMUI5.0 优化，方舟编译平台， GC 优化，EROFS文件系统等等。但主框架仍然脱不了安卓或者Linux的操作系统。由于安卓和Linux都是开放的，这样做没有问题。它让人想起了2014年被收购的红旗Linux。</p><p>当今手机操作系统领域，基本上是苹果和安卓的二分天下。苹果是先行者，谷歌是赶超者。先行者有先发优势。即使不开放，也能占领很大市场。安卓不同于苹果系统是它的开放性，它采用了跨平台操作的JAVA语言，支持不同硬件设备，环境对应用开发商开放。苹果手机使用自己的硬件，严格管控应用开发商。苹果的封闭环境，使它更易于高效，更容易优化，这就是为什么苹果手机使用规格较低的硬件还能让用户感受流畅的体验。谷歌为了培养生态系统，采用了开源的安卓，对效率和性能不得不有所牺牲。谷歌的开放，使很多新制造商（包括华为）可以快速进入智能手机领域。也使安卓的应用大量增加。据2017年年底统计，安卓的应用比苹果多了42%。全球范围内，安卓用户占86%，苹果用户占14%。</p><p>手机操作系统的后发者，还有诺基亚的塞班，Palm的Palm OS和微软的window Phone，都是由于没有杀手锏以及生态圈没做好，惨遭淘汰。</p><p>具体来说，安卓系统在两个性能上落后于苹果OS。一个是为了跨硬件操作，JAVA使用了虚拟机。功能是将各种硬件抽象成Java的运行环境，JAVA只管虚拟机。而虚拟机负责连接具体硬件。因此Java实现了跨平台——不管是X86，ARM，还是其他CPU的机器都没有问题。虚拟机里有一个解释器，将JAVA语言逐句翻译成硬件懂得的机器码。而苹果由于没有跨平台的问题，事先把整个程序编译成机器码，执行起来就快了。另一个瓶颈是安卓需要回收不再使用的内存，这个工作叫garbage collection （GC）。GC时，虚拟机要停止运行，判断哪些内存不再使用并释放。这个停顿会造成手机的卡顿。</p><p>谷歌和其他安卓手机制造商，也在持续优化安卓，一方面是硬件提升。由于硬件越来越便宜，手机上的CPU增至8核，速度也增加了很多。内存也由几百M增加到8G。软件上，谷歌采用了JIT（Just In Time）编译。当系统发现程序内有一段代码频繁执行的时候，下次调用就不用重复解释，直接执行上次解释出的机器指令。虚拟机进化到ART（Android Run Time）后，采用了AOT编译器（Ahead Of Time），就是运行之前，将部分代码静态编译为机器码，极大地提升了效率。但对于那些Java动态特性的部分，还有其他部分，仍然做不到直接编译，还是要解释执行。GC方面谷歌也做了优化，将GC的频率和时间都减少了。综合效果是，如果你用的是一个比较新的手机，硬件配置属于中高端，安卓版本比较新，基本上感觉不到卡顿，运行比较流畅。</p><p>当不能得到谷歌GMS授权后，华为如果能很快推出新手机操作系统，而且这个操作系统有革命性的创新，且性能大大领先于现有的安卓，就会成为一个大杀器，挽回流失的用户。但是作为后发者的华为进入手机操作系统领域，除了为培育生态圈，必须开源之外，还要有一些杀手锏。方舟编译器似乎就是是鸿蒙寄予深厚希望的一个杀手锏。华为宣称，方舟编译器可让系统操作流畅度提升24％，系统响应速度提升44％，第三方应用编译后流畅度可提升60％！是革命性的优化，全程执行机器码，高效运行应用，彻底解决安卓应用“边解释边执行”造成的低效率。</p><p>根据目前公开的资料。方舟编译器不再使用Java的虚拟机，而是开发者在应用打包的时候就将所有程序，包括静态和动态的部分直接编译成机器指令。 这种编译会带来跨平台问题，java使用虚拟机解决的正是这个问题。方舟对跨平台问题的解决方法，是同时编译出所有硬件平台对应的机器码文件，之后在具体手机安装的时候选择针对当前硬件平台的机器码装入手机。因此会出现安装包容量大的问题（因为安装包包含所有硬件平台的二进制文件）。导致应用安装包和安装后的机器码占用空间增大。据估计，方舟编译器重新编译的安装包要比安卓大两三倍，手机安装后的机器码要大0.5-1倍。带来的问题是占用存贮和内存显著增加。用户下载安装包会消耗越来越多的时间和流量。这是一个用空间换取运行速度的策略。</p><p>方舟编译器会有严重的生态问题。首先华为必须将编译器代码开放，让应用开发商免费下载。应用开发商将其已发布的应用重新编译，并再次对安卓的所有版本和所有硬件平台进行测试。改正Bug后，重新发布，在所有应用商店上架。这个工作必须让各个应用开发商自己做，华为不能代劳，因为由于安全原因，每个应用都要有开发者的签名。这基本上是一个不可能完成的任务。你可以在爱国情怀下忽悠国内的部分开发者，但不可能让全球的应用开发者来跟随。大多数的app开发商是中小规模的，甚至是个人，怎么可能有时间有精力开发编译测试如此多的版本？</p><p>方舟编译器还有维护的困难。当新的非华为（高通，联发科等）硬件平台发布后，方舟编译器必须及时跟进，并将新版本推送给所有的开发商。随着越来越多新硬件的发布，方舟编译出的安装包势必会越来越大。用户下载安装包会消耗越来越多时间和流量。同时开发商编译时间会越来越长，需要测试的硬件会越来越多。</p><p><img src="https://inews.gtimg.com/newsapp_match/0/10158083033/0" alt="img"></p><p>这么大的麻烦换取的是最多44%的系统响应速度。而且这个提升很可能是在实验室特定条件下测得的。体现在用户感知上，很可能要大打折扣。根据用户感知测试，一般人对在0.2秒以下的速度提升没有感知。在这个区间，人的感知已经达到饱和。换句话说，把响应速度从0.2秒提升到0.1秒，大部分人感觉不到区别。据我的经验，目前中高端安卓手机的性能瓶颈不是CPU的处理速度， 更不在解释执行速度。 所以对这个方舟的优化，用户很可能无感。</p><p>另一个华为宣传的对安卓的优化是内存垃圾回收（GC），从全局统一回收改变为随用随回收，回收时无需暂停应用，宣称消除了因内存回收的卡顿。但问题是，安卓自5.0版本以后，采用ART虚拟机，GC的次数和停顿时间已经大大改善，GC引起的卡顿几乎感知不到了。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Q732on.png" alt="Q732on"></p><p>最重要的是，华为这些对安卓的改善可以说都是工程方面的，没有技术的创新。消除JNI的开销,把Java和C在一起编译，来自于甲骨文的GraalVM和开源的LLVM；无需虚拟机类似于苹果swift语言的执行和谷歌的AOT；引用计数的垃圾回收也是业界已有的建议。所有的思路都是谷歌曾经想到的，但为了可移植性做的牺牲。</p><p>谷歌也在对安卓优化，开发下一代操作系统。项目叫Fuchsia。 Fuchsia基于微内核架构，用于嵌入式系统，主要使用C语言和C++编写。Fuchsia的设计目标之一是可运行在众多的设备上，包括移动电话和个人计算机。</p><p>比较谷歌和华为的操作系统，目标虽然相同。但谷歌的系统包含更多的技术创新，而华为的系统著重于工程集成。这反映了两个公司的区别。谷歌代表的是技术创新。而华为擅长的是工程能力，还需要更多的创新！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为 </tag>
            
            <tag> 鸿蒙 </tag>
            
            <tag> 方舟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Architecture</title>
      <link href="/2020/05/17/b272/"/>
      <url>/2020/05/17/b272/</url>
      
        <content type="html"><![CDATA[<p>Android is designed so that there’s no central point of failure, where one industry player restricts or controls the innovations of another. The result is a full, production-quality consumer product with source code open for customization and porting.</p><p><img src="https://source.android.com/images/android_framework_details.png" alt="Android framework details"></p><h1 id="Platform-Architecture"><a href="#Platform-Architecture" class="headerlink" title="Platform Architecture"></a>Platform Architecture</h1><p>Android is an open source, Linux-based software stack created for a wide array of devices and form factors. The following diagram shows the major components of the Android platform.</p><p><img src="https://developer.android.com/guide/platform/images/android-stack_2x.png" alt="The Android software stack"></p><p><strong>Figure 1.</strong> The Android software stack.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美方完美封杀华为 特朗普打响中美贸易战2.0</title>
      <link href="/2020/05/17/2bbd/"/>
      <url>/2020/05/17/2bbd/</url>
      
        <content type="html"><![CDATA[<p>中美关係在刚过去的周五（15日）发生了两件关键大事，一是美国决定进一步收紧向中国电讯设备巨头华为供货，二是华为芯片主要供应者台积电，宣布在美国设立高端芯片厂的计划。两事相隔仅数小时，绝非偶然巧合，客观上产生的效应是：美国升级攻击华为供应链，而作为华为伙伴的台积电，释出站在美国一方的姿态。如再结合特朗普政府近期不断重申的中美「脱钩论」，可以合理推敲，美国已为攻击中国供应链掀起大幕。有观察者形容，这是中美贸易战的第二波。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/9iVdMh.png" alt="9iVdMh"></p><p>新冠肺情令中美关係陷于低谷，但中方连日来大手购买美国大豆、猪肉等产品，展示愿意履行第一阶段中美贸易协议的姿；但此举似乎不足以解读为「中美贸易战缓和」；相反，上周五两个与美国相关的消息，足以说明中美贸易矛盾不仅没放轻，且还有恶化趋势。</p><p>其一：美方收紧向华为供应半导体的限制：</p><p>美国商务部宣布新规定，要求各国採用美国科技、卖给华为的半导体产品，一律须取得美国政府许可，这远比过去的「美国技术含量15%」以上才受限，更为严苛。</p><p>商务部工业和安全局声明提到，美方自去年将华为及其114间关联企业列入「出口管制实体名单」，限制美国企业供货华为后，华为却继续通过委託使用美国设备的海外代工厂生产，又使用美国的软件和技术来设计芯片，破坏「实体名单」目的。美方因此堵塞漏洞。</p><p>其二：全球芯片代工龙头台积电宣布赴美设厂计划：</p><p>台积电宣布计划投资120亿美元，在美国亚利桑那州新建工厂，生产目前最高端的5纳米芯片，预计4年后投产、每月产出2万片芯片。</p><p>伯恩斯坦证券估计，台积电美厂房未来月产2万片芯片，只佔到4年后的台积总产能不到2%，这对苹果（Apple）等每月要用上6到10万片，根本是极杯水车薪。因此，预计亚利桑那厂生产的，该是敏感度最高、最需要在美国製造的军用晶片，例如战斗机用的处理器。此举是要防止军工技术转移中国。</p><p>路透社解读指，美国推出新版的华为禁令，旨在瞄准打击华为供应链，而台积电在几乎同一时间宣布在美设厂，便颇有站队美国的意思；而中美科技产业对抗升级，更可能导致华为手机全面难产。事实上，由于华为已经不再使用高通的产品，而是由华为自家子公司—海思半导体研发，并交付台积电代工生产晶片。美方上述组合拳，是要完美封杀华为。</p><p>值得注意是，美国总统特朗普在周四（14日）播出的霍士财经频道访问中提到，新冠肺炎疫情凸显了美国本土製造业的重要性，应把供应链迁离中国。因此有理由相信，美方针对华为的动作只是前奏，未来有可能拓散到中美其他领域。</p><p>有一名美国半导体业副总更形容，特朗普打击华为的新政，「是第二波中美贸易战开打」。华为虽亦有在中国南京设厂，但只生产16纳米的晶圆产品、比今天最高端的心片落后了一代，未来的发展挑战重重。</p>]]></content>
      
      
      <categories>
          
          <category> 国际经济 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为 </tag>
            
            <tag> 中美对抗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全球化2.0与中国“战略性分手”的三种形式</title>
      <link href="/2020/05/17/ba7b/"/>
      <url>/2020/05/17/ba7b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章来源: 自由亚洲电台</p></blockquote><p>全球化2.0与中国“战略性分手”（自由亚洲电台制图）</p><p>西方五眼联盟学者提出了与中国的”战略性分手”三管齐下的策略。这可能在全球化2.0之际，重创中国的经济地位。</p><p>美国总统特朗普周四刚发表了“切断和中国关系”的讲话，周五，美商务部宣布新出口禁令，扩大对华为供应链封锁；同日，台湾的半导体大厂台积电宣布斥资在美国亚利桑纳州建造芯片厂，获得美国官员的大力赞扬。</p><p>中国外交部发言人赵立坚5月15日则批评”美中脱钩”的氛围。赵立坚：”合则两利，斗则俱伤，搞脱钩和切割没有出路。”</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/kWhH6I.png" alt="kWhH6I"></p><h1 id="中国不再是可靠的伙伴"><a href="#中国不再是可靠的伙伴" class="headerlink" title="中国不再是可靠的伙伴"></a>中国不再是可靠的伙伴</h1><p>英国智库“亨利·杰克逊协会” (Henry Jackson Seciety)的研究部主任安德鲁·福克萨尔(Andrew Foxall)告诉自由亚洲电台，”与中国脱钩”的概念自美中贸易战打响开始就在西方世界传播，新冠疫情加速让世界重新思考产业链过于依赖中国的危险性。</p><p>福克萨尔：”（疫情）让西方更清楚地意识到，中国不再是可靠的伙伴。这种（与中国）脱钩或说成是战略性的分手，确实困难，但绝对有必要。”</p><p>亨利·杰克逊协会14日发布的报告，详细分析了五眼联盟国家在关键进口商品上对中国的”战略依赖”程度。所谓“战略依赖”，指该商品有50％以上来自中国供应链，且中国控制该商品30%以上的全球市场。</p><p>报告发现，“五眼联盟”成员澳大利亚、新西兰、美国、加拿大、英国共有831种进口商品对中国有“战略依赖”，其中260种是国家基础设施（CNI）的关键组成部分。所谓“五眼联盟”是这些国家组成的一个分享情报的机制。</p><p>报告的共同作者、亨利·杰克逊学会 “全球英国”计划负责人罗杰斯(James Rogers)在接受自由亚洲电台专访时表示，这份报告的目的是把对中国依赖程度高的关键商品找出来，让这些国家政府在制定与中国脱钩计划时，能做出清楚的选择。</p><p>罗杰斯：”我们把重点放在影响国家关键基础设施的产业，比如医疗、国防、科技，以及会影响进入第四次工业革命的生技、化学原料、稀土等。五眼联盟必须确保在这些方面不依赖中国。”</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevy9gdph4j30pc0e8kdo.jpg" alt="image-20200517101508098"></p><p>变态辣椒：全球化2.0即将开通 疫情雷区请绕行 Photo: RFA</p><h1 id="学者提与中国”战略性分手”的三种形式"><a href="#学者提与中国”战略性分手”的三种形式" class="headerlink" title="学者提与中国”战略性分手”的三种形式"></a>学者提与中国”战略性分手”的三种形式</h1><p>福克萨尔告诉本台，西方国家不应该完全切断与中国的关系。所谓的与中国脱钩不是提倡保护主义，更不该被诠释为反全球化、反对自由贸易，重点是在战略产业不再集中依赖中国。</p><p>这份报告提出了对中国脱钩策略需要三管齐下。第一”消极性脱钩”，指的是对关键性中国商品的进口予以限制；第二”积极性脱钩”，指在本国或其它国家拓展产业链；第三”合作性脱钩”，则是由五眼联盟国的经济合作、情报共享开始，并进一步扩大到印太区域的合作伙伴如日本、韩国、台湾、印度和越南等。</p><h1 id="中国制造2025化为幻影？"><a href="#中国制造2025化为幻影？" class="headerlink" title="中国制造2025化为幻影？"></a>中国制造2025化为幻影？</h1><p>2015年，中国国务院总理李克强曾提出”中国制造2025”的政策，希望中国从低端制造大国跻身高端产业的制造业强国。</p><p>罗杰斯告诉自由亚洲电台，在这场由美国引领的全球与中国脱钩计划下，势必对中国造成”重大影响”，中国势必要重新拟定战略计划。</p><p>罗杰斯：”美国一直是中国工业现代化的主要投资者及最大的市场。如今从美国到五眼联盟再到世界各国越广泛的与中国脱钩，势必对中国的计划造成重大影响。”</p><p>两位学者都提到了上世纪九十年代的全球化政策。西方国家很多人都期待全球化会加速中国中产阶级崛起，最终能够成为推动中国融入全球政治经济体的力量。</p><p>罗杰斯说，全球化的基础是各国对贸易规则的尊重与合作。但是从中国现任政府看来，中国并没有选择往这条路走。他说，而当世界发现全球化1.0这条路不再与各国利益相符，终将采取行动，在全球化2.0的进程中一起”约束中国”。</p>]]></content>
      
      
      <categories>
          
          <category> 国际经济 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中美对抗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美国封杀华为“断芯”升级 中国或砍苹果出气</title>
      <link href="/2020/05/17/7b8a/"/>
      <url>/2020/05/17/7b8a/</url>
      
        <content type="html"><![CDATA[<p>美国商务部星期五（5月15日）宣布扩大对中国华为公司的禁令，要求那些依赖美国设备和软件的外国芯片制造商必须取得美国商务部的特许，方可向中国华为公司出口芯片产品。中国官方媒体暗示，中国可能出台针对苹果、波音等美国企业的报复措施。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/YqpgBI.png" alt="YqpgBI"></p><p>美国官员说，华为一直在通过从美国以外的制造商获取芯片，规避美国制裁。</p><p>美国商务部的声明说，新推出的决定将切断华为对美国出口管制的“破坏努力”，商务部下属的工业和安全局（BIS）正在修订“外国直接产品规则”和“实体清单”，以具有战略性做法专门针对华为试图获取的、直接通过美国软件和技术制造的半导体产品。</p><p>美国商务部长罗斯星期五在接受福克斯商业频道采访时说：“一直以来，华为都在用一个非常有技术性的漏洞通过外国晶圆生产商使用美国的技术。”他说，新的规定“试图纠正这个漏洞，并确保美国的晶圆厂与外国晶圆厂在平等的基础上竞争。”</p><p>华为去年被列入美国商务部“实体清单”。美国政府以国家安全为由，限制美国制造的产品卖给华为，禁令也针对一些包含美国技术的外国产品。路透社说，特朗普政府中的对华强硬派对实体清单的作用仍然不满，因为某些外国供应商仍然可以向华为供货，于是从去年11月开始推动进一步加强对华为的出口限令。</p><p>美国商务部资深官员星期五上午在一场背景说明会上说，美国商务部正在与美国出口管制部门进行跨部门合作，在“设计”和“生产”两个方面封堵华为使用海外制造设施获取芯片的渠道。</p><p>这名官员说：“在设计方面，如果华为使用来源于美国的软件生产芯片，现在就需要执照。这些产品现在就要受到华为实体清单规定下的美国BIS执照规定的约束。”</p><p>在制造层面，这名官员表示，新的管制措施约束的着眼点是制造芯片所使用的技术和硬件设备。“如果这些产品是华为设计的、或者是由清单上华为的114个分支实体设计的，如果这些设计是通过使用美国控制的技术，特别是半导体设施和技术而生产，其产品就需要获得美国商务部的执照。”</p><p>美国以国家安全的名义，于2019年5月发布针对华为的“实体清单”。华为则试图壮大旗下的海思半导体走自力更生之路，但仍然指定上海的中芯国际和台湾台积电等厂商制造其设计的芯片。《纽约时报》说，中芯与台积电都使用美国的设备。</p><p>美国国务卿蓬佩奥星期五发表声明说，商务部此次为了阻挡华为绕过美国法律、扩大外国直接产品规则，进一步保护了美国安全与5G网络的安全性。</p><p>蓬佩奥在声明中说：“华为是一个不值得信任的供应商，是中国共产党的工具，听命于中共的指令。美国司法部已经起诉华为偷窃美国技术、帮助伊朗躲避制裁，美国商务部在2019年将华为列入实体清单。一年多来，美国国务院一直在与世界各地的盟友和合作伙伴分享我们对华为和其他不值得信任的供应商的了解。”</p><p>在美中两国政治与经济对弈中陷入两难的台积电日前宣布将在美国亚利桑那州投资120亿美元兴建晶圆厂，生产高端的5纳米芯片。</p><p>中国光大证券去年的一份报告显示，大多数芯片制造商依赖美国设备，这些公司包括科磊（KLA Corp）、泛林集团（Lam Research）以及应用材料公司（Applied Materials）。</p><p>美国德汇律师事务所（Dorsey &amp; Whitney）在提供给美国之音的一份出自该公司高级合伙人邓锦明（Nelson Dong）的分析中说：美国商务部的“这一新举措将影响到世界各地、特别是中国、台湾、韩国和日本的集成电路设计者和生产商。”</p><p>他说：“由于全球半导体行业往往非常依赖源自美国的半导体设计软件和美国的半导体制造设备，这一修订后的‘直接产品规则’可能会导致一些短期和长期的后果。”</p><p>新出口限令预计从5月15日开始计算的120天以后开始执行。执行细则尚未公布。</p><p>美国商务部宣布新的制裁后，中国共产党官方报纸《人民日报》旗下的《环球时报》立刻作出回应，其英文网站援引“中国政府消息人士”的话说，如果美国计划对华为实行半导体产品禁运，中国将采取“一系列反制措施”，例如将美国公司列入中国的“不可靠实体清单”，根据中国的网络安全法和反垄断法对苹果、高通和思科等公司进行调查和实施限令，和暂停购买波音飞机等。</p><p>不过，《环球时报》的报道并没有指出其消息来源的身份和姓名。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中芯国际获国家200亿注资，拟取代台积电曲线救华为</title>
      <link href="/2020/05/17/a204/"/>
      <url>/2020/05/17/a204/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载6park</p></blockquote><p>近日，来自中芯国际官方消息，国家集成电路基金会等多方同意分别向中芯南方注资15亿美元及7.5亿美元。消息已证实，中芯控股与国家集成电路基金等多方签订新合资合同及新增资扩股协议，中芯南方注册资本将由35亿美元增加至65亿美元，被新增注资金额折合人民币近200亿元。 </p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/hhPIyD.png" alt="hhPIyD">联想到近几天川建国那边捅出的幺蛾子，不难看出国家有意通过注资的方式助力中国芯片产业，曲线救华为的意图也十分清晰。要知道，这两天川建国曾宣布将阻止全球芯片制造商向华为出售或运输半导体芯片，且美国商务部也正在修改一项出口新规，计划从战略上直接针对华为收购通过美国软件和技术制造的半导体产品。 </p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/30GWcf.png" alt="30GWcf">从美国三次延期华为“临时通用许可”的行为来看，不是对华为的宽限，而是给使用华为设备的用户的美国运营商提供空间，特别是针对美国农村地区的用户和运营商，要求加快向替代供应商过渡。而且川建国也在酝酿着修改“外国直接产品”再出口规则，意在限制台积电等重要供应商继续向华为供应半导体产品。联系到台积电计划斥资120亿美元在亚利桑那州建造芯片工厂的举动，不难看出川建国的指令正在逐步生效，华为被“卡脖子”似乎也将成为事实。 </p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/HZ3WdL.png" alt="HZ3WdL">现在华为积极自救，不但将自家电子设备零部件的国产替代率提升到41.8%，比遭受制裁前大大提升16.5%，将美国产电子设备零件比例压缩至总体的1.5%，还在新款5G机型上用自家海思半导体替代了美国大型通信芯片企业思佳讯的产品，为中国芯争了一口气。目前，拿华为Mate30 5G版为例，非国产零部件除了日本的摄像头、闪存和双工器等，以及韩国的显示器、DRAM和触摸屏外，只有机身的玻璃盖板依赖美国康宁公司。而这一零部件在手机整体32美元的总成本中仅占3美元，且随时可以被中国产品替代，这一点从华为和京东方的合作中不难看出其可能性。 </p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Ls6EtC.png" alt="Ls6EtC"></p><p>另外，华为把14纳米芯片转到中芯国际研发生产，也有计划将7纳米芯片交给中芯作进一步研发。尽管中芯国际在短时间内很难替代台积电，至少在1-2年内难以实现超越，但国家资本的注入势必会加快中芯国际的研发速度，更加先进工艺的半导体产品将在中芯国际的操作台喷涌而出。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 芯片 </tag>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国人的“芯病”何去何从</title>
      <link href="/2020/05/16/f2b1/"/>
      <url>/2020/05/16/f2b1/</url>
      
        <content type="html"><![CDATA[<h1 id="中国芯片之殇"><a href="#中国芯片之殇" class="headerlink" title="中国芯片之殇"></a>中国芯片之殇</h1><p>2019年5月18日，美国将华为列入了“实体名单”。</p><p>所谓“实体名单”是美国为了维护其国家利益，作为出口管制的重要手段。进入到这个名单的公司，在没有得到美国政府许可的情况下，美国公司不能和名单上的企业合作。</p><p>简单说实体名单就是一份黑名单，企业一旦上榜就被剥夺了和美国进行贸易的机会，华为开始被美国政府掐住了喉咙。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Y8Rzld.png" alt="Y8Rzld"></p><p>尽管当时限制了美国公司和华为的合作，但华为还有一线生机。华为手里有自己的芯片设计公司：“一夜转正”的华为海思。</p><p>虽然华为没有芯片生产能力，所幸的是世界上最大的芯片代工企业是台湾的台积电，并不是一家美国公司。华为还能够通过台积电代加工得到自己的高性能芯片。</p><p>一年后的现在，美国对华为要落井下石。</p><p>2020年5月15日，美国商务部发布一则公告：一年前只是禁止美国公司和华为开展业务，现在美国限制了全世界所有的半导体工厂，这些工厂不管是哪个国家的，只要有使用到美国软件和设备，在为华为生产芯片之前，就必须获得美国政府的许可。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/GC5BGD.png" alt="GC5BGD"></p><p>▲美国商务部：华为破坏了实体名单限制华为使用美国科技生产产品</p><p>最狠的是这条禁令是无差别全面打击，不只是华为，所有需要美国软件、技术、设备的芯片制造商，不管是中国、日本、还是韩国企业，都逃不开美国的技术和设备。只要是为华为造芯片，就要受美国管制。</p><p>此令一出，中方表示，如果美国针对华为的方案实施，那么将予以强力反击，将相关企业列入“不可靠实体清单”，依照相关法律对高通、思科、苹果等美国企业展开限制与调查，甚至暂停采购波音客机。</p><p>一场科技封锁战的铁幕在大国之间落下已然是事实。</p><p><img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfmzibMuEf9SmWxdYiaLdV9HwZrvibV8nkic8y2nWZxLoERDuQsRtIrMFKx9moYox1IGrkGmXCsBE0ltQ/640?wx_fmt=gif" alt="img"></p><h1 id="01-信息时代“芯”是有多么重要"><a href="#01-信息时代“芯”是有多么重要" class="headerlink" title="01 信息时代“芯”是有多么重要"></a>01 信息时代“芯”是有多么重要</h1><p>我们常说如今社会步入了信息化时代，一个手机基本就能搞定每个人每天的所有诉求，玩“吃鸡”逛淘宝，外卖小哥顺着定位就能给你送餐到家，一个智能手机已经是时代标配。</p><p>从小小的手机，到大型工业设备设施的运行，乃至网络，电力，国防，没有一个环节离不开硬件的支撑。而硬件之核心，乃是芯片。</p><p>抛开芯片谈信息技术发展，就如同跟陌生女孩聊结婚，都是耍无赖行为。</p><p>而信息时代中这些社会运转的基础就是芯片，中国人需要的芯片有多依赖进口？看这样一组数据。</p><p>中国高端芯片完全不能自给自足，80%依赖进口。去年中国进口芯片花掉3000多亿美元，是进口原油价格的两倍，约等于中国军费的两倍，相当于造80艘航空母舰的开销。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/tIjojk.png" alt="tIjojk"></p><p>据《G20国家创新竞争力黄皮书》显示：中国在军用航天级芯片上基本能实现自给自足，中低档的芯片甚至满足自己的需要外还能大量出口，但是在高端芯片上进口依赖度飙升，80%靠进口。</p><p>电子消费级市场也很难见到中国自己的高端芯片。每个人离不开的电脑手机，其中高端芯片基本是国外产品的天下，有时候事实体现在钱上更有说服力。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/EcHCwq.png" alt="EcHCwq"></p><p>▲2018年进口额达到3120.58亿美元图片来自：中商产业研究院</p><p>从2012年开始，中国集成电路进口额连续突破2000亿美元，2000亿美元什么概念？按照2017年汇率来算，2000亿美元折合人民币是13200亿人民币。</p><p>2017年中国军费开支是10433亿人民币，如果按照网上所言，山东舰造价250亿人民币左右（不包含舰载机等费用），2018年中国进口芯片的开支也就比军费多出来10艘辽宁舰吧！</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/JcJa1w.png" alt="JcJa1w"></p><p>▲2019原油进口额1662亿美元图片来自：中商产业研究院</p><p>2019年中国集成电路进口额更是达到了3055亿美元（21048亿人民币），占中国整年总进口额的14.7%，同年中国原油进口额是1662亿美元约为芯片进口额的一半。</p><p>10年前美国杂志《连线》一篇文章开篇中写到：“试想，一个国家需要完全依靠从一个与之有着战事冲突或者经济往来不稳定的国家进口某种珍贵商品，而且没有这种商品，其整个社会将被迫停顿。假如这个国家是中国，与之有冲突的国家是美国，而该商品就是芯片。”</p><p>中国、美国、贸易冲突、芯片，《连线》杂志一语成谶。中方的反制措施当然很有必要，但是依然无法掩饰中国在芯片领域的落后。</p><p>指甲盖大小的芯片，已然成为这场大国较量中的主角。</p><h1 id="02-芯片怎么造？"><a href="#02-芯片怎么造？" class="headerlink" title="02 芯片怎么造？"></a>02 芯片怎么造？</h1><p>芯片是世界上最硬核的高科技产业，以纳米来计量的制造过程极为复杂，产业链涉及到50多个行业、数千个环节，世界上没有多少公司能够包办芯片生产的所有环节，芯片产业形成一条齐整的产业链。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/FHpv6U.png" alt="FHpv6U"></p><p>总的来说有芯片设计、芯片制造、芯片封测、芯片材料、芯片设备这5大类，整个产业链条里，中国占据的份额极少。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/UE39V3.png" alt="UE39V3"><br>▲芯片设计公司华为海思排名第5</p><p> 为了方便大家更直观的了解芯片，不妨通过一个有意思的比方来讲。</p><p>我们如果把做芯片看作厨师做菜，那么做好一个菜，首先要有好的食材，然后你这个厨子做菜的炊具要好，最后当然是你这个厨子肚子里面有没有好的菜谱。</p><p>做芯片粗看一下也可以理解成这么几块，首先要有好的原材料，还要有好的生产制作工具，而且还要有优秀的芯片设计，这三个能力OK，好的芯片才能做出来。</p><p>先说“食材”部分</p><p>芯片听起来挺高级，制造原料实际是蓝星最不值钱的沙子。芯片主要的原材料是硅，硅元素在地球上的储量仅次于氧元素。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/QRGe2J.png" alt="QRGe2J"></p><p>▲芯片的原材料就是长这样</p><p>如果你家门口有一堆沙，那么恭喜你已经有了制造高性能芯片的原材料，可也仅仅是原材料。</p><p>沙子很多，但是难得是要把沙子里的硅提纯出来，如果要生产高性能芯片，一般的硅纯度完全不够，需要纯度达到99.999999999%的电子级多晶硅，这么9不是我瞎打的，一共9个9。</p><p>也就是说在100万个硅原子中最多只允许存在1个杂质原子，这个尺度放大一些，也就是说5000吨的电子级多晶硅杂质含量仅仅有1枚1元硬币那么多。 商场里的金饰为了标榜自己的高纯度，经常会有千足金的标签，也就是说金的纯度是99.999%，和千足金类比，那99.999999999%纯度的电子级多晶硅可以改个名字叫亿足硅。</p><p><img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfmzibMuEf9SmWxdYiaLdV9HwfmGtZxFujZoHib4ljwHuAGXiaarGSaRwwYJN2WjHdrbJBIsibb6xtvwMQ/640?wx_fmt=gif" alt="img"></p><p>▲沙子提纯单晶硅棒</p><p><img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfmzibMuEf9SmWxdYiaLdV9Hwic69cHCQiblzTDFqwu25GQw9e7IGGGMOeUJrxBiaLR9IGPF5WHI2Akq2Q/640?wx_fmt=gif" alt="img"></p><p>▲硅棒切割成晶圆 得到电子级多晶硅锭以后，将圆柱形的硅锭横向切割成圆形的单个硅片，叫做晶圆，切割好的晶圆表面几乎是完美无瑕的。</p><p>造芯片最基础的电子级多晶硅就是中国还没有迈过去的一个坎。</p><p>大厨想要做好菜，缺了好食材不行。在芯片材料方面日本一家独大。拿硅晶圆全球份额占比来说，日本公司占去50%，中国台湾地区17%，德国15%，韩国9%，这5个地区占去了全球94%的份额，在这里中国大陆没有名字。 <img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_jpg/RIQJDM7oiajfmzibMuEf9SmWxdYiaLdV9HwwklCw956CQicqO7ALjnp5sU5ialia1THZl7Z2Qr006luXxTNQMF650Jfw/640?wx_fmt=jpeg" alt="img"></p><p>▲世界芯片设备份额占比来源：招商证券</p><p>“厨师的工具与菜谱”</p><p>有了好的原材料“硅晶圆”之后就轮到大厨用菜刀按照菜谱处理了。“菜刀”就是生产芯片的设备，菜谱就是芯片的设计。</p><p>芯片设计通俗来说就是“写菜谱”的。以2018年统计数据为例，世界芯片设计产业中美国的博通、高通、英伟达霸榜前3名，第4名是中国台湾地区的联发科，第5名是中国大陆的华为海思。</p><p>芯片核心外表看起来很光滑，可芯片刻蚀不只是一层，要经过多次重复刻蚀，形成一个分层的立体结构，打个比方，相当于在一平方厘米的土地上盖高层写字楼一样，难度可想而知。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Mgprdp.png" alt="Mgprdp"></p><p>▲看似光滑的芯片表面，其实有多层复杂电路设计</p><p>美国在全球芯片设计领域市场占有率是68%，中国台湾地区市场占有率是16%位居第2，中国大陆则以13%的市场占有率位居第3。中国占比13%嫌低？在芯片产业链中，相比其他阶段，中国在芯片设计中表现是最好的。</p><p>华为海思就是这么一个“写菜谱”的。去年华为发布最新的手机处理芯片麒麟990采用7纳米工艺拥有103亿晶体管，是世界上首个突破百亿晶体管的手机处理器，总体性能可以和高通和苹果同类产品比肩。</p><p>菜谱写完以后完成后交给大厨去做菜，大厨就是芯片制造企业。世界上三大芯片制造巨头分别是中国台湾地区的台积电、韩国的三星和美国的英特尔。 <img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_jpg/RIQJDM7oiajfQBuKEMvicG8vAan91jBdMEHb16CLmlFAIBCkfyRdpzR4ylg1IZaL2wiacpplJIUMBU4zDzbESMrNw/640?wx_fmt=jpeg" alt="img"></p><p>▲全球前五的芯片制造企业</p><p>以排名第一的台湾台积电为例，台积电主营业务就是芯片代工，台积电现在以自己的7nm芯片生产线称霸江湖。台积电仅凭芯片代工就达到了2000亿美元市值，和中国中石油差距只有不到10%。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/GcBhFr.png" alt="GcBhFr"></p><p>▲台积电的标志就是一个晶圆</p><p>中国芯片制造方面顶尖的中芯国际只有28纳米的生产工艺，14纳米工艺才刚刚开始量产，中国芯片制造只能占到世界7.3%的份额。由于中国大陆没有能力生产这样的高规格芯片，华为的麒麟990只能交给中国台湾地区的台积电代工生产。</p><p>那么大厨有没有一把好刀呢？芯片制造设备公司就是生产“刀”的。可惜全球芯片设备制造产业集中在日本、荷兰、美国、韩国四个国家。而这把刀就是”光刻机“。</p><p>就是下图这个究极神器——光刻机，这个神器也是中国求之不得的。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/nhjH33.png" alt="nhjH33"></p><p>▲人类工业皇冠上的明珠——光刻机</p><p>荷兰的ASML基本垄断了高端光刻机领域，特别是最新的EUV极紫外光光刻机有生产7纳米制成的能力，ASML全球市场份额100%。 <img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfmzibMuEf9SmWxdYiaLdV9HwicNES06yDauIwzXxEPguOelUf90Cm9ousoXOC0qSdicuZknmVFqAHCdw/640?wx_fmt=gif" alt="img"></p><p>光刻机可以简单理解为：用“紫外线”作刀，对晶圆进行雕刻，让芯片上的电路变成人们想要的图案。四个字形容：“硅上雕花”</p><p>人类芯片的发展史其实就是芯片这几平方厘米的面积上锱铢必较的过程。1978年英特尔设计的8086处理器的刻蚀尺寸是3微米，2000年英特尔发布的奔腾4处理器刻蚀尺寸达到了0.09微米（90纳米）。</p><p>请大家记住90纳米这个数字，这是英特尔2000年的技术。之后2015年初发布的第五代酷睿处理器，刻蚀尺寸为14纳米。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/cSmQL1.png" alt="cSmQL1"></p><p>▲英特尔90纳米的奔腾4处理器</p><p>2019年AMD发布了7nm的三代锐龙处理器，40年间人类处理器刻蚀尺寸从3微米（3000纳米）到7纳米，翻了400多倍。</p><p>在知乎上有这样一个问题“搞光刻机难还是搞氢弹难？” <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Cpjp8y.png" alt="Cpjp8y"></p><p>光刻机被誉为”人类工业皇冠上的明珠“不是没有道理的。有人这样形容光刻机：这是一种集合了数学、光学、流体力学、高分子物理与化学、表面物理与化学、精密仪器、机械、自动化、软件、图像识别领域顶尖技术的产物。</p><p>先进的光刻机上有10w个零件，（一辆汽车大概是5000个零件）。</p><p>难道中国人就造不出自己的光刻机了吗？也不是，我们能造落后别人好几代的国产光刻机，别小看这个能力，关键时候，这个能力至少能保证国家的国防等重大领域不被卡脖子。</p><p>国内上海微电子芯片公司的光刻机水平最高，刚刚突破90纳米工艺，90纳米是英特尔2000年奔腾4处理器的水平，距离7纳米顶尖水平还有差好几个珠穆朗玛峰。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/OVNR2i.png" alt="OVNR2i"></p><p>▲上海微电子芯片公司SSA600/20最高能达才达到90纳米分辨率</p><p>很多朋友可能会有疑问，既然造不出来，买不行么？咱国家现在也不差钱呀？</p><p><img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfQBuKEMvicG8vAan91jBdMEMFZC3Rm5ydWjgNQJWnootD0TBydzSa8zx2b6luf9iayOA0gzI3tKR9g/640?wx_fmt=gif" alt="img"></p><p>不好意思，有时候真不是有钱就能为所欲为的。想买？不给！</p><p>1996年，美国和他的小伙伴们签署了一个叫做《瓦森纳安排》的协定，没错这个协定就叫做“安排”，目的就是把那些不听美国话的国家给他安排的明明白白。</p><p>瓦森纳安排签署的国家有42个，美国、韩国、日本、德国、荷兰等国家都在列，囊括了几乎所有西方发达国家，中国、伊朗、利比亚等国被纳入受限制国家。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/5eOs0L.png" alt="5eOs0L"></p><p>▲瓦森纳安排缔约国家世界上主要国家都在这里了</p><p>瓦森纳安排包含两份控制清单：一份是军民两用商品和技术清单，涵盖了先进材料、材料处理、电子器件、计算机、电信与信息安全、传感与激光、导航与航空电子仪器、船舶与海事设备、推进系统等9大类；另一份是军品清单，涵盖了各类武器弹药、设备及作战平台等共22类，清单长达234页。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/NcpXjN.png" alt="NcpXjN"></p><p>▲绿色为签署瓦森纳安排的国家</p><p>签约国家严禁对中国这些被安排国家清单中的高科技和武器。瓦森纳安排虽然允许成员国在自愿的基础上对各自的技术出口实施控制，但实际上成员国在重要的技术出口决策上受到美国的影响。光刻机之类的究极神器，中国想都不要想。</p><p>最狠的是瓦森纳安排还不断在调整，针对中国发展情况围追堵截。2020年初，瓦森纳安排管制品类扩大，新增了“可转为军用的半导体制造材料及网络软件”。实在是劳美国费心了，在遏制中国半导体产业的路上兢兢业业。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/dbtB4H.png" alt="dbtB4H"></p><p>如前文所说，荷兰的ASML公司在光刻机领域是当之无愧的老大，最新的极紫外光EUV光刻机能够生产7纳米的CPU，世界上只此一家别无分号，市场份额100%。现在世界主流处理器都开始步入7纳米行列，想生产7纳米芯片就必须有ASML的EUV光刻机。</p><p>既然完全垄断，那价格也是ASML自己说了算，价格不贵1亿美元一台。</p><p>1亿美元对中国来说不算啥，北京二环内几套房而已。一年3000亿美元芯片进口费用，拿几亿出来买EUV也不算啥。</p><p>有钱想买，可惜却买不到。</p><p>2018年中国最大的芯片制造企业向荷兰的ASML花了1.2亿美金订购了一台EUV光刻机，两年过去了，这台光刻机还没拿到荷兰的出口许可。而中国台湾的台积电去年从ASML拿到了十几台EUV光刻机。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/4SUFpJ.png" alt="4SUFpJ"></p><p>▲19年ASML的EUV光刻机一半交付台湾地区的台积电</p><p>就连最基础的电子级多晶硅中国有太多课要补。中国的工业硅、多晶硅产量世界第一，可制造芯片用的高纯度电子级多晶硅完全依赖进口。 回到上面那个问题：芯片难造还是氢弹难造？造好用的芯片难。</p><p>氢弹不是商品，不需要考虑市场，不需要考虑高速换代，不需要考虑企业生存，不需要考虑性价比，氢弹要考虑的是按下按钮的那一刻，炸响。</p><p>最终芯片经过一系列复杂的程序，最后的成品长下面这个样子：</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/cziYlN.png" alt="cziYlN"></p><p>▲中间黑色部分就是芯片的核心</p><p>所以从上面的介绍，大家应该清楚了我们目前的处境，一个懂一些菜谱的厨师，没有好的食材，没有好的炊具，想做出上等佳肴来，太难了。</p><p><img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfQBuKEMvicG8vAan91jBdMEpSnCmHbR2lshOn4aZOlmnDB2IdzlhrFezbqNpMhxHRRShAUm6icNvZg/640?wx_fmt=gif" alt="img"></p><h1 id="03-中国对“芯”的渴望"><a href="#03-中国对“芯”的渴望" class="headerlink" title="03 中国对“芯”的渴望"></a>03 中国对“芯”的渴望</h1><p>有人说，中国为什么不早点搞自己的芯片？搞过。 现在美国对华为封锁，让很多人开始关心中国芯片的发展历程，其实20年前中国搞芯片的热情比现在还要大。 20年前我们国家提出口号，要发展自己的半导体产业。2000年左右是中国芯片发展的黄金时期，1999年北大研制了中国第一个完全自主研发的CPU架构。</p><p>这是中国人最荣耀的时刻，《人民日报》在20世纪的最后一天刊文，称这一成果是“献给新千年的礼物”。可尚在摇篮里的中国芯片毁在了一个骗子手里。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Q2Dz51.png" alt="Q2Dz51"></p><p>▲人民日报：献给新千年的礼物 2003年，上海交大微电子学院的院长陈进，带领自己的团队搞出了一个芯片，叫做“汉芯一号”。有关部门对“汉芯一号”做了测试，得出结论让所有人震惊：汉芯一号已经接近了国际先进水平，一些方面甚至实现了超越。</p><p>这对当时幼小的中国半导体产业来说，就是饿极了想吃个馒头，没想到天上掉下来一大盆红烧肉。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/d84pMO.png" alt="d84pMO"></p><p>▲汉芯一号处理器</p><p>陈进被视为是汉芯一号的发明人，更是荣誉加身，授予长江学者称号，随后陈进的“汉芯二号”“汉芯三号”“汉芯四号”项目成功上马，陈进也得到了国家的数亿科研经费。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/7HP7gI.png" alt="7HP7gI"></p><p>▲陈进其人</p><p>关于汉芯的荣誉到了2006年戛然而止。清华大学论坛上一个名叫“汉芯黑幕”的帖子曝光汉芯造假。</p><p>经过调查，汉芯一号根本就是一个骗局，这枚举世瞩目的芯片其实是陈进从美国摩托罗拉买的56800芯片，找几个装修师傅打磨掉摩托罗拉的字样，再印上“汉芯一号”，就变成了中国自主研发的芯片。</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/5gXD6H.png" alt="5gXD6H"></p><p>▲打磨汉芯的民工日记 甚至负责打磨字样的师傅声称自己负责了汉芯的外观设计，这可是中国最有牌面的民工师傅了。</p><p>民工师傅牛皮吹爽了，可中国芯片很不爽。从这以后中国没有人再敢去搞芯片，谁知道你是不是搞得假的？</p><p>新项目上马的时候主管部门审核也变得极为谨慎，谁知道你是不是想套经费？一盆假的“红烧肉”，让中国芯片连吃“馒头”都变得谨慎了起来。 04</p><p>芯片，勒紧裤腰带也得搞</p><p> 2007年秋天，以色列出动战斗机炸毁了叙利亚的一处核设施。</p><p>出动的是F15/F16这样的非隐身战斗机，但是叙利亚严密的防空体系毫无反应。有趣的是，在以色列突袭前一天叙利亚的防空系统雷达刚好坏了，本来以为是正常的损坏，最后才发现是雷达CPU的后门引起的。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/Y0qwFG.png" alt="Y0qwFG"></p><p>▲叙利亚设施被摧毁</p><p>叙利亚不是最后一个。2013年伊朗核离心机几千台莫名其妙损坏，几千台离心机疯狂开转，转坏为止。最后发现也是核离心机控制系统出了问题，处理器早就被动了手脚。 <img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/p7DtF4.png" alt="p7DtF4"></p><p>现在轮到了中国。</p><p>日经中文网报道，其实在去年美国开始针对华为之后，日本人通过拆解华为手机后，发现华为最高端新机型中国产零件的使用率已经从25%左右大幅上涨到42%，与此同时美国产零部件则从11%左右降到了约1%。</p><p>今天，华为在心声社区发了一张内涵颇深的图</p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/w1Jno7.png" alt="w1Jno7"></p><p>让我想起一句名言，大意是“阻碍弱者前进路上的花岗岩，会成为强者脚下的垫脚石。“</p><p>想当年美国人用原子弹威胁过我们，苏联人叫嚣着要对我们实施外科手术式的核打击，尽管这样，咱们屈服了吗？没有。</p><p>我们国家当年一穷二白不都照样挺过来么，还搞出了自己的核武器，新中国成立以来就从没怕过谁威胁。</p><p><img src="https://i1.wp.com/mmbiz.qpic.cn/mmbiz_gif/RIQJDM7oiajfQBuKEMvicG8vAan91jBdME4PBDdADOYHJ9w0LgrIEkL6d5A04YftawAdSr4NugKUwBG2PYtthLbA/640?wx_fmt=gif" alt="img"></p><p>▲又想威胁我？NO！去你妈的</p><p>中国人的芯片之路必然艰辛，除了义无反顾，我们别无选择。</p>]]></content>
      
      
      <categories>
          
          <category> 科技观察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to modify ova file</title>
      <link href="/2020/01/10/55d2/"/>
      <url>/2020/01/10/55d2/</url>
      
        <content type="html"><![CDATA[<h1 id="Extract-the-ova-file"><a href="#Extract-the-ova-file" class="headerlink" title="Extract the ova file"></a>Extract the ova file</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf vmName.ova</span><br></pre></td></tr></table></figure><h1 id="Modify-ovf-for-some-invalid-tag"><a href="#Modify-ovf-for-some-invalid-tag" class="headerlink" title="Modify ovf for some invalid tag"></a>Modify ovf for some invalid tag</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vi vmName.ovf</span><br></pre></td></tr></table></figure><h1 id="Re-calculate-sha1-from-vmName-ovf-then-modify-the-hash-value-of-vmName-mf"><a href="#Re-calculate-sha1-from-vmName-ovf-then-modify-the-hash-value-of-vmName-mf" class="headerlink" title="Re-calculate sha1 from vmName.ovf, then modify the hash value of vmName.mf"></a>Re-calculate sha1 from vmName.ovf, then modify the hash value of vmName.mf</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sha1sum vmName.ovf</span><br><span class="line">$ vi vmName.mf</span><br></pre></td></tr></table></figure><h1 id="Package-to-ova-which-source-files-from-vmName-ovf-vmName-disk1-vmdk-vmName-mf"><a href="#Package-to-ova-which-source-files-from-vmName-ovf-vmName-disk1-vmdk-vmName-mf" class="headerlink" title="Package to ova which source files from [vmName.ovf, vmName-disk1.vmdk, vmName.mf]"></a>Package to ova which source files from [vmName.ovf, vmName-disk1.vmdk, vmName.mf]</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf vmName-NEW.ova vmName.ovf vmName-disk1.vmdk vmName.mf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ova </tag>
            
            <tag> vmdk </tag>
            
            <tag> ovftool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIP系统完整性保护怎么禁用？SIP系统完整性关闭方法</title>
      <link href="/2020/01/08/69ef/"/>
      <url>/2020/01/08/69ef/</url>
      
        <content type="html"><![CDATA[<blockquote><p>许多Mac用户反应，装了部分软件后打不开，那可能是sip系统完整性没有关闭。下面我们就来看一下如何关闭sip系统完整性。</p></blockquote><blockquote><p>系统完整性保护是 OS X El Capitan 及更高版本所采用的一项安全技术，能够帮助防止潜在恶意软件修改 Mac 上受保护的文件和文件夹。系统完整性保护可以限制 root 用户帐户，以及 root 用户能够在 Mac 操作系统的受保护部分完成的操作。</p></blockquote><p>上面是官方的介绍，说的有点吓人。<code>我们换一个说法，SIP类似windows的防火墙，安卓手机Root</code>，这应该可以解决很多的人困惑。</p><p>苹果应用商店的软件都是用沙盒运行的，无法访问系统文件，所以大部分软件都是阉割版的。很多优秀软件没有在Apple Store上架就是因为需要SIP系统权限，苹果不过审核，一些软件采取双版本，分为官方版和App Store版，App Store 是精简单版，全功能版需要单独下载，都是这个原因。比如腾讯柠檬之类的系统应用。</p><ol><li>macOS默认只允许运行通过苹果应用商店下载的软件。</li><li>macOS如果想安装第三方应用需要到<code>系统偏好设置 》 安全性与隐私 》 通用</code>中开启允许<code>App Store 和被认可的开发者</code>选项</li><li>macOS如果想安装第三方未签名的应用需要在终端中执行命令行 <code>sudo spctl --master-disable</code> 开启<code>任何来源</code>选项，<code>系统偏好设置 》 安全性与隐私 》 通用</code> 中默认是没有这个选项的。</li><li>macOS如果想安装一些反编译破解的应用需要关闭SIP。</li></ol><p>通过上面大家也应该能看出来，苹果为了大家的安全煞费苦心，但是事情仅仅真的是只是大家看到的这样的吗？</p><p>你想要安装任意来源的软件，需要打开终端输入命令才可以，你要关闭SIP需要关机才可以操作（在macOS早期系统是不需要关机的），为什么越来越麻烦呢？</p><p>上架到苹果应用商店，每卖一次，苹果抽成1/3。比如你软件卖100元，苹果抽33.33元。</p><p>所谓的认可的开发者就是去苹果买开发者账号，然后用开发者账号对应用进行签名。购买苹果的开发者账号，个人99美元/年，约合人民币688元/年。企业299美元/年，约合人民币2000元/年。</p><p>买完对应用签名一下就不是恶意软件了，你说搞笑不搞笑？</p><p>不搞得麻烦一点，怎么让小白害怕，不搞得麻烦一点，苹果商店怎么赚钱？真是万恶的资本主义！！！</p><hr><p>废话不多说了，切入正题吧。</p><p><code>目前最新的10.15.x系统使用破解软件基本上都需要关闭SIP才可以打开，就算是正版软件也有大量需要关闭SIP的，是需要永久关闭！</code>，不要再问类似 [Sip关了还能再打开吗] 这样的问题了。</p><h5 id="看了上面的说明，还是不放心开放系统权限，那你有下面的选择，"><a href="#看了上面的说明，还是不放心开放系统权限，那你有下面的选择，" class="headerlink" title="看了上面的说明，还是不放心开放系统权限，那你有下面的选择，"></a>看了上面的说明，还是不放心开放系统权限，那你有下面的选择，</h5><ul><li>我不绝不关闭SIP，我不要用这个软件了！</li></ul><h2 id="在sip系统完整性关闭前，我们先检查是否启用了SIP系统完整性保护"><a href="#在sip系统完整性关闭前，我们先检查是否启用了SIP系统完整性保护" class="headerlink" title="在sip系统完整性关闭前，我们先检查是否启用了SIP系统完整性保护?"></a>在sip系统完整性关闭前，我们先检查是否启用了SIP系统完整性保护?</h2><p>打开终端输入以下命令并回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil status</span><br></pre></td></tr></table></figure><p>你会看到以下信息中的一个，指示SIP状态</p><p>已打开:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System Integrity Protection status: enabled.</span><br></pre></td></tr></table></figure><p>已关闭:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System Integrity Protection <span class="keyword">status</span>: disabled</span><br></pre></td></tr></table></figure><p>![image-20200108180318851](/Users/dhrsong/Library/Application Support/typora-user-images/image-20200108180318851.png)</p><h2 id="Mac上-sip系统完整性关闭方法具体操作步骤如下："><a href="#Mac上-sip系统完整性关闭方法具体操作步骤如下：" class="headerlink" title="Mac上 sip系统完整性关闭方法具体操作步骤如下："></a>Mac上 sip系统完整性关闭方法具体操作步骤如下：</h2><ol><li>关机，然后重新启动你的Mac电脑，在开机时一直按住Command+R迸入Recovery模式。</li><li>进入Recovery模式后打开终端，如图：</li></ol><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/NsiF6f.png" alt="NsiF6f"></p><ol><li>在终端上输入命令 csrutil disable然后回车。</li></ol><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/JEsowh.png" alt="JEsowh"></p><ol><li>点击左上角苹果图标，再点击重新启动</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Spring全家桶7大知识点</title>
      <link href="/2019/12/30/9b0a/"/>
      <url>/2019/12/30/9b0a/</url>
      
        <content type="html"><![CDATA[<p>Spring框架自诞生以来一直备受开发者青睐，有人亲切的称之为：Spring 全家桶。它包括SpringMVC、SpringBoot、Spring Cloud、Spring Cloud Dataflow等解决方案。<br>很多研发人员把spring看作心目中最好的java项目，没有之一。<br>所以这是重点也是难点，工作中必须会，面试时肯定考。</p><p><strong>那么，今天花费10分钟，梳理Spring框架相关知识。</strong></p><h1 id="Spring知识点-汇总"><a href="#Spring知识点-汇总" class="headerlink" title="Spring知识点-汇总"></a>Spring知识点-汇总</h1><p>spring系列包含非常多的项目，可以满足java开发中的方方面面。先来看常用框架的知识点汇总，如图：<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/vaNdQc.jpg" alt=""></p><h1 id="一、5个常用的spring框架"><a href="#一、5个常用的spring框架" class="headerlink" title="一、5个常用的spring框架"></a><strong>一、5个常用的spring框架</strong></h1><h2 id="spring-framework"><a href="#spring-framework" class="headerlink" title="spring framework"></a>spring framework</h2><p>也就是我们经常说的spring框架，包括了ioc依赖注入，Context上下文、bean管理、springmvc等众多功能模块，其它spring项目比如spring boot也会依赖spring框架。</p><h2 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h2><p>它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。<br />Spring Boot的核心思想是约定大于配置，应用只需要很少的配置即可，简化了应用开发模式。</p><h2 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h2><p>是一个数据访问及操作的工具集，封装了多种数据源的操作能力，包括：jdbc、Redis、MongoDB等。</p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>是一套完整的微服务解决方案，是一系列不同功能的微服务框架的集合。Spring Cloud基于Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。比如sleuth提供了全链路追踪能力，Netflix套件提供了hystrix熔断器、zuul网关等众多的治理组件。config组件提供了动态配置能力，bus组件支持使用RabbitMQ、kafka、Activemq等消息队列，实现分布式服务之间的事件通信。</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>主要用于快速构建安全的应用程序和服务，在Spring Boot和Spring Security OAuth2的基础上，可以快速实现常见安全模型，如单点登录，令牌中继和令牌交换。你可以了解一下oauth2授权机制和jwt认证方式。oauth2是一种授权机制，规定了完备的授权、认证流程。JWT全称是JSON Web Token，是一种把认证信息包含在token中的认证实现，oauth2授权机制中就可以应用jwt来作为认证的具体实现方法。</p><h1 id="二、Struts的具体作用"><a href="#二、Struts的具体作用" class="headerlink" title="二、Struts的具体作用"></a>二、Struts的具体作用</h1><p>struts是曾经非常火爆的web组合ssh中的控制层。我们知道web服务一般都采用MVC分层模型构建，就是model层负责内部数据模型，controller负责请求的分发控制，view层负责返回给用户展示的视图。struts实现的就是其中控制层的角色。<br />Struts采用Filter实现，针对类进行拦截，每次请求就会创建一个Action。使用struts的SSH组合已经逐渐被使用springMVC的SSM组合代替，也就是Spring-MVC+Spring+MyBatis的组合，一方面原因是由于struts对几次安全漏洞的处理，让大家对struts的信心受到影响；另一方面，springmvc更加的灵活，不需要额外配置，不存在和spring整合等问题，使用更加方便，所以建议以SSM框架的学习为主。</p><h1 id="三、常用的ORM框架"><a href="#三、常用的ORM框架" class="headerlink" title="三、常用的ORM框架"></a>三、常用的ORM框架</h1><p>ORM就是对象关系匹配，是为了解决面向对象与关系数据库存在的互不匹配的问题。简单来说，就是把关系数据库中的数据转换成面向对象程序中的对象。<br />常用的ORM框架有Hibernate和MyBatis，也就是ssh组合和ssm组合中的h与m。<br /><strong>它们的特点和区别如下：</strong><br />Hibernate对数据库结构提供了完整的封装，实现了POJO对象与数据库表之间的映射，能够自动生成并执行SQL语句。只要定义了POJO 到数据库表的映射关系，就可以通过Hibernate提供的方法完成数据库操作。Hibernate符合JPA规范，就是Java持久层API。<br />mybatis通过映射配置文件，将SQL所需的参数和返回的结果字段映射到指定对象，mybatis不会自动生成sql，需要自己定义sql语句，不过更方便对sql语句进行优化。<br />总结起来：</p><ol><li>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。mybatis，简单、高效、灵活，但是需要自己维护sql；</li><li>hibernate功能强大、全自动、适配不同数据库，但是非常复杂，灵活性稍差。</li></ol><h1 id="四、Netty简介"><a href="#四、Netty简介" class="headerlink" title="四、Netty简介"></a>四、Netty简介</h1><p>Netty是一个高性能的异步事件驱动的网络通信框架，Netty对JDK原生NIO进行封装，简化了网络服务的开发。下文会详细讲解<br />另外，同类型的框架还有mina、grizzly，不过目前使用的相对较少，一般不会在面试中出现，可以作为兴趣简单了解。</p><h1 id="五、RPC服务"><a href="#五、RPC服务" class="headerlink" title="五、RPC服务"></a>五、RPC服务</h1><p>Motan、Dubbo、gRPC都是比较常用的高性能rpc框架，可以提供完善的服务治理能力，java版本的通信层都是基于前面提到的Netty实现。它们的特点稍后介绍。</p><h1 id="六、其他常用框架"><a href="#六、其他常用框架" class="headerlink" title="六、其他常用框架"></a>六、其他常用框架</h1><p>jersy和restEasy都是可以快速开发restful服务的框架。<br />和springmvc相比，这两个框架都是基于jax-rs标准，而springmvcs基于servlet，使用自己构建的API，是两个不同的标准。<br />shiro框架是一个与spring security类似的开源的权限管理框架，用于访问授权、认证、加密及会话管理。能够支持单机与分布式session管理。<br />相比security，shiro更加简单易用。</p><p><strong>本篇文章将重点阐述Spring相关知识点，其他框架请期待下一篇</strong></p><h1 id="Spring知识点-详解"><a href="#Spring知识点-详解" class="headerlink" title="Spring知识点-详解"></a>Spring知识点-详解</h1><h2 id="一、spring基本概念"><a href="#一、spring基本概念" class="headerlink" title="一、spring基本概念"></a>一、spring基本概念</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/PsImmN.jpg" alt="PsImmN"><br>Sping中的基本概念<br />本文涉及的流程与实现默认都是基于最新的5.x版本。<br />spring中的几个重要概念如下：</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC，就是控制反转，如最左边，拿公司招聘岗位来举例：<br />假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，如图中向上的箭头，这就是控制反转。<br />在spring中，对象的属性是由对象自己创建的，就是正向流程；如果属性不是对象创建，而是由spring来自动进行装配，就是控制反转。这里的DI也就是依赖注入，就是实现控制反转的方式。正向流程导致了对象于对象之间的高耦合，IOC可以解决对象耦合的问题，有利于功能的复用，能够使程序的结构变得非常灵活。</p><h3 id="context上下文和bean"><a href="#context上下文和bean" class="headerlink" title="context上下文和bean"></a>context上下文和bean</h3><p>spring进行IOC实现时使用的有两个概念：context上下文和bean。<br />如中间图所示，所有被spring管理的、由spring创建的、用于依赖注入的对象，就叫做一个bean。Spring创建并完成依赖注入后，所有bean统一放在一个叫做context的上下文中进行管理。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP就是面向切面编程。如右面的图，一般程序执行流程是从controller层调用service层、然后service层调用DAO层访问数据，最后在逐层返回结果。<br />这个是图中向下箭头所示的按程序执行顺序的纵向处理。但是，一个系统中会有多个不同的服务，例如用户服务、商品信息服务等等，每个服务的controller层都需要验证参数，都需要处理异常，如果按照图中红色的部分，对不同服务的纵向处理流程进行横切，在每个切面上完成通用的功能，例如身份认证、验证参数、处理异常等等、这样就不用在每个服务中都写相同的逻辑了，这就是AOP思想解决的问题。<br />AOP以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。</p><h2 id="二、spring框架"><a href="#二、spring框架" class="headerlink" title="二、spring框架"></a>二、spring框架</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/GCCqBa.jpg" alt="GCCqBa"><br>Spring框架组件<br>上图列出了spring框架主要包含的组件。这张图来自spring4.x的文档。目前最新的5.x版本中右面的portlet组件已经被废弃掉，同时增加了用于异步响应式处理的WebFlux组件。<br />并不需要对所有的组件都详细了解，只需重点了解最常用的几个组件实现，以及知道每个组件用来实现哪一类功能。<br />图中红框是比较重要的组件，core组件是spring所有组件的核心；bean组件和context组件我刚才提到了，是实现IOC和依赖注入的基础；AOP组件用来实现面向切面编程；web组件包括springmvc是web服务的控制层实现。</p><h2 id="三、spring中机制和实现"><a href="#三、spring中机制和实现" class="headerlink" title="三、spring中机制和实现"></a>三、spring中机制和实现</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/cMVJi5.jpg" alt="cMVJi5"></p><h3 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h3><p>AOP的实现是通过代理模式，在调用对象的某个方法时，执行插入的切面逻辑。实现的方式有动态代理也叫运行时增强，比如jdk代理、CGLIB；静态代理是在编译时进行织入或类加载时进行织入，比如AspectJ。<br>关于AOP还需要了解一下对应的Aspect、pointcut、advice等注解和具体使用方式。</p><h3 id="placeHolder动态替换"><a href="#placeHolder动态替换" class="headerlink" title="placeHolder动态替换"></a>placeHolder动态替换</h3><p>主要需要了解替换发生的时间，是在bean definition创建完成后，bean初始化之前，是通过实现BeanFactoryPostProcessor接口实现的。主要实现方式有PropertyPlaceholderConfigurer和PropertySourcesPlaceholderConfigurer。这两个类实现逻辑不一样，spring boot使用PropertySourcesPlaceholderConfigurer实现。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>需要了解spring 中对事务规定的隔离类型和事务传播类型。要知道事务的隔离级别是由具体的数据库来实现的，在数据库部分我会详细介绍。<br>事务的传播类型，可以重点了解最常用的REQUIRED和SUPPORTS类型。</p><h3 id="核心接口类"><a href="#核心接口类" class="headerlink" title="核心接口类"></a>核心接口类</h3><ul><li>ApplicationContext保存了ioc的整个应用上下文，可以通过其中的beanfactory获取到任意到bean；</li><li>BeanFactory主要的作用是根据bean definition来创建具体的bean；</li><li>BeanWrapper是对Bean的包装，一般情况下是在spring ioc内部使用，提供了访问bean的属性值、属性编辑器注册、类型转换等功能，方便ioc容器用统一的方式来访问bean的属性；</li><li>FactoryBean通过getObject方法返回实际的bean对象，例如motan框架中referer对service的动态代理就是通过FactoryBean来实现的。<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3>bean的scope是指bean的作用域，默认情况下是单例模式，这也是使用最多的一种方式；多例模式，即每次从beanFactory中获取bean都会创建一个新的bean。<br>request、session、global-session是在web服务中使用的scope，request每次请求都创建一个实例，session是在一个会话周期内保证只有一个实例。<br>global-session在5.x版本中已经不在使用，同时增加了Application和Websocket两种scope，分别保证在一个ServletContext与一个WebSocket中只创建一个实例。<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3>spring的事件机制需要知道spring定义的五种标准事件，具体事件可见上图，了解如何自定义事件和实现对应的applicationListener来处理自定义事件。<h2 id="spring应用相关"><a href="#spring应用相关" class="headerlink" title="spring应用相关"></a>spring应用相关</h2><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/ScLmyQ.jpg" alt="ScLmyQ"><h3 id="常用注释"><a href="#常用注释" class="headerlink" title="常用注释"></a>常用注释</h3><h4 id="类型类注释"><a href="#类型类注释" class="headerlink" title="类型类注释"></a>类型类注释</h4>类型类注释包括controller、service等，需要重点了解<br />其中component和bean注解的区别如下：<ul><li>@Component注解在类上使用表明这个类是个组件类，需要Spring为这个类创建bean。</li><li>@Bean注解使用在方法上，告诉Spring这个方法将会返回一个Bean对象，需要把返回的对象注册到Spring的应用上下文中。<h4 id="设置类注解"><a href="#设置类注解" class="headerlink" title="设置类注解"></a>设置类注解</h4>重点了解@Autowire和@Qualifier以及bytype、byname等不同的自动装配机制。<h4 id="web类注解"><a href="#web类注解" class="headerlink" title="web类注解"></a>web类注解</h4>主要以了解为主，关注@RequestMapping、@GetMapping、@PostMapping等路径匹配注解，以及@PathVariable、@RequestParam 等参数获取注解。<h4 id="功能类注解"><a href="#功能类注解" class="headerlink" title="功能类注解"></a>功能类注解</h4>包括@ImportResource引用配置、@ComponentScan注解自动扫描、@Transactional事务注解等等，这里不一一介绍了。<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3>需要了解配置spring的几种方式，xml文件配置、注解配置和使用api进行配置。<br />自动装配机制需要了解按类型匹配进行自动装配，按bean名称进行自动装配，构造器中的自动装配和自动检测等主要的四种方式。<br />还需要了解一下list、set、map等集合类属性的配置方式以及内部bean的使用。</li></ul></li></ul><h2 id="四、Spring的Context的初始化流程"><a href="#四、Spring的Context的初始化流程" class="headerlink" title="四、Spring的Context的初始化流程"></a>四、Spring的Context的初始化流程</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/PjJyQL.jpg" alt="PjJyQL"><br>Spring Context初始化流程<br />图中左上角是三种类型的context，xml配置方式的context、springboot的context和web服务的context。不论哪种context，创建后都会调用到AbstractApplicationContext类的refresh方法，这个方法是我们要重点分析的。</p><h3 id="refresh方法中，操作共分13步"><a href="#refresh方法中，操作共分13步" class="headerlink" title="refresh方法中，操作共分13步"></a>refresh方法中，操作共分13步</h3><ol><li>对刷新进行准备，包括设置开始时间、设置激活状态、初始化context环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的properties；</li><li>刷新并获得内部的bean factory；</li><li>对bean factory进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境bean；</li><li>为context的子类提供后置处理bean factory的扩展能力。如果子类想在bean定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法；</li><li>执行context中注册的bean factory后缀处理器；<blockquote><p>注：这里有两种后置处理器，一种是可以注册bean的后缀处理器，另一种是针对bean factory进行处理的后置处理器。执行的顺序是，先按优先级执行可注册bean的处理器，在按优先级执行针对beanfactory的处理器。对springboot来说，这一步会进行注解bean definition的解析。流程如右面小框中所示，由ConfigurationClassPostProcessor触发、由ClassPathBeanDefinitionScanner解析并注册到bean factory。</p></blockquote></li><li>按优先级顺序在beanfactory中注册bean的后缀处理器，bean后置处理器可以在bean初始化前、后执行处理；</li><li>初始化消息源，消息源用来支持消息的国际化；</li><li>初始化应用事件广播器。事件广播器用来向applicationListener通知各种应用产生的事件，是一个标准的观察者模式；</li><li>是留给子类的扩展步骤，用来让特定的context子类初始化其他的bean；</li><li>把实现了ApplicationListener的bean注册到事件广播器，并对广播器中的早期未广播事件进行通知；</li><li>冻结所有bean描述信息的修改，实例化非延迟加载的单例bean；</li><li>完成上下文的刷新工作，调用LifecycleProcessor的onFresh()方法以及发布ContextRefreshedEvent事件；</li><li>在finally中，执行第十三步，重置公共的缓存，比如ReflectionUtils中的缓存、AnnotationUtils中的缓存等等；</li></ol><p>至此，spring的context初始化完成。这里仅介绍了最主要的主流程，建议课后阅读源码来复习这个知识点，补全细节。</p><h2 id="五、Spring中bean的生命周期"><a href="#五、Spring中bean的生命周期" class="headerlink" title="五、Spring中bean的生命周期"></a>五、Spring中bean的生命周期</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/1BcbwS.jpg" alt="1BcbwS"><br>Spring中bean的生命周期<br><strong>面试中经常问到的bean的生命周期，先看绿色的部分，bean的创建过程:</strong></p><ol><li>调用bean的构造方法创建bean；</li><li>通过反射调用setter方法进行属性的依赖注入；</li><li>如果实现BeanNameAware接口的话，会设置bean的name；</li><li>如果实现了BeanFactoryAware，会把bean factory设置给bean；</li><li>如果实现了ApplicationContextAware，会给bean设置ApplictionContext；</li><li>如果实现了BeanPostProcessor接口，则执行前置处理方法；</li><li>实现了InitializingBean接口的话，执行afterPropertiesSet方法；</li><li>执行自定义的init方法；</li><li>执行BeanPostProcessor接口的后置处理方法。</li></ol><p>这时，就完成了bean的创建过程。在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。这部分也建议阅读源码加深理解。</p><h2 id="六、Spring扩展接口"><a href="#六、Spring扩展接口" class="headerlink" title="六、Spring扩展接口"></a>六、Spring扩展接口</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/7sNv8H.jpg" alt="7sNv8H"><br>Spring扩展接口对spring进行定制化功能扩展时，可以选择如下一些扩展点：</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>是beanFactory后置处理器，支持在bean factory标准初始化完成后，对bean factory进行一些额外处理。在讲context初始化流程时介绍过，这时所有的bean的描述信息已经加载完毕，但是还没有进行bean初始化。例如前面提到的PropertyPlaceholderConfigurer，就是在这个扩展点上对bean属性中的占位符进行替换。</p><h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>它扩展自BeanFactoryPostProcessor，在执行BeanFactoryPostProcessor的功能前，提供了可以添加bean definition的能力，允许在初始化一般bean前，注册额外的bean。例如可以在这里根据bean的scope创建一个新的代理bean。</p><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>提供了在bean初始化之前和之后插入自定义逻辑的能力。与BeanFactoryPostProcessor的区别是处理的对象不同，BeanFactoryPostProcessor是对beanfactory进行处理，BeanPostProcessor是对bean进行处理。<br /><strong>注：上面这三个扩展点，可以通过实现Ordered和PriorityOrdered接口来指定执行顺序。实现PriorityOrdered接口的processor会先于实现Ordered接口的执行。</strong></p><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>可以获得ApplicationContext及其中的bean，当需要在代码中动态获取bean时，可以通过实现这个接口来实现。</p><h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h3><p>可以在bean初始化完成，所有属性设置完成后执行特定逻辑，例如对自动装配对属性进行验证等等。</p><h3 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h3><p>用于在bean被销毁前执行特定的逻辑，例如做一些回收工作等。</p><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p>用来监听spring的标准应用事件或者自定义事件。</p><h2 id="七、springboot相关的知识点"><a href="#七、springboot相关的知识点" class="headerlink" title="七、springboot相关的知识点"></a>七、springboot相关的知识点</h2><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/UkH2xV.jpg" alt="UkH2xV"></p><h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1. 启动流程"></a>1. 启动流程</h3><p>主要步骤首先要配置environment，然后准备context上下文，包括执行applicationContext的后置处理、初始化initializer、通知listener处理contextPrepared和contextLoaded事件。最后执行refreshContext，也就是前面介绍过的AbstractApplicationContext类的refresh方法。</p><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><p>然后要知道在Spring Boot中有两种上下文，一种是bootstrap, 另外一种是application。<br />bootstrap是应用程序的父上下文，也就是说bootstrap会先于applicaton加载。bootstrap主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。bootstrap里面的属性会优先加载，默认也不能被本地相同配置覆盖。</p><h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3. 注解"></a>3. 注解</h3><p>@SpringBootApplication包含了@ComponentScan、@EnableAutoConfiguration、@SpringBootConfiguration三个注解。 而@SpringBootConfiguration注解包含了@Configuration注解。也就是springboot的自动配置功能。@Conditional注解就是控制自动配置的生效条件的注解，例如bean或class存在、不存在时进行配置，当满足条件时进行配置等等。</p><h3 id="4-特色模块"><a href="#4-特色模块" class="headerlink" title="4. 特色模块"></a>4. 特色模块</h3><ul><li>starter是springboot提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动配置进行bean的创建。例如需要使用web功能时，只需要在依赖中引入spring-boot-starter-web即可。</li><li>actuator是用来对应用程序进行监视和管理，通过restful api请求来监管、审计、收集应用的运行情况。</li><li>devtools提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</li><li>CLI就是命令行接口，是一个命令行工具，支持使用Groovy脚本，可以快速搭建spring原型项目。</li></ul><p>以上为Spring框架需要掌握的内容，前面提到的核心机制、核心流程，建议阅读源码加深理解。<br>以上内容摘取自《32个Java面试必考点》 第07讲：必会框架-Spring全家桶</p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 全家桶 10 Days - Day 1 Spring 家族的主要成员</title>
      <link href="/2019/12/30/f2b0/"/>
      <url>/2019/12/30/f2b0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Framework-History"><a href="#Spring-Framework-History" class="headerlink" title="Spring Framework History"></a>Spring Framework History</h1><ul><li>Born in 2002, the earliest Author Rod Johnson</li><li>Today, Spring 5.x, Support JDK 8-11 and Java EE 8.</li></ul><h1 id="Spring-The-source-for-modern-java"><a href="#Spring-The-source-for-modern-java" class="headerlink" title="Spring: The source for modern java"></a>Spring: The source for modern java</h1><p>Spring，始于框架，但不不限于框架<br>    <img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/oUY3eJ.jpg" alt="oUY3eJ"></p><h1 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h1><blockquote><p>用于构架企业应用的轻量级一站式解决方案</p></blockquote><h2 id="设计理理念"><a href="#设计理理念" class="headerlink" title="设计理理念"></a>设计理理念</h2><ul><li>⼒力力争让选择⽆无处不不在</li><li>体现海海纳百川的精神</li><li>保持向后兼容性</li><li>专注 API 设计</li><li>追求严苛的代码质量量</li></ul><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><blockquote><p>快速构架基于Spring的应用程序</p></blockquote><ul><li>快，非常快</li><li>开箱即用，按需改动</li><li>提供非功能特性</li><li>不用生成代码，没有XML配置</li></ul><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/DwpoV5.jpg" alt="DwpoV5"></p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="简化分布式系统的开发"><a href="#简化分布式系统的开发" class="headerlink" title="简化分布式系统的开发"></a>简化分布式系统的开发</h2><ul><li>配置管理理</li><li>服务注册与发现</li><li>熔断</li><li>服务追踪</li></ul><h1 id="Spring-5-x-的改变暗示了了什什么"><a href="#Spring-5-x-的改变暗示了了什什么" class="headerlink" title="Spring 5.x 的改变暗示了了什什么"></a>Spring 5.x 的改变暗示了了什什么</h1><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/OE30HW.jpg" alt="OE30HW"></p><h1 id="第一个Spring程序-Hello-Spring"><a href="#第一个Spring程序-Hello-Spring" class="headerlink" title="第一个Spring程序 Hello Spring"></a>第一个Spring程序 Hello Spring</h1><ol><li><p>Open IntelliJ</p></li><li><p>Create a new project</p></li><li><p>Choose Spring Initializr<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/Z1dDju.jpg" alt="Z1dDju"></p></li><li><p>Fill in the Project Metadata<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/Kd0ntJ.jpg" alt="Kd0ntJ"></p></li><li><p>Choose Dependencies: Spring Web and Spring Boot Actuator<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/sc3cGw.jpg" alt="sc3cGw"></p></li><li><p>Finish the project</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Springboot </tag>
            
            <tag> IntelliJ </tag>
            
            <tag> Java </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setup a Hexo Editor Environment on Mac</title>
      <link href="/2019/12/30/3803/"/>
      <url>/2019/12/30/3803/</url>
      
        <content type="html"><![CDATA[<p><a name="diUkv"></a></p><h1 id="Use-Upic-to-Upload-to-the-Image-Bed"><a href="#Use-Upic-to-Upload-to-the-Image-Bed" class="headerlink" title="Use Upic to Upload to the Image Bed"></a>Use Upic to Upload to the Image Bed</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install upic</span><br></pre></td></tr></table></figure><h2 id="Setup-Image-Bed-on-the-Github"><a href="#Setup-Image-Bed-on-the-Github" class="headerlink" title="Setup Image Bed on the Github"></a>Setup Image Bed on the Github</h2><ol><li><p>Generate the App Secret<br>Go to the Github-&gt;Setting-&gt;Developer Settings-&gt;Personal access tokens</p></li><li><p>Open uPic-&gt;Preferences, to add Github as the image bed<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/uksitl.jpg" alt="uksitl"></p></li><li><p>Set the github repo information<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/Kw2jG9.jpg" alt="Kw2jG9"></p></li></ol><h1 id="Prepare-Hexo-Env"><a href="#Prepare-Hexo-Env" class="headerlink" title="Prepare Hexo Env"></a>Prepare Hexo Env</h1><h2 id="Install-Node"><a href="#Install-Node" class="headerlink" title="Install Node"></a>Install Node</h2><p>There are many ways to install nodes. Most advanced users want to install multiple versions of nodes instead of one version only. To have multiple versions of node installed, I chose to use nvm.<br><a name="u1DzV"></a></p><h3 id="Install-nvm-via-brew"><a href="#Install-nvm-via-brew" class="headerlink" title="Install nvm via brew"></a>Install nvm via brew</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bew install nvm</span><br><span class="line">mkdir ~/.nvm</span><br><span class="line"><span class="comment">#put the following the in the .zshrc</span></span><br><span class="line">  <span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line">  [ -s <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span> ] &amp;&amp; . <span class="string">&quot;/usr/local/opt/nvm/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">  [ -s <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span> ] &amp;&amp; . <span class="string">&quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><p><a name="pkBHr"></a></p><h3 id="To-see-what-Node-versions-are-available-to-install-run"><a href="#To-see-what-Node-versions-are-available-to-install-run" class="headerlink" title="To see what Node versions are available to install run"></a>To see what Node versions are available to install run</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure><p><a name="2spx7"></a></p><h3 id="Install-the-LTS"><a href="#Install-the-LTS" class="headerlink" title="Install the LTS"></a>Install the LTS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v12.14.0</span><br></pre></td></tr></table></figure><p>After installing you can verify what is installed with</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><p><a name="Ai8HU"></a></p><h3 id="Swith-between-different-node-versions"><a href="#Swith-between-different-node-versions" class="headerlink" title="Swith between different node versions"></a>Swith between different node versions</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 11</span><br></pre></td></tr></table></figure><p><a name="D17ZW"></a></p><h1 id="Add-SSH-keys-for-the-Github-repo"><a href="#Add-SSH-keys-for-the-Github-repo" class="headerlink" title="Add SSH keys for the Github repo"></a>Add SSH keys for the Github repo</h1><p><a name="EljiX"></a></p><h2 id="Generate-SSh-keys"><a href="#Generate-SSh-keys" class="headerlink" title="Generate SSh keys"></a>Generate SSh keys</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p><a name="adding-your-ssh-key-to-the-ssh-agent"></a></p><h3 id="Adding-your-SSH-key-to-the-ssh-agent"><a href="#Adding-your-SSH-key-to-the-ssh-agent" class="headerlink" title="Adding your SSH key to the ssh-agent"></a><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#adding-your-ssh-key-to-the-ssh-agent">Adding your SSH key to the ssh-agent</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p><a name="IeIjJ"></a></p><h2 id="Copy-the-SSH-key-to-your-clipboard"><a href="#Copy-the-SSH-key-to-your-clipboard" class="headerlink" title="Copy the SSH key to your clipboard"></a>Copy the SSH key to your clipboard</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><a name="iP1c2"></a></p><h1 id="Checkout-Hexo-Blog-Repo"><a href="#Checkout-Hexo-Blog-Repo" class="headerlink" title="Checkout Hexo Blog Repo"></a>Checkout Hexo Blog Repo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:geekdanny/hexo.git</span><br></pre></td></tr></table></figure><p><a name="wM3H5"></a></p><h1 id="Install-Hexo-on-Mac"><a href="#Install-Hexo-on-Mac" class="headerlink" title="Install Hexo on Mac"></a>Install Hexo on Mac</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><a name="mhSbi"></a></p><h2 id="Add-Butterfly-Theme-Specific-Dependencies"><a href="#Add-Butterfly-Theme-Specific-Dependencies" class="headerlink" title="Add Butterfly Theme Specific Dependencies"></a>Add Butterfly Theme Specific Dependencies</h2><p>My hexo uses the Butterfly Theme, which requires some specific dependencies. The bufferfly repo located at <a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Go to the blog folder</span></span><br><span class="line"><span class="built_in">cd</span> /Users/admin/Development/personal/hexo/blog/</span><br><span class="line"><span class="comment">#clone the butterfly theme</span></span><br><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment">#Install cheerio</span></span><br><span class="line">npm install cheerio</span><br><span class="line"><span class="comment">#Install live2d</span></span><br><span class="line">npm install hexo-helper-live2d</span><br><span class="line"><span class="comment">#Install local search</span></span><br><span class="line">npm install hexo-generator-search</span><br><span class="line"><span class="comment">#Install WordCount</span></span><br><span class="line">npm install hexo-wordcount</span><br><span class="line"><span class="comment">#Install hexo-abbrlink</span></span><br><span class="line">npm install hexo-abbrlink</span><br></pre></td></tr></table></figure><p><a name="ov482"></a></p><h2 id="Sync-YuQue-with-Hexo"><a href="#Sync-YuQue-with-Hexo" class="headerlink" title="Sync YuQue with Hexo"></a>Sync YuQue with Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yuque-hexo</span><br></pre></td></tr></table></figure><p><a name="dhV06"></a></p><h3 id="Add-the-YuQue-config-to-the-package-json"><a href="#Add-the-YuQue-config-to-the-package-json" class="headerlink" title="Add the YuQue config to the package.json"></a>Add the YuQue config to the package.json</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;yuqueConfig&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;https://www.yuque.com/api/v2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;login&quot;</span>: <span class="string">&quot;geekdanny&quot;</span>,</span><br><span class="line">  <span class="string">&quot;repo&quot;</span>: <span class="string">&quot;hexo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mdNameFormat&quot;</span>: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">  <span class="string">&quot;postPath&quot;</span>: <span class="string">&quot;source/_posts/yuque&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Staring 2021, Github requested the user to use Personal acces token. The original username and password authentication is not supported.</p><h2 id="Step-by-Step-Guide-to-Changing-your-GitHub-Remote-Authentication-from-Password-to-Personal-Access-Token"><a href="#Step-by-Step-Guide-to-Changing-your-GitHub-Remote-Authentication-from-Password-to-Personal-Access-Token" class="headerlink" title="Step-by-Step Guide to Changing your GitHub Remote Authentication from Password to Personal Access Token"></a>Step-by-Step Guide to Changing your GitHub Remote Authentication from Password to Personal Access Token</h2><ol><li><strong>Go to</strong> <a href="https://github.com/settings/tokens"><strong>https://github.com/settings/tokens</strong></a> and Log In</li><li><strong>Click “Generate new token”</strong>, and then confirm your password</li></ol><p><img src="https://miro.medium.com/max/1400/1*J-HyZrYsdUpUjCxqqW5MUQ.png" alt="img"></p><ol start="3"><li><strong>Add a token name</strong> (you can use a naming convention to help keep track of who has which token if you like) <strong>and select your desired scopes/permissions</strong>. Basic repo read/write access can be achieved by simply checking the <strong>repo</strong> box (see below).</li></ol><p><img src="https://miro.medium.com/max/1400/1*k670owFzCI1QAwMTjjidqA.png" alt="img"></p><ol start="4"><li>Scroll down and <strong>click “Generate token”</strong>.</li></ol><p><img src="https://miro.medium.com/max/1400/1*cyFQkKXZjNBAwd1Kg_1DKw.png" alt="img"></p><ol start="5"><li><strong>Copy the token</strong> itself by clicking the blue clipboard. Keep this private! Do not share this token with anyone you don’t want to have access to your repo (I have included the full token in this example for demonstration purposes but I deleted it afterward).</li></ol><p><img src="https://miro.medium.com/max/1400/1*UYbumN0g7imzGMN5IfXQbQ.png" alt="img"></p><ol start="6"><li><p>Now change your remote locally. Fire up your local terminal and <code>cd</code> into your local repo directory. Note: if you need to <strong>remove the old remote</strong> do so now; for example, run a <code>git remote remove origin</code> to remove the <code>origin</code> remote.</p></li><li><p><strong>Add your new remote</strong> in the following format:<br><code>git remote add origin https://&lt;TOKEN&gt;@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.git</code></p></li></ol><p>In my case: https://<Perosnal Access Token>@github.com/geekdanny/hexo.git</p><ol start="8"><li>Now <strong>run</strong> <code>**git remote -v**</code> and you should see something like this:</li></ol><p><img src="https://miro.medium.com/max/1400/1*XYR2kggDxUEqd3V33SCHHA.png" alt="img"></p><p>That’s it! Now try <strong>pushing a test commit</strong> to ensuring everything is working correctly, and the GitHub warnings should stop.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Yuque </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoDaddy with Github Pages</title>
      <link href="/2019/12/29/7e78/"/>
      <url>/2019/12/29/7e78/</url>
      
        <content type="html"><![CDATA[<p>Github provides <a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/">docs</a> to wire up your domain with your gh-pages, but I’m going to cover the set up in 7simple steps</p><ol><li><p>First, the most difficult part…decide on a domain name and buy it on GoDaddy (<em>fingers-crossed you get the domain name you want and someone else hasn’t already taken it</em>).</p></li><li><p>On the home page of your account the in Domain Manager “Menu Domains” Go to all domains and select Use My Domains in Next Steps Colums</p></li></ol><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/TIuLcH.jpg" alt="TIuLcH"></p><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/uPic/NHUhQt.jpg" alt="NHUhQt"></p><ol start="3"><li>Within the DNS management page you will need to make five changes:</li></ol><ul><li><p>In the Type “A” row update the IP address to: 185.199.108.153<br>(<em>this will point your custom domain to GitHub’s server over HTTPS</em>)</p></li><li><p>In the CNAME row with Name “www” input your gh-pages website (<em>username.github.io</em>)</p></li><li><p>At the bottom click the “ADD” button and make 3 more Type “A” rows with the IP addresses of: 185.199.109.153, 185.199.110.153, 185.199.111.153<br>(<em>don’t worry when you leave the page it will alphabetize the types</em>)</p></li></ul><p><img src="https://cdn-images-1.medium.com/max/2008/1*Uqz2xPi6uWdBm8HqFwf9IQ.png" alt=""></p><ol start="4"><li>Go to your editor and in the repository of your website create a new file named “CNAME” in the root of your directory.</li></ol><p><img src="https://cdn-images-1.medium.com/max/2046/1*IYBtpap1lyj1xJzhM5V3GQ.png" alt=""></p><ol start="5"><li><p>In the “CNAME” file add your domain name purchased from GoDaddy.</p></li><li><p>Add, commit, and push your changes to Github.</p></li><li><p>Within your repository you will need to allow your website to be served through HTTPS. Check “Enforce HTTPS” in the Settings tab of your repo. This permission might take awhile because the certificate needs to be issued, but make sure you check this enforcement option when allowed.</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/1472/1*n3m607Jv1jIBXWZgg6gR2w.png" alt=""></p><p>You can confirm that your DNS is set-up correctly by using the <code>dig</code> command in your terminal with your custom domain. You should see that your “A” Types point to the IP addresses that you had specified in GoDaddy’s DNS management page, in other words you’re pointing your DNS to GitHub’s server. Below is an example of the <code>dig</code> command:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dig </span>gramabharathi.in</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1452/1*0WN6XMpUMFe8dWlJwsqVWg.png" alt=""></p><p>If you’re encountering any problems, this <a href="https://help.github.com/articles/troubleshooting-custom-domains/">GitHub Troubleshooting Custom Domains</a> documentation is a good reference.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> GoDaddy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to install Node on Mac using NVM and Homebrew</title>
      <link href="/2019/12/23/956a/"/>
      <url>/2019/12/23/956a/</url>
      
        <content type="html"><![CDATA[<p><strong>Version Manager makes it easy to install multiple versions of Node on a Mac. You install NVM using Homebrew, and if you don’t have Homebrew installed yet, read this article.</strong></p><h1 id="Step-1-Install-NVM"><a href="#Step-1-Install-NVM" class="headerlink" title="Step 1: Install NVM"></a>Step 1: Install NVM</h1><p>Install node version manager.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><h1 id="Step-2-Create-a-directory-for-NVM"><a href="#Step-2-Create-a-directory-for-NVM" class="headerlink" title="Step 2: Create a directory for NVM"></a>Step 2: Create a directory for NVM</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.nvm/</span><br></pre></td></tr></table></figure><h1 id="Step-3-Configure-your-environmental-variables"><a href="#Step-3-Configure-your-environmental-variables" class="headerlink" title="Step 3: Configure your environmental variables"></a>Step 3: Configure your environmental variables</h1><p>Either create or open your .bash_profile.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>Paste this.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=~/.nvm</span><br><span class="line"><span class="built_in">source</span> $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure><p>Execute the content we just pasted.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h1 id="Step-4-Double-check-your-work"><a href="#Step-4-Double-check-your-work" class="headerlink" title="Step 4: Double-check your work"></a>Step 4: Double-check your work</h1><p>If you’ve done everything correctly, you should be able to run the nvm command and ask it to list which versions node are available.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><h1 id="Step-5-Install-Node"><a href="#Step-5-Install-Node" class="headerlink" title="Step 5: Install Node"></a>Step 5: Install Node</h1><p>You can see a list of previously released versions of node from the NodeJS release page<br>Install Node 6.x.x.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 6.x.x</span><br></pre></td></tr></table></figure><p>Install Node 8.x.x</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 8.x.x</span><br></pre></td></tr></table></figure><p>Double-check your installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><h1 id="Step-6-Set-Node-Globally"><a href="#Step-6-Set-Node-Globally" class="headerlink" title="Step 6: Set Node Globally"></a>Step 6: Set Node Globally</h1><p>You can set a specific version of Node as your default.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">alias</span> default 12.x.x</span><br></pre></td></tr></table></figure><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>Error Example #1<br>If you are having issues with npm, then you might want to try this.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/lib/node_modules</span><br><span class="line">brew uninstall node</span><br></pre></td></tr></table></figure><p>Install Node version 12.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install node@12</span><br><span class="line"><span class="built_in">echo</span> prefix=~/.npm-packages &gt;&gt; ~/.npmrc</span><br><span class="line">curl -L https://www.npmjs.com/install.sh | sh</span><br></pre></td></tr></table></figure><p>Add this to your local variables so that npm and global npm are usable.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.npm-packages/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>Source</p><h2 id="Error-Example-2"><a href="#Error-Example-2" class="headerlink" title="Error Example #2"></a>Error Example #2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fetching: https://registry.npmjs.org/npm/-/npm-6.4.1.tgz</span><br><span class="line">up to date <span class="keyword">in</span> 0.027s</span><br><span class="line">sh: rimraf: <span class="built_in">command</span> not found</span><br><span class="line">npm ERR! file sh</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno ENOENT</span><br><span class="line">npm ERR! syscall spawn</span><br><span class="line">npm ERR! npm@6.4.1 prepare: `node bin/npm-cli.js --no-audit --no-timing prune --prefix=. --no-global &amp;&amp; rimraf <span class="built_in">test</span>/*/*/node_modules &amp;&amp; make -j4 doc`</span><br><span class="line">npm ERR! spawn ENOENT</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the npm@6.4.1 prepare script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/myaccount/.npm/_logs/*-debug.log</span><br><span class="line">npm ERR! code E404</span><br><span class="line">npm ERR! 404 Not Found: 0.99s@latest</span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/myaccount/.npm/_logs/*-debug.log</span><br><span class="line">It failed</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Install K8S on Centos 7.5</title>
      <link href="/2019/12/07/cbc1/"/>
      <url>/2019/12/07/cbc1/</url>
      
        <content type="html"><![CDATA[<h1 id="Install-K8S-on-Centos-7-5"><a href="#Install-K8S-on-Centos-7-5" class="headerlink" title="Install K8S on Centos 7.5"></a>Install K8S on Centos 7.5</h1><p>Kubernetes (K8s) uses a containerization platform like Docker, containerd, etc. and requires a Registry to download and use Docker images. Docker Hub is the global public registry that serves the purpose. However, there are situations, when we want to use Kubernetes (K8s) in a private network. In such a situation, we cannot access Docker Hub, therefore, we must configure a Private Docker Registry for our Kubernetes (K8s) cluster.</p><p>In this article, we will install Kubernetes (K8s) offline on CentOS 7. We are not configuring a Private Docker Registry here, but you can read our following articles to configure it by yourself.</p><ul><li>Configure Secure Registry with Docker-Distribution on CentOS 7</li><li>Configure a Private Docker Registry on CentOS 7<h2 id="Install-and-prepare-the-Centos7-5-Virtual-Machine"><a href="#Install-and-prepare-the-Centos7-5-Virtual-Machine" class="headerlink" title="Install and prepare the Centos7.5 Virtual Machine"></a>Install and prepare the Centos7.5 Virtual Machine</h2>I chose to install Centos7.5 VM on VSphere, you can choose to install th centos on your local virtualbox.<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/E8SrS9.png" alt=""><br>Finish the installation first. Make sure to turn on the network during the installation.<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/xRzPkJ.png" alt=""><br>In our example, we will use one <strong>master</strong> and one <strong>one node</strong>.<h3 id="Prepare-the-Virtual-Machine"><a href="#Prepare-the-Virtual-Machine" class="headerlink" title="Prepare the Virtual Machine"></a>Prepare the Virtual Machine</h3><h4 id="System-Specifiction"><a href="#System-Specifiction" class="headerlink" title="System Specifiction"></a>System Specifiction</h4>We have configured two CentOS 7 virtual machines.<table><thead><tr><th>Hostname</th><th>docker-online.example.com</th><th>docker-offline.example.com</th></tr></thead><tbody><tr><td>Operating System</td><td>CentOS 7.6</td><td>CentOS 7.6</td></tr><tr><td>Internet</td><td>Yes</td><td>No</td></tr><tr><td>Docker Version</td><td>B3</td><td>C3</td></tr></tbody></table></li></ul><h2 id="Download-the-kube"><a href="#Download-the-kube" class="headerlink" title="Download the kube"></a>Download the kube</h2>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduce K8S</title>
      <link href="/2019/12/07/1031/"/>
      <url>/2019/12/07/1031/</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h1><p><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/5UmgFx.png" alt=""></p><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>A physical machine. It is using to monitor and dispatch to each node to work. The master is the controller.</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>A node can be a virtual or physical machine. A node is a worker</p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ul><li>A pod is the smallest unit in K8S. A pod is a container of containers.</li><li>A pod contains can container many containers.</li><li>A pod is a process.</li><li>Each pod has its own IP address.</li><li>Each pod can communicate, but the communication has to go via kube-proxy.</li><li>Pause is a root container in the pod.</li><li>Pod should contain a complete module per container.</li><li>You can use the analogy that each pod is a virtual machine.</li><li>All the communication should go through the pause between it goes out the pod<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/wyVam5.png" alt=""><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2>Label is a description tag of a pod.<h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2>It is used to replicate, delete, add new pods. It monitors the system has enough pods between nodes.<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2>Service is a logic group. Usually, the same services are put into the same pod. E.g Backend services are grouped into one pod and frontend services are grouped in another pod.<br><img src="https://raw.githubusercontent.com/geekdanny/images/master/blog/4iMG69.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
